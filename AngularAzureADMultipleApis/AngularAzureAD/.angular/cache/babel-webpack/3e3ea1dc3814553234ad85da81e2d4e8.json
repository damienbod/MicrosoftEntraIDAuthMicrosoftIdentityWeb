{"ast":null,"code":"import { DOCUMENT, isPlatformBrowser, CommonModule } from '@angular/common';\nimport * as i1 from '@angular/common/http';\nimport { HttpHeaders, HttpParams, HttpErrorResponse, HttpResponse, HttpClientModule } from '@angular/common/http';\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject, PLATFORM_ID, InjectionToken, APP_INITIALIZER, NgModule } from '@angular/core';\nimport { ReplaySubject, from, of, BehaviorSubject, throwError, timer, Observable, Subject, forkJoin, TimeoutError } from 'rxjs';\nimport { map, mergeMap, tap, distinctUntilChanged, switchMap, retryWhen, catchError, retry, concatMap, take, timeout } from 'rxjs/operators';\nimport { base64url } from 'rfc4648';\nimport * as i2 from '@angular/router';\n\nclass HttpBaseService {\n  constructor(http) {\n    this.http = http;\n  }\n\n  get(url, params) {\n    return this.http.get(url, params);\n  }\n\n  post(url, body, params) {\n    return this.http.post(url, body, params);\n  }\n\n}\n\nHttpBaseService.ɵfac = function HttpBaseService_Factory(t) {\n  return new (t || HttpBaseService)(i0.ɵɵinject(i1.HttpClient));\n};\n\nHttpBaseService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: HttpBaseService,\n  factory: HttpBaseService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(HttpBaseService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i1.HttpClient\n    }];\n  }, null);\n})();\n\nclass ConfigurationProvider {\n  constructor() {\n    this.configsInternal = {};\n  }\n\n  hasAtLeastOneConfig() {\n    return Object.keys(this.configsInternal).length > 0;\n  }\n\n  hasManyConfigs() {\n    return Object.keys(this.configsInternal).length > 1;\n  }\n\n  setConfig(readyConfig) {\n    const {\n      configId\n    } = readyConfig;\n    this.configsInternal[configId] = readyConfig;\n  }\n\n  getOpenIDConfiguration(configId) {\n    if (!!configId) {\n      return this.configsInternal[configId] || null;\n    }\n\n    const [, value] = Object.entries(this.configsInternal)[0] || [[null, null]];\n    return value || null;\n  }\n\n  getAllConfigurations() {\n    return Object.values(this.configsInternal);\n  }\n\n}\n\nConfigurationProvider.ɵfac = function ConfigurationProvider_Factory(t) {\n  return new (t || ConfigurationProvider)();\n};\n\nConfigurationProvider.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ConfigurationProvider,\n  factory: ConfigurationProvider.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ConfigurationProvider, [{\n    type: Injectable\n  }], null, null);\n})();\n\nconst NGSW_CUSTOM_PARAM = 'ngsw-bypass';\n\nclass DataService {\n  constructor(httpClient, configurationProvider) {\n    this.httpClient = httpClient;\n    this.configurationProvider = configurationProvider;\n  }\n\n  get(url, configId, token) {\n    const headers = this.prepareHeaders(token);\n    const params = this.prepareParams(configId);\n    return this.httpClient.get(url, {\n      headers,\n      params\n    });\n  }\n\n  post(url, body, configId, headersParams) {\n    const headers = headersParams || this.prepareHeaders();\n    const params = this.prepareParams(configId);\n    return this.httpClient.post(url, body, {\n      headers,\n      params\n    });\n  }\n\n  prepareHeaders(token) {\n    let headers = new HttpHeaders();\n    headers = headers.set('Accept', 'application/json');\n\n    if (!!token) {\n      headers = headers.set('Authorization', 'Bearer ' + decodeURIComponent(token));\n    }\n\n    return headers;\n  }\n\n  prepareParams(configId) {\n    let params = new HttpParams();\n    const {\n      ngswBypass\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (ngswBypass) {\n      params = params.set(NGSW_CUSTOM_PARAM, '');\n    }\n\n    return params;\n  }\n\n}\n\nDataService.ɵfac = function DataService_Factory(t) {\n  return new (t || DataService)(i0.ɵɵinject(HttpBaseService), i0.ɵɵinject(ConfigurationProvider));\n};\n\nDataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DataService,\n  factory: DataService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: HttpBaseService\n    }, {\n      type: ConfigurationProvider\n    }];\n  }, null);\n})(); // eslint-disable-next-line no-shadow\n\n\nvar EventTypes;\n\n(function (EventTypes) {\n  /**\r\n   *  This only works in the AppModule Constructor\r\n   */\n  EventTypes[EventTypes[\"ConfigLoaded\"] = 0] = \"ConfigLoaded\";\n  EventTypes[EventTypes[\"ConfigLoadingFailed\"] = 1] = \"ConfigLoadingFailed\";\n  EventTypes[EventTypes[\"CheckSessionReceived\"] = 2] = \"CheckSessionReceived\";\n  EventTypes[EventTypes[\"UserDataChanged\"] = 3] = \"UserDataChanged\";\n  EventTypes[EventTypes[\"NewAuthenticationResult\"] = 4] = \"NewAuthenticationResult\";\n  EventTypes[EventTypes[\"TokenExpired\"] = 5] = \"TokenExpired\";\n  EventTypes[EventTypes[\"IdTokenExpired\"] = 6] = \"IdTokenExpired\";\n  EventTypes[EventTypes[\"SilentRenewStarted\"] = 7] = \"SilentRenewStarted\";\n})(EventTypes || (EventTypes = {})); // eslint-disable-next-line no-shadow\n\n\nvar LogLevel;\n\n(function (LogLevel) {\n  LogLevel[LogLevel[\"None\"] = 0] = \"None\";\n  LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\n  LogLevel[LogLevel[\"Warn\"] = 2] = \"Warn\";\n  LogLevel[LogLevel[\"Error\"] = 3] = \"Error\";\n})(LogLevel || (LogLevel = {}));\n\nclass LoggerService {\n  constructor(configurationProvider) {\n    this.configurationProvider = configurationProvider;\n  }\n\n  logError(configId, message, ...args) {\n    if (!!configId) {\n      this.logErrorWithConfig(configId, message, ...args);\n    } else {\n      this.logErrorWithoutConfig(message, ...args);\n    }\n  }\n\n  logWarning(configId, message, ...args) {\n    if (!!configId) {\n      this.logWarningWithConfig(configId, message, ...args);\n    } else {\n      this.logWarningWithoutConfig(message, ...args);\n    }\n  }\n\n  logDebug(configId, message, ...args) {\n    if (!this.logLevelIsSet(configId)) {\n      return;\n    }\n\n    if (this.loggingIsTurnedOff(configId)) {\n      return;\n    }\n\n    if (!this.currentLogLevelIsEqualOrSmallerThan(configId, LogLevel.Debug)) {\n      return;\n    }\n\n    if (!!args && !!args.length) {\n      console.log(`[DEBUG] ${configId} - ${message}`, ...args);\n    } else {\n      console.log(`[DEBUG] ${configId} - ${message}`);\n    }\n  }\n\n  logWarningWithoutConfig(message, ...args) {\n    if (!!args && !!args.length) {\n      console.warn(`[WARN] - ${message}`, ...args);\n    } else {\n      console.warn(`[WARN] - ${message}`);\n    }\n  }\n\n  logWarningWithConfig(configId, message, ...args) {\n    if (!this.logLevelIsSet(configId)) {\n      return;\n    }\n\n    if (this.loggingIsTurnedOff(configId)) {\n      return;\n    }\n\n    if (!this.currentLogLevelIsEqualOrSmallerThan(configId, LogLevel.Warn)) {\n      return;\n    }\n\n    if (!!args && !!args.length) {\n      console.warn(`[WARN] ${configId} - ${message}`, ...args);\n    } else {\n      console.warn(`[WARN] ${configId} - ${message}`);\n    }\n  }\n\n  logErrorWithConfig(configId, message, ...args) {\n    if (this.loggingIsTurnedOff(configId)) {\n      return;\n    }\n\n    if (!!args && !!args.length) {\n      console.error(`[ERROR] ${configId} - ${message}`, ...args);\n    } else {\n      console.error(`[ERROR] ${configId} - ${message}`);\n    }\n  }\n\n  logErrorWithoutConfig(message, ...args) {\n    if (!!args && !!args.length) {\n      console.error(`[ERROR] - ${message}`, ...args);\n    } else {\n      console.error(`[ERROR] - ${message}`);\n    }\n  }\n\n  currentLogLevelIsEqualOrSmallerThan(configId, logLevelToCompare) {\n    const {\n      logLevel\n    } = this.configurationProvider.getOpenIDConfiguration(configId) || {};\n    return logLevel <= logLevelToCompare;\n  }\n\n  logLevelIsSet(configId) {\n    const {\n      logLevel\n    } = this.configurationProvider.getOpenIDConfiguration(configId) || {};\n\n    if (logLevel === null) {\n      return false;\n    }\n\n    if (logLevel === undefined) {\n      return false;\n    }\n\n    return true;\n  }\n\n  loggingIsTurnedOff(configId) {\n    const {\n      logLevel\n    } = this.configurationProvider.getOpenIDConfiguration(configId) || {};\n    return logLevel === LogLevel.None;\n  }\n\n}\n\nLoggerService.ɵfac = function LoggerService_Factory(t) {\n  return new (t || LoggerService)(i0.ɵɵinject(ConfigurationProvider));\n};\n\nLoggerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: LoggerService,\n  factory: LoggerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LoggerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ConfigurationProvider\n    }];\n  }, null);\n})();\n\nclass BrowserStorageService {\n  constructor(configProvider, loggerService) {\n    this.configProvider = configProvider;\n    this.loggerService = loggerService;\n  }\n\n  read(key, configId) {\n    if (!this.hasStorage()) {\n      this.loggerService.logDebug(configId, `Wanted to read '${key}' but Storage was undefined`);\n      return null;\n    }\n\n    const storage = this.getStorage(configId);\n\n    if (!storage) {\n      this.loggerService.logDebug(configId, `Wanted to read config for '${configId}' but Storage was falsy`);\n      return null;\n    }\n\n    const storedConfig = storage.read(configId);\n\n    if (!storedConfig) {\n      return null;\n    }\n\n    return JSON.parse(storedConfig);\n  }\n\n  write(value, configId) {\n    if (!this.hasStorage()) {\n      this.loggerService.logDebug(configId, `Wanted to write '${value}' but Storage was falsy`);\n      return false;\n    }\n\n    const storage = this.getStorage(configId);\n\n    if (!storage) {\n      this.loggerService.logDebug(configId, `Wanted to write '${value}' but Storage was falsy`);\n      return false;\n    }\n\n    value = value || null;\n    storage.write(configId, JSON.stringify(value));\n    return true;\n  }\n\n  remove(key, configId) {\n    if (!this.hasStorage()) {\n      this.loggerService.logDebug(configId, `Wanted to remove '${key}' but Storage was falsy`);\n      return false;\n    }\n\n    const storage = this.getStorage(configId);\n\n    if (!storage) {\n      this.loggerService.logDebug(configId, `Wanted to write '${key}' but Storage was falsy`);\n      return false;\n    }\n\n    storage.remove(key);\n    return true;\n  } // TODO THIS STORAGE WANTS AN ID BUT CLEARS EVERYTHING\n\n\n  clear(configId) {\n    if (!this.hasStorage()) {\n      this.loggerService.logDebug(configId, `Wanted to clear storage but Storage was falsy`);\n      return false;\n    }\n\n    const storage = this.getStorage(configId);\n\n    if (!storage) {\n      this.loggerService.logDebug(configId, `Wanted to clear storage but Storage was falsy`);\n      return false;\n    }\n\n    storage.clear();\n    return true;\n  }\n\n  getStorage(configId) {\n    const {\n      storage\n    } = this.configProvider.getOpenIDConfiguration(configId) || {};\n    return storage;\n  }\n\n  hasStorage() {\n    return typeof Storage !== 'undefined';\n  }\n\n}\n\nBrowserStorageService.ɵfac = function BrowserStorageService_Factory(t) {\n  return new (t || BrowserStorageService)(i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(LoggerService));\n};\n\nBrowserStorageService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: BrowserStorageService,\n  factory: BrowserStorageService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(BrowserStorageService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ConfigurationProvider\n    }, {\n      type: LoggerService\n    }];\n  }, null);\n})();\n\nclass StoragePersistenceService {\n  constructor(browserStorageService) {\n    this.browserStorageService = browserStorageService;\n  }\n\n  read(key, configId) {\n    const storedConfig = this.browserStorageService.read(key, configId) || {};\n    return storedConfig[key];\n  }\n\n  write(key, value, configId) {\n    const storedConfig = this.browserStorageService.read(key, configId) || {};\n    storedConfig[key] = value;\n    this.browserStorageService.write(storedConfig, configId);\n  }\n\n  remove(key, configId) {\n    const storedConfig = this.browserStorageService.read(key, configId) || {};\n    delete storedConfig[key];\n    this.browserStorageService.write(storedConfig, configId);\n  }\n\n  clear(configId) {\n    this.browserStorageService.clear(configId);\n  }\n\n  resetStorageFlowData(configId) {\n    this.remove('session_state', configId);\n    this.remove('storageSilentRenewRunning', configId);\n    this.remove('codeVerifier', configId);\n    this.remove('userData', configId);\n    this.remove('storageCustomParamsAuthRequest', configId);\n    this.remove('access_token_expires_at', configId);\n    this.remove('storageCustomParamsRefresh', configId);\n    this.remove('storageCustomParamsEndSession', configId);\n  }\n\n  resetAuthStateInStorage(configId) {\n    this.remove('authzData', configId);\n    this.remove('authnResult', configId);\n  }\n\n  getAccessToken(configId) {\n    return this.read('authzData', configId);\n  }\n\n  getIdToken(configId) {\n    var _a;\n\n    return (_a = this.read('authnResult', configId)) === null || _a === void 0 ? void 0 : _a.id_token;\n  }\n\n  getRefreshToken(configId) {\n    var _a;\n\n    return (_a = this.read('authnResult', configId)) === null || _a === void 0 ? void 0 : _a.refresh_token;\n  }\n\n  getAuthenticationResult(configId) {\n    return this.read('authnResult', configId);\n  }\n\n}\n\nStoragePersistenceService.ɵfac = function StoragePersistenceService_Factory(t) {\n  return new (t || StoragePersistenceService)(i0.ɵɵinject(BrowserStorageService));\n};\n\nStoragePersistenceService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StoragePersistenceService,\n  factory: StoragePersistenceService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StoragePersistenceService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: BrowserStorageService\n    }];\n  }, null);\n})();\n\nclass PublicEventsService {\n  constructor() {\n    this.notify = new ReplaySubject(1);\n  }\n  /**\r\n   * Fires a new event.\r\n   *\r\n   * @param type The event type.\r\n   * @param value The event value.\r\n   */\n\n\n  fireEvent(type, value) {\n    this.notify.next({\n      type,\n      value\n    });\n  }\n  /**\r\n   * Wires up the event notification observable.\r\n   */\n\n\n  registerForEvents() {\n    return this.notify.asObservable();\n  }\n\n}\n\nPublicEventsService.ɵfac = function PublicEventsService_Factory(t) {\n  return new (t || PublicEventsService)();\n};\n\nPublicEventsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PublicEventsService,\n  factory: PublicEventsService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PublicEventsService, [{\n    type: Injectable\n  }], null, null);\n})();\n\nconst PARTS_OF_TOKEN = 3;\n\nclass TokenHelperService {\n  constructor(loggerService) {\n    this.loggerService = loggerService;\n  }\n\n  getTokenExpirationDate(dataIdToken) {\n    if (!dataIdToken.hasOwnProperty('exp')) {\n      return new Date(new Date().toUTCString());\n    }\n\n    const date = new Date(0); // The 0 here is the key, which sets the date to the epoch\n\n    date.setUTCSeconds(dataIdToken.exp);\n    return date;\n  }\n\n  getSigningInputFromToken(token, encoded, configId) {\n    if (!this.tokenIsValid(token, configId)) {\n      return '';\n    }\n\n    const header = this.getHeaderFromToken(token, encoded, configId);\n    const payload = this.getPayloadFromToken(token, encoded, configId);\n    return [header, payload].join('.');\n  }\n\n  getHeaderFromToken(token, encoded, configId) {\n    if (!this.tokenIsValid(token, configId)) {\n      return {};\n    }\n\n    return this.getPartOfToken(token, 0, encoded);\n  }\n\n  getPayloadFromToken(token, encoded, configId) {\n    if (!this.tokenIsValid(token, configId)) {\n      return {};\n    }\n\n    return this.getPartOfToken(token, 1, encoded);\n  }\n\n  getSignatureFromToken(token, encoded, configId) {\n    if (!this.tokenIsValid(token, configId)) {\n      return {};\n    }\n\n    return this.getPartOfToken(token, 2, encoded);\n  }\n\n  getPartOfToken(token, index, encoded) {\n    const partOfToken = this.extractPartOfToken(token, index);\n\n    if (encoded) {\n      return partOfToken;\n    }\n\n    const result = this.urlBase64Decode(partOfToken);\n    return JSON.parse(result);\n  }\n\n  urlBase64Decode(str) {\n    let output = str.replace(/-/g, '+').replace(/_/g, '/');\n\n    switch (output.length % 4) {\n      case 0:\n        break;\n\n      case 2:\n        output += '==';\n        break;\n\n      case 3:\n        output += '=';\n        break;\n\n      default:\n        throw Error('Illegal base64url string!');\n    }\n\n    const decoded = typeof window !== 'undefined' ? window.atob(output) : Buffer.from(output, 'base64').toString('binary');\n\n    try {\n      // Going backwards: from byte stream, to percent-encoding, to original string.\n      return decodeURIComponent(decoded.split('').map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join(''));\n    } catch (err) {\n      return decoded;\n    }\n  }\n\n  tokenIsValid(token, configId) {\n    if (!token) {\n      this.loggerService.logError(configId, `token '${token}' is not valid --> token falsy`);\n      return false;\n    }\n\n    if (!token.includes('.')) {\n      this.loggerService.logError(configId, `token '${token}' is not valid --> no dots included`);\n      return false;\n    }\n\n    const parts = token.split('.');\n\n    if (parts.length !== PARTS_OF_TOKEN) {\n      this.loggerService.logError(configId, `token '${token}' is not valid --> token has to have exactly ${PARTS_OF_TOKEN - 1} dots`);\n      return false;\n    }\n\n    return true;\n  }\n\n  extractPartOfToken(token, index) {\n    return token.split('.')[index];\n  }\n\n}\n\nTokenHelperService.ɵfac = function TokenHelperService_Factory(t) {\n  return new (t || TokenHelperService)(i0.ɵɵinject(LoggerService));\n};\n\nTokenHelperService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: TokenHelperService,\n  factory: TokenHelperService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TokenHelperService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }];\n  }, null);\n})();\n\nclass JwtWindowCryptoService {\n  constructor() {\n    this.crypto = window.crypto || window.msCrypto; // for IE11\n  }\n\n  generateCodeChallenge(codeVerifier) {\n    return this.calcHash(codeVerifier).pipe(map(challengeRaw => base64UrlEncode(challengeRaw)));\n  }\n\n  generateAtHash(accessToken, algorithm) {\n    return this.calcHash(accessToken, algorithm).pipe(map(tokenHash => {\n      let substr = tokenHash.substr(0, tokenHash.length / 2);\n      const tokenHashBase64 = btoa(substr);\n      return tokenHashBase64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n    }));\n  }\n\n  calcHash(valueToHash, algorithm = 'SHA-256') {\n    const msgBuffer = new TextEncoder().encode(valueToHash);\n    return from(this.crypto.subtle.digest(algorithm, msgBuffer)).pipe(map(hashBuffer => {\n      const hashArray = Array.from(new Uint8Array(hashBuffer));\n      return this.toHashString(hashArray);\n    }));\n  }\n\n  toHashString(byteArray) {\n    let result = '';\n\n    for (let e of byteArray) {\n      result += String.fromCharCode(e);\n    }\n\n    return result;\n  }\n\n}\n\nJwtWindowCryptoService.ɵfac = function JwtWindowCryptoService_Factory(t) {\n  return new (t || JwtWindowCryptoService)();\n};\n\nJwtWindowCryptoService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: JwtWindowCryptoService,\n  factory: JwtWindowCryptoService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(JwtWindowCryptoService, [{\n    type: Injectable\n  }], null, null);\n})();\n\nfunction base64UrlEncode(str) {\n  const base64 = btoa(str);\n  return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n} // http://openid.net/specs/openid-connect-implicit-1_0.html\n// id_token\n// id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)\n// MUST exactly match the value of the iss (issuer) Claim.\n//\n// id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified\n// by the iss (issuer) Claim as an audience.The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience,\n// or if it contains additional audiences not trusted by the Client.\n//\n// id_token C3: If the ID Token contains multiple audiences, the Client SHOULD verify that an azp Claim is present.\n//\n// id_token C4: If an azp (authorized party) Claim is present, the Client SHOULD verify that its client_id is the Claim Value.\n//\n// id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the\n// alg Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.\n//\n// id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the OpenID Connect\n// Core 1.0\n// [OpenID.Core] specification.\n//\n// id_token C7: The current time MUST be before the time represented by the exp Claim (possibly allowing for some small leeway to account\n// for clock skew).\n//\n// id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,\n// limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.\n//\n// id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one that was sent\n// in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.The precise method for detecting replay attacks\n// is Client specific.\n//\n// id_token C10: If the acr Claim was requested, the Client SHOULD check that the asserted Claim Value is appropriate.\n// The meaning and processing of acr Claim Values is out of scope for this document.\n//\n// id_token C11: When a max_age request is made, the Client SHOULD check the auth_time Claim value and request re- authentication\n// if it determines too much time has elapsed since the last End- User authentication.\n// Access Token Validation\n// access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]\n// for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.\n// access_token C2: Take the left- most half of the hash and base64url- encode it.\n// access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash is present\n// in the ID Token.\n\n\nclass TokenValidationService {\n  constructor(tokenHelperService, loggerService, jwtWindowCryptoService) {\n    this.tokenHelperService = tokenHelperService;\n    this.loggerService = loggerService;\n    this.jwtWindowCryptoService = jwtWindowCryptoService;\n    this.keyAlgorithms = ['HS256', 'HS384', 'HS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'PS256', 'PS384', 'PS512'];\n    this.cyptoObj = window.crypto || window.msCrypto; // for IE11\n  } // id_token C7: The current time MUST be before the time represented by the exp Claim\n  // (possibly allowing for some small leeway to account for clock skew).\n\n\n  hasIdTokenExpired(token, configId, offsetSeconds) {\n    const decoded = this.tokenHelperService.getPayloadFromToken(token, false, configId);\n    return !this.validateIdTokenExpNotExpired(decoded, configId, offsetSeconds);\n  } // id_token C7: The current time MUST be before the time represented by the exp Claim\n  // (possibly allowing for some small leeway to account for clock skew).\n\n\n  validateIdTokenExpNotExpired(decodedIdToken, configId, offsetSeconds) {\n    const tokenExpirationDate = this.tokenHelperService.getTokenExpirationDate(decodedIdToken);\n    offsetSeconds = offsetSeconds || 0;\n\n    if (!tokenExpirationDate) {\n      return false;\n    }\n\n    const tokenExpirationValue = tokenExpirationDate.valueOf();\n    const nowWithOffset = new Date(new Date().toUTCString()).valueOf() + offsetSeconds * 1000;\n    const tokenNotExpired = tokenExpirationValue > nowWithOffset;\n    this.loggerService.logDebug(configId, `Has idToken expired: ${!tokenNotExpired} --> expires in ${this.millisToMinutesAndSeconds(tokenExpirationValue - nowWithOffset)} , ${new Date(tokenExpirationValue).toLocaleTimeString()} > ${new Date(nowWithOffset).toLocaleTimeString()}`); // Token not expired?\n\n    return tokenNotExpired;\n  }\n\n  validateAccessTokenNotExpired(accessTokenExpiresAt, configId, offsetSeconds) {\n    // value is optional, so if it does not exist, then it has not expired\n    if (!accessTokenExpiresAt) {\n      return true;\n    }\n\n    offsetSeconds = offsetSeconds || 0;\n    const accessTokenExpirationValue = accessTokenExpiresAt.valueOf();\n    const nowWithOffset = new Date(new Date().toUTCString()).valueOf() + offsetSeconds * 1000;\n    const tokenNotExpired = accessTokenExpirationValue > nowWithOffset;\n    this.loggerService.logDebug(configId, `Has accessToken expired: ${!tokenNotExpired} --> expires in ${this.millisToMinutesAndSeconds(accessTokenExpirationValue - nowWithOffset)} , ${new Date(accessTokenExpirationValue).toLocaleTimeString()} > ${new Date(nowWithOffset).toLocaleTimeString()}`); // access token not expired?\n\n    return tokenNotExpired;\n  } // iss\n  // REQUIRED. Issuer Identifier for the Issuer of the response.The iss value is a case-sensitive URL using the\n  // https scheme that contains scheme, host,\n  // and optionally, port number and path components and no query or fragment components.\n  //\n  // sub\n  // REQUIRED. Subject Identifier.Locally unique and never reassigned identifier within the Issuer for the End- User,\n  // which is intended to be consumed by the Client, e.g., 24400320 or AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4.\n  // It MUST NOT exceed 255 ASCII characters in length.The sub value is a case-sensitive string.\n  //\n  // aud\n  // REQUIRED. Audience(s) that this ID Token is intended for. It MUST contain the OAuth 2.0 client_id of the Relying Party as an\n  // audience value.\n  // It MAY also contain identifiers for other audiences.In the general case, the aud value is an array of case-sensitive strings.\n  // In the common special case when there is one audience, the aud value MAY be a single case-sensitive string.\n  //\n  // exp\n  // REQUIRED. Expiration time on or after which the ID Token MUST NOT be accepted for processing.\n  // The processing of this parameter requires that the current date/ time MUST be before the expiration date/ time listed in the value.\n  // Implementers MAY provide for some small leeway, usually no more than a few minutes, to account for clock skew.\n  // Its value is a JSON [RFC7159] number representing the number of seconds from 1970- 01 - 01T00: 00:00Z as measured in UTC until\n  // the date/ time.\n  // See RFC 3339 [RFC3339] for details regarding date/ times in general and UTC in particular.\n  //\n  // iat\n  // REQUIRED. Time at which the JWT was issued. Its value is a JSON number representing the number of seconds from\n  // 1970- 01 - 01T00: 00: 00Z as measured\n  // in UTC until the date/ time.\n\n\n  validateRequiredIdToken(dataIdToken, configId) {\n    let validated = true;\n\n    if (!dataIdToken.hasOwnProperty('iss')) {\n      validated = false;\n      this.loggerService.logWarning(configId, 'iss is missing, this is required in the id_token');\n    }\n\n    if (!dataIdToken.hasOwnProperty('sub')) {\n      validated = false;\n      this.loggerService.logWarning(configId, 'sub is missing, this is required in the id_token');\n    }\n\n    if (!dataIdToken.hasOwnProperty('aud')) {\n      validated = false;\n      this.loggerService.logWarning(configId, 'aud is missing, this is required in the id_token');\n    }\n\n    if (!dataIdToken.hasOwnProperty('exp')) {\n      validated = false;\n      this.loggerService.logWarning(configId, 'exp is missing, this is required in the id_token');\n    }\n\n    if (!dataIdToken.hasOwnProperty('iat')) {\n      validated = false;\n      this.loggerService.logWarning(configId, 'iat is missing, this is required in the id_token');\n    }\n\n    return validated;\n  } // id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,\n  // limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.\n\n\n  validateIdTokenIatMaxOffset(dataIdToken, maxOffsetAllowedInSeconds, disableIatOffsetValidation, configId) {\n    if (disableIatOffsetValidation) {\n      return true;\n    }\n\n    if (!dataIdToken.hasOwnProperty('iat')) {\n      return false;\n    }\n\n    const dateTimeIatIdToken = new Date(0); // The 0 here is the key, which sets the date to the epoch\n\n    dateTimeIatIdToken.setUTCSeconds(dataIdToken.iat);\n    maxOffsetAllowedInSeconds = maxOffsetAllowedInSeconds || 0;\n    const nowInUtc = new Date(new Date().toUTCString());\n    const diff = nowInUtc.valueOf() - dateTimeIatIdToken.valueOf();\n    const maxOffsetAllowedInMilliseconds = maxOffsetAllowedInSeconds * 1000;\n    this.loggerService.logDebug(configId, `validate id token iat max offset ${diff} < ${maxOffsetAllowedInMilliseconds}`);\n\n    if (diff > 0) {\n      return diff < maxOffsetAllowedInMilliseconds;\n    }\n\n    return -diff < maxOffsetAllowedInMilliseconds;\n  } // id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one\n  // that was sent in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.\n  // The precise method for detecting replay attacks is Client specific.\n  // However the nonce claim SHOULD not be present for the refresh_token grant type\n  // https://bitbucket.org/openid/connect/issues/1025/ambiguity-with-how-nonce-is-handled-on\n  // The current spec is ambiguous and KeyCloak does send it.\n\n\n  validateIdTokenNonce(dataIdToken, localNonce, ignoreNonceAfterRefresh, configId) {\n    const isFromRefreshToken = (dataIdToken.nonce === undefined || ignoreNonceAfterRefresh) && localNonce === TokenValidationService.refreshTokenNoncePlaceholder;\n\n    if (!isFromRefreshToken && dataIdToken.nonce !== localNonce) {\n      this.loggerService.logDebug(configId, 'Validate_id_token_nonce failed, dataIdToken.nonce: ' + dataIdToken.nonce + ' local_nonce:' + localNonce);\n      return false;\n    }\n\n    return true;\n  } // id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)\n  // MUST exactly match the value of the iss (issuer) Claim.\n\n\n  validateIdTokenIss(dataIdToken, authWellKnownEndpointsIssuer, configId) {\n    if (dataIdToken.iss !== authWellKnownEndpointsIssuer) {\n      this.loggerService.logDebug(configId, 'Validate_id_token_iss failed, dataIdToken.iss: ' + dataIdToken.iss + ' authWellKnownEndpoints issuer:' + authWellKnownEndpointsIssuer);\n      return false;\n    }\n\n    return true;\n  } // id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified\n  // by the iss (issuer) Claim as an audience.\n  // The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience, or if it contains additional audiences\n  // not trusted by the Client.\n\n\n  validateIdTokenAud(dataIdToken, aud, configId) {\n    if (Array.isArray(dataIdToken.aud)) {\n      const result = dataIdToken.aud.includes(aud);\n\n      if (!result) {\n        this.loggerService.logDebug(configId, 'Validate_id_token_aud array failed, dataIdToken.aud: ' + dataIdToken.aud + ' client_id:' + aud);\n        return false;\n      }\n\n      return true;\n    } else if (dataIdToken.aud !== aud) {\n      this.loggerService.logDebug(configId, 'Validate_id_token_aud failed, dataIdToken.aud: ' + dataIdToken.aud + ' client_id:' + aud);\n      return false;\n    }\n\n    return true;\n  }\n\n  validateIdTokenAzpExistsIfMoreThanOneAud(dataIdToken) {\n    if (!dataIdToken) {\n      return false;\n    }\n\n    if (Array.isArray(dataIdToken.aud) && dataIdToken.aud.length > 1 && !dataIdToken.azp) {\n      return false;\n    }\n\n    return true;\n  } // If an azp (authorized party) Claim is present, the Client SHOULD verify that its client_id is the Claim Value.\n\n\n  validateIdTokenAzpValid(dataIdToken, clientId) {\n    if (!(dataIdToken === null || dataIdToken === void 0 ? void 0 : dataIdToken.azp)) {\n      return true;\n    }\n\n    if (dataIdToken.azp === clientId) {\n      return true;\n    }\n\n    return false;\n  }\n\n  validateStateFromHashCallback(state, localState, configId) {\n    if (state !== localState) {\n      this.loggerService.logDebug(configId, 'ValidateStateFromHashCallback failed, state: ' + state + ' local_state:' + localState);\n      return false;\n    }\n\n    return true;\n  } // id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the alg\n  // Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.\n  // id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the\n  // OpenID Connect Core 1.0 [OpenID.Core] specification.\n\n\n  validateSignatureIdToken(idToken, jwtkeys, configId) {\n    if (!jwtkeys || !jwtkeys.keys) {\n      return of(false);\n    }\n\n    const headerData = this.tokenHelperService.getHeaderFromToken(idToken, false, configId);\n\n    if (Object.keys(headerData).length === 0 && headerData.constructor === Object) {\n      this.loggerService.logWarning(configId, 'id token has no header data');\n      return of(false);\n    }\n\n    const kid = headerData.kid;\n    let alg = headerData.alg;\n    let keys = jwtkeys.keys;\n    let key;\n\n    if (!this.keyAlgorithms.includes(alg)) {\n      this.loggerService.logWarning(configId, 'alg not supported', alg);\n      return of(false);\n    }\n\n    if (kid) {\n      key = keys.find(k => k['kid'] === kid);\n    } else {\n      let kty = this.alg2kty(alg);\n      let matchingKeys = keys.filter(k => k.kty === kty && k.use === 'sig');\n\n      if (matchingKeys.length > 1) {\n        let error = 'More than one matching key found. Please specify a kid in the id_token header.';\n        console.error(error);\n        return of(false);\n      } else if (matchingKeys.length === 1) {\n        key = matchingKeys[0];\n      }\n    }\n\n    const algorithm = this.getImportAlg(alg);\n    const signingInput = this.tokenHelperService.getSigningInputFromToken(idToken, true, configId);\n    const rawSignature = this.tokenHelperService.getSignatureFromToken(idToken, true, configId);\n    const agent = window.navigator.userAgent.toLowerCase();\n\n    if (agent.indexOf('firefox') > -1 && key.kty === 'EC') {\n      key.alg = '';\n    }\n\n    return from(this.cyptoObj.subtle.importKey('jwk', key, algorithm, false, ['verify'])).pipe(mergeMap(cryptoKey => {\n      const signature = base64url.parse(rawSignature, {\n        loose: true\n      });\n      const algorithm = this.getVerifyAlg(alg);\n      return from(this.cyptoObj.subtle.verify(algorithm, cryptoKey, signature, new TextEncoder().encode(signingInput)));\n    }), tap(isValid => {\n      if (!isValid) {\n        this.loggerService.logWarning(configId, 'incorrect Signature, validation failed for id_token');\n      }\n    }));\n  }\n\n  getImportAlg(alg) {\n    switch (alg.charAt(0)) {\n      case 'R':\n        if (alg.includes('256')) {\n          return {\n            name: 'RSASSA-PKCS1-v1_5',\n            hash: 'SHA-256'\n          };\n        } else if (alg.includes('384')) {\n          return {\n            name: 'RSASSA-PKCS1-v1_5',\n            hash: 'SHA-384'\n          };\n        } else if (alg.includes('512')) {\n          return {\n            name: 'RSASSA-PKCS1-v1_5',\n            hash: 'SHA-512'\n          };\n        } else {\n          return null;\n        }\n\n      case 'E':\n        if (alg.includes('256')) {\n          return {\n            name: 'ECDSA',\n            namedCurve: 'P-256'\n          };\n        } else if (alg.includes('384')) {\n          return {\n            name: 'ECDSA',\n            namedCurve: 'P-384'\n          };\n        } else {\n          return null;\n        }\n\n      default:\n        return null;\n    }\n  }\n\n  getVerifyAlg(alg) {\n    switch (alg.charAt(0)) {\n      case 'R':\n        return {\n          name: 'RSASSA-PKCS1-v1_5',\n          hash: 'SHA-256'\n        };\n\n      case 'E':\n        if (alg.includes('256')) {\n          return {\n            name: 'ECDSA',\n            hash: 'SHA-256'\n          };\n        } else if (alg.includes('384')) {\n          return {\n            name: 'ECDSA',\n            hash: 'SHA-384'\n          };\n        } else {\n          return null;\n        }\n\n      default:\n        return null;\n    }\n  }\n\n  alg2kty(alg) {\n    switch (alg.charAt(0)) {\n      case 'R':\n        return 'RSA';\n\n      case 'E':\n        return 'EC';\n\n      default:\n        throw new Error('Cannot infer kty from alg: ' + alg);\n    }\n  } // Accepts ID Token without 'kid' claim in JOSE header if only one JWK supplied in 'jwks_url'\n  //// private validate_no_kid_in_header_only_one_allowed_in_jwtkeys(header_data: any, jwtkeys: any): boolean {\n  ////    this.oidcSecurityCommon.logDebug('amount of jwtkeys.keys: ' + jwtkeys.keys.length);\n  ////    if (!header_data.hasOwnProperty('kid')) {\n  ////        // no kid defined in Jose header\n  ////        if (jwtkeys.keys.length != 1) {\n  ////            this.oidcSecurityCommon.logDebug('jwtkeys.keys.length != 1 and no kid in header');\n  ////            return false;\n  ////        }\n  ////    }\n  ////    return true;\n  //// }\n  // Access Token Validation\n  // access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]\n  // for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.\n  // access_token C2: Take the left- most half of the hash and base64url- encode it.\n  // access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash\n  // is present in the ID Token.\n\n\n  validateIdTokenAtHash(accessToken, atHash, idTokenAlg, configId) {\n    this.loggerService.logDebug(configId, 'at_hash from the server:' + atHash); // 'sha256' 'sha384' 'sha512'\n\n    let sha = 'SHA-256';\n\n    if (idTokenAlg.includes('384')) {\n      sha = 'SHA-384';\n    } else if (idTokenAlg.includes('512')) {\n      sha = 'SHA-512';\n    }\n\n    return this.jwtWindowCryptoService.generateAtHash('' + accessToken, sha).pipe(mergeMap(hash => {\n      this.loggerService.logDebug(configId, 'at_hash client validation not decoded:' + hash);\n\n      if (hash === atHash) {\n        return of(true); // isValid;\n      } else {\n        return this.jwtWindowCryptoService.generateAtHash('' + decodeURIComponent(accessToken), sha).pipe(map(newHash => {\n          this.loggerService.logDebug(configId, '-gen access--' + hash);\n          return newHash === atHash;\n        }));\n      }\n    }));\n  }\n\n  millisToMinutesAndSeconds(millis) {\n    const minutes = Math.floor(millis / 60000);\n    const seconds = (millis % 60000 / 1000).toFixed(0);\n    return minutes + ':' + (+seconds < 10 ? '0' : '') + seconds;\n  }\n\n}\n\nTokenValidationService.refreshTokenNoncePlaceholder = '--RefreshToken--';\n\nTokenValidationService.ɵfac = function TokenValidationService_Factory(t) {\n  return new (t || TokenValidationService)(i0.ɵɵinject(TokenHelperService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(JwtWindowCryptoService));\n};\n\nTokenValidationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: TokenValidationService,\n  factory: TokenValidationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TokenValidationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: TokenHelperService\n    }, {\n      type: LoggerService\n    }, {\n      type: JwtWindowCryptoService\n    }];\n  }, null);\n})();\n\nconst DEFAULT_AUTHRESULT = {\n  isAuthenticated: false,\n  allConfigsAuthenticated: []\n};\n\nclass AuthStateService {\n  constructor(storagePersistenceService, loggerService, publicEventsService, configurationProvider, tokenValidationService) {\n    this.storagePersistenceService = storagePersistenceService;\n    this.loggerService = loggerService;\n    this.publicEventsService = publicEventsService;\n    this.configurationProvider = configurationProvider;\n    this.tokenValidationService = tokenValidationService;\n    this.authenticatedInternal$ = new BehaviorSubject(DEFAULT_AUTHRESULT);\n  }\n\n  get authenticated$() {\n    return this.authenticatedInternal$.asObservable().pipe(distinctUntilChanged());\n  }\n\n  setAuthenticatedAndFireEvent() {\n    const result = this.composeAuthenticatedResult();\n    this.authenticatedInternal$.next(result);\n  }\n\n  setUnauthenticatedAndFireEvent(configIdToReset) {\n    this.storagePersistenceService.resetAuthStateInStorage(configIdToReset);\n    const result = this.composeUnAuthenticatedResult();\n    this.authenticatedInternal$.next(result);\n  }\n\n  updateAndPublishAuthState(authenticationResult) {\n    this.publicEventsService.fireEvent(EventTypes.NewAuthenticationResult, authenticationResult);\n  }\n\n  setAuthorizationData(accessToken, authResult, configId) {\n    this.loggerService.logDebug(configId, `storing the accessToken '${accessToken}'`);\n    this.storagePersistenceService.write('authzData', accessToken, configId);\n    this.persistAccessTokenExpirationTime(authResult, configId);\n    this.setAuthenticatedAndFireEvent();\n  }\n\n  getAccessToken(configId) {\n    if (!this.isAuthenticated(configId)) {\n      return null;\n    }\n\n    const token = this.storagePersistenceService.getAccessToken(configId);\n    return this.decodeURIComponentSafely(token);\n  }\n\n  getIdToken(configId) {\n    if (!this.isAuthenticated(configId)) {\n      return null;\n    }\n\n    const token = this.storagePersistenceService.getIdToken(configId);\n    return this.decodeURIComponentSafely(token);\n  }\n\n  getRefreshToken(configId) {\n    if (!this.isAuthenticated(configId)) {\n      return null;\n    }\n\n    const token = this.storagePersistenceService.getRefreshToken(configId);\n    return this.decodeURIComponentSafely(token);\n  }\n\n  getAuthenticationResult(configId) {\n    if (!this.isAuthenticated(configId)) {\n      return null;\n    }\n\n    return this.storagePersistenceService.getAuthenticationResult(configId);\n  }\n\n  areAuthStorageTokensValid(configId) {\n    if (!this.isAuthenticated(configId)) {\n      return false;\n    }\n\n    if (this.hasIdTokenExpiredAndRenewCheckIsEnabled(configId)) {\n      this.loggerService.logDebug(configId, 'persisted idToken is expired');\n      return false;\n    }\n\n    if (this.hasAccessTokenExpiredIfExpiryExists(configId)) {\n      this.loggerService.logDebug(configId, 'persisted accessToken is expired');\n      return false;\n    }\n\n    this.loggerService.logDebug(configId, 'persisted idToken and accessToken are valid');\n    return true;\n  }\n\n  hasIdTokenExpiredAndRenewCheckIsEnabled(configId) {\n    const {\n      renewTimeBeforeTokenExpiresInSeconds,\n      enableIdTokenExpiredValidationInRenew\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!enableIdTokenExpiredValidationInRenew) {\n      return false;\n    }\n\n    const tokenToCheck = this.storagePersistenceService.getIdToken(configId);\n    const idTokenExpired = this.tokenValidationService.hasIdTokenExpired(tokenToCheck, configId, renewTimeBeforeTokenExpiresInSeconds);\n\n    if (idTokenExpired) {\n      this.publicEventsService.fireEvent(EventTypes.IdTokenExpired, idTokenExpired);\n    }\n\n    return idTokenExpired;\n  }\n\n  hasAccessTokenExpiredIfExpiryExists(configId) {\n    const {\n      renewTimeBeforeTokenExpiresInSeconds\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    const accessTokenExpiresIn = this.storagePersistenceService.read('access_token_expires_at', configId);\n    const accessTokenHasNotExpired = this.tokenValidationService.validateAccessTokenNotExpired(accessTokenExpiresIn, configId, renewTimeBeforeTokenExpiresInSeconds);\n    const hasExpired = !accessTokenHasNotExpired;\n\n    if (hasExpired) {\n      this.publicEventsService.fireEvent(EventTypes.TokenExpired, hasExpired);\n    }\n\n    return hasExpired;\n  }\n\n  isAuthenticated(configId) {\n    return !!this.storagePersistenceService.getAccessToken(configId) && !!this.storagePersistenceService.getIdToken(configId);\n  }\n\n  decodeURIComponentSafely(token) {\n    if (token) {\n      return decodeURIComponent(token);\n    } else {\n      return '';\n    }\n  }\n\n  persistAccessTokenExpirationTime(authResult, configId) {\n    if (authResult === null || authResult === void 0 ? void 0 : authResult.expires_in) {\n      const accessTokenExpiryTime = new Date(new Date().toUTCString()).valueOf() + authResult.expires_in * 1000;\n      this.storagePersistenceService.write('access_token_expires_at', accessTokenExpiryTime, configId);\n    }\n  }\n\n  composeAuthenticatedResult() {\n    if (!this.configurationProvider.hasManyConfigs()) {\n      const {\n        configId\n      } = this.configurationProvider.getOpenIDConfiguration();\n      return {\n        isAuthenticated: true,\n        allConfigsAuthenticated: [{\n          configId,\n          isAuthenticated: true\n        }]\n      };\n    }\n\n    return this.checkAllConfigsIfTheyAreAuthenticated();\n  }\n\n  composeUnAuthenticatedResult() {\n    if (!this.configurationProvider.hasManyConfigs()) {\n      const {\n        configId\n      } = this.configurationProvider.getOpenIDConfiguration();\n      return {\n        isAuthenticated: false,\n        allConfigsAuthenticated: [{\n          configId,\n          isAuthenticated: false\n        }]\n      };\n    }\n\n    return this.checkAllConfigsIfTheyAreAuthenticated();\n  }\n\n  checkAllConfigsIfTheyAreAuthenticated() {\n    const configs = this.configurationProvider.getAllConfigurations();\n    const allConfigsAuthenticated = configs.map(({\n      configId\n    }) => ({\n      configId,\n      isAuthenticated: this.isAuthenticated(configId)\n    }));\n    const isAuthenticated = allConfigsAuthenticated.every(x => !!x.isAuthenticated);\n    return {\n      allConfigsAuthenticated,\n      isAuthenticated\n    };\n  }\n\n}\n\nAuthStateService.ɵfac = function AuthStateService_Factory(t) {\n  return new (t || AuthStateService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(TokenValidationService));\n};\n\nAuthStateService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AuthStateService,\n  factory: AuthStateService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthStateService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: LoggerService\n    }, {\n      type: PublicEventsService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: TokenValidationService\n    }];\n  }, null);\n})();\n\nconst STORAGE_KEY = 'redirect';\n\nclass AutoLoginService {\n  constructor(storageService, router) {\n    this.storageService = storageService;\n    this.router = router;\n  }\n\n  checkSavedRedirectRouteAndNavigate(configId) {\n    const savedRouteForRedirect = this.getStoredRedirectRoute(configId);\n\n    if (savedRouteForRedirect) {\n      this.deleteStoredRedirectRoute(configId);\n      this.router.navigateByUrl(savedRouteForRedirect);\n    }\n  }\n  /**\r\n   * Saves the redirect URL to storage.\r\n   *\r\n   * @param url The redirect URL to save.\r\n   */\n\n\n  saveRedirectRoute(configId, url) {\n    this.storageService.write(STORAGE_KEY, url, configId);\n  }\n  /**\r\n   * Gets the stored redirect URL from storage.\r\n   */\n\n\n  getStoredRedirectRoute(configId) {\n    return this.storageService.read(STORAGE_KEY, configId);\n  }\n  /**\r\n   * Removes the redirect URL from storage.\r\n   */\n\n\n  deleteStoredRedirectRoute(configId) {\n    this.storageService.remove(STORAGE_KEY, configId);\n  }\n\n}\n\nAutoLoginService.ɵfac = function AutoLoginService_Factory(t) {\n  return new (t || AutoLoginService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(i2.Router));\n};\n\nAutoLoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AutoLoginService,\n  factory: AutoLoginService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AutoLoginService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: i2.Router\n    }];\n  }, null);\n})();\n\nclass UriEncoder {\n  encodeKey(key) {\n    return encodeURIComponent(key);\n  }\n\n  encodeValue(value) {\n    return encodeURIComponent(value);\n  }\n\n  decodeKey(key) {\n    return decodeURIComponent(key);\n  }\n\n  decodeValue(value) {\n    return decodeURIComponent(value);\n  }\n\n}\n\nclass RandomService {\n  constructor(doc, loggerService) {\n    this.doc = doc;\n    this.loggerService = loggerService;\n  }\n\n  createRandom(requiredLength, configId) {\n    if (requiredLength <= 0) {\n      return '';\n    }\n\n    if (requiredLength > 0 && requiredLength < 7) {\n      this.loggerService.logWarning(configId, `RandomService called with ${requiredLength} but 7 chars is the minimum, returning 10 chars`);\n      requiredLength = 10;\n    }\n\n    const length = requiredLength - 6;\n    const arr = new Uint8Array(Math.floor((length || length) / 2));\n\n    if (this.getCrypto()) {\n      this.getCrypto().getRandomValues(arr);\n    }\n\n    return Array.from(arr, this.toHex).join('') + this.randomString(7);\n  }\n\n  toHex(dec) {\n    return ('0' + dec.toString(16)).substr(-2);\n  }\n\n  randomString(length) {\n    let result = '';\n    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    const values = new Uint32Array(length);\n\n    if (this.getCrypto()) {\n      this.getCrypto().getRandomValues(values);\n\n      for (let i = 0; i < length; i++) {\n        result += characters[values[i] % characters.length];\n      }\n    }\n\n    return result;\n  }\n\n  getCrypto() {\n    // support for IE,  (window.crypto || window.msCrypto)\n    return this.doc.defaultView.crypto || this.doc.defaultView.msCrypto;\n  }\n\n}\n\nRandomService.ɵfac = function RandomService_Factory(t) {\n  return new (t || RandomService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(LoggerService));\n};\n\nRandomService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RandomService,\n  factory: RandomService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RandomService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: LoggerService\n    }];\n  }, null);\n})();\n\nclass FlowsDataService {\n  constructor(storagePersistenceService, randomService, configurationProvider, loggerService) {\n    this.storagePersistenceService = storagePersistenceService;\n    this.randomService = randomService;\n    this.configurationProvider = configurationProvider;\n    this.loggerService = loggerService;\n  }\n\n  createNonce(configId) {\n    const nonce = this.randomService.createRandom(40, configId);\n    this.loggerService.logDebug(configId, 'Nonce created. nonce:' + nonce);\n    this.setNonce(nonce, configId);\n    return nonce;\n  }\n\n  setNonce(nonce, configId) {\n    this.storagePersistenceService.write('authNonce', nonce, configId);\n  }\n\n  getAuthStateControl(configId) {\n    return this.storagePersistenceService.read('authStateControl', configId);\n  }\n\n  setAuthStateControl(authStateControl, configId) {\n    this.storagePersistenceService.write('authStateControl', authStateControl, configId);\n  }\n\n  getExistingOrCreateAuthStateControl(configId) {\n    let state = this.storagePersistenceService.read('authStateControl', configId);\n\n    if (!state) {\n      state = this.randomService.createRandom(40, configId);\n      this.storagePersistenceService.write('authStateControl', state, configId);\n    }\n\n    return state;\n  }\n\n  setSessionState(sessionState, configId) {\n    this.storagePersistenceService.write('session_state', sessionState, configId);\n  }\n\n  resetStorageFlowData(configId) {\n    this.storagePersistenceService.resetStorageFlowData(configId);\n  }\n\n  getCodeVerifier(configId) {\n    return this.storagePersistenceService.read('codeVerifier', configId);\n  }\n\n  createCodeVerifier(configId) {\n    const codeVerifier = this.randomService.createRandom(67, configId);\n    this.storagePersistenceService.write('codeVerifier', codeVerifier, configId);\n    return codeVerifier;\n  }\n\n  isSilentRenewRunning(configId) {\n    const storageObject = this.getSilentRenewRunningStorageEntry(configId);\n\n    if (!storageObject) {\n      return false;\n    }\n\n    const {\n      silentRenewTimeoutInSeconds\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    const timeOutInMilliseconds = silentRenewTimeoutInSeconds * 1000;\n    const dateOfLaunchedProcessUtc = Date.parse(storageObject.dateOfLaunchedProcessUtc);\n    const currentDateUtc = Date.parse(new Date().toISOString());\n    const elapsedTimeInMilliseconds = Math.abs(currentDateUtc - dateOfLaunchedProcessUtc);\n    const isProbablyStuck = elapsedTimeInMilliseconds > timeOutInMilliseconds;\n\n    if (isProbablyStuck) {\n      this.loggerService.logDebug(configId, 'silent renew process is probably stuck, state will be reset.', configId);\n      this.resetSilentRenewRunning(configId);\n      return false;\n    }\n\n    return storageObject.state === 'running';\n  }\n\n  setSilentRenewRunning(configId) {\n    const storageObject = {\n      state: 'running',\n      dateOfLaunchedProcessUtc: new Date().toISOString()\n    };\n    this.storagePersistenceService.write('storageSilentRenewRunning', JSON.stringify(storageObject), configId);\n  }\n\n  resetSilentRenewRunning(configId) {\n    this.storagePersistenceService.write('storageSilentRenewRunning', '', configId);\n  }\n\n  getSilentRenewRunningStorageEntry(configId) {\n    const storageEntry = this.storagePersistenceService.read('storageSilentRenewRunning', configId);\n\n    if (!storageEntry) {\n      return null;\n    }\n\n    return JSON.parse(storageEntry);\n  }\n\n}\n\nFlowsDataService.ɵfac = function FlowsDataService_Factory(t) {\n  return new (t || FlowsDataService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(RandomService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(LoggerService));\n};\n\nFlowsDataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: FlowsDataService,\n  factory: FlowsDataService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(FlowsDataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: RandomService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: LoggerService\n    }];\n  }, null);\n})();\n\nclass FlowHelper {\n  constructor(configurationProvider) {\n    this.configurationProvider = configurationProvider;\n  }\n\n  isCurrentFlowCodeFlow(configId) {\n    return this.currentFlowIs('code', configId);\n  }\n\n  isCurrentFlowAnyImplicitFlow(configId) {\n    return this.isCurrentFlowImplicitFlowWithAccessToken(configId) || this.isCurrentFlowImplicitFlowWithoutAccessToken(configId);\n  }\n\n  isCurrentFlowCodeFlowWithRefreshTokens(configId) {\n    const {\n      useRefreshToken\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (this.isCurrentFlowCodeFlow(configId) && useRefreshToken) {\n      return true;\n    }\n\n    return false;\n  }\n\n  isCurrentFlowImplicitFlowWithAccessToken(configId) {\n    return this.currentFlowIs('id_token token', configId);\n  }\n\n  currentFlowIs(flowTypes, configId) {\n    const {\n      responseType\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (Array.isArray(flowTypes)) {\n      return flowTypes.some(x => responseType === x);\n    }\n\n    return responseType === flowTypes;\n  }\n\n  isCurrentFlowImplicitFlowWithoutAccessToken(configId) {\n    return this.currentFlowIs('id_token', configId);\n  }\n\n}\n\nFlowHelper.ɵfac = function FlowHelper_Factory(t) {\n  return new (t || FlowHelper)(i0.ɵɵinject(ConfigurationProvider));\n};\n\nFlowHelper.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: FlowHelper,\n  factory: FlowHelper.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(FlowHelper, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ConfigurationProvider\n    }];\n  }, null);\n})();\n\nconst CALLBACK_PARAMS_TO_CHECK = ['code', 'state', 'token', 'id_token'];\nconst AUTH0_ENDPOINT = 'auth0.com';\n\nclass UrlService {\n  constructor(configurationProvider, loggerService, flowsDataService, flowHelper, storagePersistenceService, jwtWindowCryptoService) {\n    this.configurationProvider = configurationProvider;\n    this.loggerService = loggerService;\n    this.flowsDataService = flowsDataService;\n    this.flowHelper = flowHelper;\n    this.storagePersistenceService = storagePersistenceService;\n    this.jwtWindowCryptoService = jwtWindowCryptoService;\n  }\n\n  getUrlParameter(urlToCheck, name) {\n    if (!urlToCheck) {\n      return '';\n    }\n\n    if (!name) {\n      return '';\n    }\n\n    name = name.replace(/[\\[]/, '\\\\[').replace(/[\\]]/, '\\\\]');\n    const regex = new RegExp('[\\\\?&]' + name + '=([^&#]*)');\n    const results = regex.exec(urlToCheck);\n    return results === null ? '' : decodeURIComponent(results[1]);\n  }\n\n  isCallbackFromSts(currentUrl) {\n    return CALLBACK_PARAMS_TO_CHECK.some(x => !!this.getUrlParameter(currentUrl, x));\n  }\n\n  getRefreshSessionSilentRenewUrl(configId, customParams) {\n    if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\n      return this.createUrlCodeFlowWithSilentRenew(configId, customParams);\n    }\n\n    return of(this.createUrlImplicitFlowWithSilentRenew(configId, customParams) || '');\n  }\n\n  getAuthorizeParUrl(requestUri, configId) {\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n    if (!authWellKnownEndPoints) {\n      this.loggerService.logError(configId, 'authWellKnownEndpoints is undefined');\n      return null;\n    }\n\n    const authorizationEndpoint = authWellKnownEndPoints.authorizationEndpoint;\n\n    if (!authorizationEndpoint) {\n      this.loggerService.logError(configId, `Can not create an authorize URL when authorizationEndpoint is '${authorizationEndpoint}'`);\n      return null;\n    }\n\n    const {\n      clientId\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!clientId) {\n      this.loggerService.logError(configId, `getAuthorizeParUrl could not add clientId because it was: `, clientId);\n      return null;\n    }\n\n    const urlParts = authorizationEndpoint.split('?');\n    const authorizationUrl = urlParts[0];\n    const existingParams = urlParts[1];\n    let params = this.createHttpParams(existingParams);\n    params = params.set('request_uri', requestUri);\n    params = params.append('client_id', clientId);\n    return `${authorizationUrl}?${params}`;\n  }\n\n  getAuthorizeUrl(configId, customParams) {\n    if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\n      return this.createUrlCodeFlowAuthorize(configId, customParams);\n    }\n\n    return of(this.createUrlImplicitFlowAuthorize(configId, customParams) || '');\n  }\n\n  createEndSessionUrl(idTokenHint, configId, customParamsEndSession) {\n    // Auth0 needs a special logout url\n    // See https://auth0.com/docs/api/authentication#logout\n    if (this.isAuth0Endpoint(configId)) {\n      return this.composeAuth0Endpoint(configId);\n    }\n\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n    const endSessionEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.endSessionEndpoint;\n\n    if (!endSessionEndpoint) {\n      return null;\n    }\n\n    const urlParts = endSessionEndpoint.split('?');\n    const authorizationEndSessionUrl = urlParts[0];\n    const existingParams = urlParts[1];\n    let params = this.createHttpParams(existingParams);\n    params = params.set('id_token_hint', idTokenHint);\n    const postLogoutRedirectUri = this.getPostLogoutRedirectUrl(configId);\n\n    if (postLogoutRedirectUri) {\n      params = params.append('post_logout_redirect_uri', postLogoutRedirectUri);\n    }\n\n    if (customParamsEndSession) {\n      params = this.appendCustomParams(Object.assign({}, customParamsEndSession), params);\n    }\n\n    return `${authorizationEndSessionUrl}?${params}`;\n  }\n\n  createRevocationEndpointBodyAccessToken(token, configId) {\n    const clientId = this.getClientId(configId);\n\n    if (!clientId) {\n      return null;\n    }\n\n    let params = this.createHttpParams();\n    params = params.set('client_id', clientId);\n    params = params.set('token', token);\n    params = params.set('token_type_hint', 'access_token');\n    return params.toString();\n  }\n\n  createRevocationEndpointBodyRefreshToken(token, configId) {\n    const clientId = this.getClientId(configId);\n\n    if (!clientId) {\n      return null;\n    }\n\n    let params = this.createHttpParams();\n    params = params.set('client_id', clientId);\n    params = params.set('token', token);\n    params = params.set('token_type_hint', 'refresh_token');\n    return params.toString();\n  }\n\n  getRevocationEndpointUrl(configId) {\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n    const revocationEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.revocationEndpoint;\n\n    if (!revocationEndpoint) {\n      return null;\n    }\n\n    const urlParts = revocationEndpoint.split('?');\n    const revocationEndpointUrl = urlParts[0];\n    return revocationEndpointUrl;\n  }\n\n  createBodyForCodeFlowCodeRequest(code, configId, customTokenParams) {\n    const codeVerifier = this.flowsDataService.getCodeVerifier(configId);\n\n    if (!codeVerifier) {\n      this.loggerService.logError(configId, `CodeVerifier is not set `, codeVerifier);\n      return null;\n    }\n\n    const clientId = this.getClientId(configId);\n\n    if (!clientId) {\n      return null;\n    }\n\n    let params = this.createHttpParams();\n    params = params.set('grant_type', 'authorization_code');\n    params = params.set('client_id', clientId);\n    params = params.set('code_verifier', codeVerifier);\n    params = params.set('code', code);\n\n    if (customTokenParams) {\n      params = this.appendCustomParams(Object.assign({}, customTokenParams), params);\n    }\n\n    const silentRenewUrl = this.getSilentRenewUrl(configId);\n\n    if (this.flowsDataService.isSilentRenewRunning(configId) && silentRenewUrl) {\n      params = params.set('redirect_uri', silentRenewUrl);\n      return params.toString();\n    }\n\n    const redirectUrl = this.getRedirectUrl(configId);\n\n    if (!redirectUrl) {\n      return null;\n    }\n\n    params = params.set('redirect_uri', redirectUrl);\n    return params.toString();\n  }\n\n  createBodyForCodeFlowRefreshTokensRequest(refreshToken, configId, customParamsRefresh) {\n    const clientId = this.getClientId(configId);\n\n    if (!clientId) {\n      return null;\n    }\n\n    let params = this.createHttpParams();\n    params = params.set('grant_type', 'refresh_token');\n    params = params.set('client_id', clientId);\n    params = params.set('refresh_token', refreshToken);\n\n    if (customParamsRefresh) {\n      params = this.appendCustomParams(Object.assign({}, customParamsRefresh), params);\n    }\n\n    return params.toString();\n  }\n\n  createBodyForParCodeFlowRequest(configId, customParamsRequest) {\n    const redirectUrl = this.getRedirectUrl(configId);\n\n    if (!redirectUrl) {\n      return of(null);\n    }\n\n    const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\n    const nonce = this.flowsDataService.createNonce(configId);\n    this.loggerService.logDebug(configId, 'Authorize created. adding myautostate: ' + state); // code_challenge with \"S256\"\n\n    const codeVerifier = this.flowsDataService.createCodeVerifier(configId);\n    return this.jwtWindowCryptoService.generateCodeChallenge(codeVerifier).pipe(map(codeChallenge => {\n      const {\n        clientId,\n        responseType,\n        scope,\n        hdParam,\n        customParamsAuthRequest\n      } = this.configurationProvider.getOpenIDConfiguration(configId);\n      let params = this.createHttpParams('');\n      params = params.set('client_id', clientId);\n      params = params.append('redirect_uri', redirectUrl);\n      params = params.append('response_type', responseType);\n      params = params.append('scope', scope);\n      params = params.append('nonce', nonce);\n      params = params.append('state', state);\n      params = params.append('code_challenge', codeChallenge);\n      params = params.append('code_challenge_method', 'S256');\n\n      if (hdParam) {\n        params = params.append('hd', hdParam);\n      }\n\n      if (customParamsAuthRequest) {\n        params = this.appendCustomParams(Object.assign({}, customParamsAuthRequest), params);\n      }\n\n      if (customParamsRequest) {\n        params = this.appendCustomParams(Object.assign({}, customParamsRequest), params);\n      }\n\n      return params.toString();\n    }));\n  }\n\n  createAuthorizeUrl(codeChallenge, redirectUrl, nonce, state, configId, prompt, customRequestParams) {\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n    const authorizationEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.authorizationEndpoint;\n\n    if (!authorizationEndpoint) {\n      this.loggerService.logError(configId, `Can not create an authorize URL when authorizationEndpoint is '${authorizationEndpoint}'`);\n      return null;\n    }\n\n    const {\n      clientId,\n      responseType,\n      scope,\n      hdParam,\n      customParamsAuthRequest\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!clientId) {\n      this.loggerService.logError(configId, `createAuthorizeUrl could not add clientId because it was: `, clientId);\n      return null;\n    }\n\n    if (!responseType) {\n      this.loggerService.logError(configId, `createAuthorizeUrl could not add responseType because it was: `, responseType);\n      return null;\n    }\n\n    if (!scope) {\n      this.loggerService.logError(configId, `createAuthorizeUrl could not add scope because it was: `, scope);\n      return null;\n    }\n\n    const urlParts = authorizationEndpoint.split('?');\n    const authorizationUrl = urlParts[0];\n    const existingParams = urlParts[1];\n    let params = this.createHttpParams(existingParams);\n    params = params.set('client_id', clientId);\n    params = params.append('redirect_uri', redirectUrl);\n    params = params.append('response_type', responseType);\n    params = params.append('scope', scope);\n    params = params.append('nonce', nonce);\n    params = params.append('state', state);\n\n    if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\n      params = params.append('code_challenge', codeChallenge);\n      params = params.append('code_challenge_method', 'S256');\n    }\n\n    const mergedParams = Object.assign(Object.assign({}, customParamsAuthRequest), customRequestParams);\n\n    if (Object.keys(mergedParams).length > 0) {\n      params = this.appendCustomParams(Object.assign({}, mergedParams), params);\n    }\n\n    if (prompt) {\n      params = this.overWriteParam(params, 'prompt', prompt);\n    }\n\n    if (hdParam) {\n      params = params.append('hd', hdParam);\n    }\n\n    return `${authorizationUrl}?${params}`;\n  }\n\n  createUrlImplicitFlowWithSilentRenew(configId, customParams) {\n    const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\n    const nonce = this.flowsDataService.createNonce(configId);\n    const silentRenewUrl = this.getSilentRenewUrl(configId);\n\n    if (!silentRenewUrl) {\n      return null;\n    }\n\n    this.loggerService.logDebug(configId, 'RefreshSession created. adding myautostate: ', state);\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n    if (authWellKnownEndPoints) {\n      return this.createAuthorizeUrl('', silentRenewUrl, nonce, state, configId, 'none', customParams);\n    }\n\n    this.loggerService.logError(configId, 'authWellKnownEndpoints is undefined');\n    return null;\n  }\n\n  createUrlCodeFlowWithSilentRenew(configId, customParams) {\n    const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\n    const nonce = this.flowsDataService.createNonce(configId);\n    this.loggerService.logDebug(configId, 'RefreshSession created. adding myautostate: ' + state); // code_challenge with \"S256\"\n\n    const codeVerifier = this.flowsDataService.createCodeVerifier(configId);\n    return this.jwtWindowCryptoService.generateCodeChallenge(codeVerifier).pipe(map(codeChallenge => {\n      const silentRenewUrl = this.getSilentRenewUrl(configId);\n\n      if (!silentRenewUrl) {\n        return '';\n      }\n\n      const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n      if (authWellKnownEndPoints) {\n        return this.createAuthorizeUrl(codeChallenge, silentRenewUrl, nonce, state, configId, 'none', customParams);\n      }\n\n      this.loggerService.logWarning(configId, 'authWellKnownEndpoints is undefined');\n      return null;\n    }));\n  }\n\n  createUrlImplicitFlowAuthorize(configId, customParams) {\n    const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\n    const nonce = this.flowsDataService.createNonce(configId);\n    this.loggerService.logDebug(configId, 'Authorize created. adding myautostate: ' + state);\n    const redirectUrl = this.getRedirectUrl(configId);\n\n    if (!redirectUrl) {\n      return null;\n    }\n\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n    if (authWellKnownEndPoints) {\n      return this.createAuthorizeUrl('', redirectUrl, nonce, state, configId, null, customParams);\n    }\n\n    this.loggerService.logError(configId, 'authWellKnownEndpoints is undefined');\n    return null;\n  }\n\n  createUrlCodeFlowAuthorize(configId, customParams) {\n    const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\n    const nonce = this.flowsDataService.createNonce(configId);\n    this.loggerService.logDebug(configId, 'Authorize created. adding myautostate: ' + state);\n    const redirectUrl = this.getRedirectUrl(configId);\n\n    if (!redirectUrl) {\n      return of(null);\n    } // code_challenge with \"S256\"\n\n\n    const codeVerifier = this.flowsDataService.createCodeVerifier(configId);\n    return this.jwtWindowCryptoService.generateCodeChallenge(codeVerifier).pipe(map(codeChallenge => {\n      const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n      if (authWellKnownEndPoints) {\n        return this.createAuthorizeUrl(codeChallenge, redirectUrl, nonce, state, configId, null, customParams);\n      }\n\n      this.loggerService.logError(configId, 'authWellKnownEndpoints is undefined');\n      return '';\n    }));\n  }\n\n  getRedirectUrl(configId) {\n    const {\n      redirectUrl\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!redirectUrl) {\n      this.loggerService.logError(configId, `could not get redirectUrl, was: `, redirectUrl);\n      return null;\n    }\n\n    return redirectUrl;\n  }\n\n  getSilentRenewUrl(configId) {\n    const {\n      silentRenewUrl\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!silentRenewUrl) {\n      this.loggerService.logError(configId, `could not get silentRenewUrl, was: `, silentRenewUrl);\n      return null;\n    }\n\n    return silentRenewUrl;\n  }\n\n  getPostLogoutRedirectUrl(configId) {\n    const {\n      postLogoutRedirectUri\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!postLogoutRedirectUri) {\n      this.loggerService.logError(configId, `could not get postLogoutRedirectUri, was: `, postLogoutRedirectUri);\n      return null;\n    }\n\n    return postLogoutRedirectUri;\n  }\n\n  getClientId(configId) {\n    const {\n      clientId\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!clientId) {\n      this.loggerService.logError(configId, `could not get clientId, was: `, clientId);\n      return null;\n    }\n\n    return clientId;\n  }\n\n  appendCustomParams(customParams, params) {\n    for (const [key, value] of Object.entries(Object.assign({}, customParams))) {\n      params = params.append(key, value.toString());\n    }\n\n    return params;\n  }\n\n  overWriteParam(params, key, value) {\n    return params.set(key, value);\n  }\n\n  createHttpParams(existingParams) {\n    existingParams = existingParams !== null && existingParams !== void 0 ? existingParams : '';\n    const params = new HttpParams({\n      fromString: existingParams,\n      encoder: new UriEncoder()\n    });\n    return params;\n  }\n\n  isAuth0Endpoint(configId) {\n    const {\n      authority\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!authority) {\n      return false;\n    }\n\n    return authority.endsWith(AUTH0_ENDPOINT);\n  }\n\n  composeAuth0Endpoint(configId) {\n    // format: https://YOUR_DOMAIN/v2/logout?client_id=YOUR_CLIENT_ID&returnTo=LOGOUT_URL\n    const {\n      authority,\n      clientId\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    const postLogoutRedirectUrl = this.getPostLogoutRedirectUrl(configId);\n    return `${authority}/v2/logout?client_id=${clientId}&returnTo=${postLogoutRedirectUrl}`;\n  }\n\n}\n\nUrlService.ɵfac = function UrlService_Factory(t) {\n  return new (t || UrlService)(i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(LoggerService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(FlowHelper), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(JwtWindowCryptoService));\n};\n\nUrlService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: UrlService,\n  factory: UrlService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(UrlService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ConfigurationProvider\n    }, {\n      type: LoggerService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: FlowHelper\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: JwtWindowCryptoService\n    }];\n  }, null);\n})();\n\nclass CodeFlowCallbackHandlerService {\n  constructor(urlService, loggerService, tokenValidationService, flowsDataService, configurationProvider, storagePersistenceService, dataService) {\n    this.urlService = urlService;\n    this.loggerService = loggerService;\n    this.tokenValidationService = tokenValidationService;\n    this.flowsDataService = flowsDataService;\n    this.configurationProvider = configurationProvider;\n    this.storagePersistenceService = storagePersistenceService;\n    this.dataService = dataService;\n  } // STEP 1 Code Flow\n\n\n  codeFlowCallback(urlToCheck, configId) {\n    const code = this.urlService.getUrlParameter(urlToCheck, 'code');\n    const state = this.urlService.getUrlParameter(urlToCheck, 'state');\n    const sessionState = this.urlService.getUrlParameter(urlToCheck, 'session_state');\n\n    if (!state) {\n      this.loggerService.logDebug(configId, 'no state in url');\n      return throwError(() => new Error('no state in url'));\n    }\n\n    if (!code) {\n      this.loggerService.logDebug(configId, 'no code in url');\n      return throwError(() => new Error('no code in url'));\n    }\n\n    this.loggerService.logDebug(configId, 'running validation for callback', urlToCheck);\n    const initialCallbackContext = {\n      code,\n      refreshToken: null,\n      state,\n      sessionState,\n      authResult: null,\n      isRenewProcess: false,\n      jwtKeys: null,\n      validationResult: null,\n      existingIdToken: null\n    };\n    return of(initialCallbackContext);\n  } // STEP 2 Code Flow //  Code Flow Silent Renew starts here\n\n\n  codeFlowCodeRequest(callbackContext, configId) {\n    const authStateControl = this.flowsDataService.getAuthStateControl(configId);\n    const isStateCorrect = this.tokenValidationService.validateStateFromHashCallback(callbackContext.state, authStateControl, configId);\n\n    if (!isStateCorrect) {\n      return throwError(() => new Error('codeFlowCodeRequest incorrect state'));\n    }\n\n    const authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n    const tokenEndpoint = authWellknownEndpoints === null || authWellknownEndpoints === void 0 ? void 0 : authWellknownEndpoints.tokenEndpoint;\n\n    if (!tokenEndpoint) {\n      return throwError(() => new Error('Token Endpoint not defined'));\n    }\n\n    let headers = new HttpHeaders();\n    headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n    const config = this.configurationProvider.getOpenIDConfiguration(configId);\n    const bodyForCodeFlow = this.urlService.createBodyForCodeFlowCodeRequest(callbackContext.code, configId, config === null || config === void 0 ? void 0 : config.customParamsCodeRequest);\n    return this.dataService.post(tokenEndpoint, bodyForCodeFlow, configId, headers).pipe(switchMap(response => {\n      let authResult = new Object();\n      authResult = response;\n      authResult.state = callbackContext.state;\n      authResult.session_state = callbackContext.sessionState;\n      callbackContext.authResult = authResult;\n      return of(callbackContext);\n    }), retryWhen(error => this.handleRefreshRetry(error, configId)), catchError(error => {\n      const {\n        authority\n      } = this.configurationProvider.getOpenIDConfiguration(configId);\n      const errorMessage = `OidcService code request ${authority}`;\n      this.loggerService.logError(configId, errorMessage, error);\n      return throwError(() => new Error(errorMessage));\n    }));\n  }\n\n  handleRefreshRetry(errors, configId) {\n    return errors.pipe(mergeMap(error => {\n      // retry token refresh if there is no internet connection\n      if (error && error instanceof HttpErrorResponse && error.error instanceof ProgressEvent && error.error.type === 'error') {\n        const {\n          authority,\n          refreshTokenRetryInSeconds\n        } = this.configurationProvider.getOpenIDConfiguration(configId);\n        const errorMessage = `OidcService code request ${authority} - no internet connection`;\n        this.loggerService.logWarning(configId, errorMessage, error);\n        return timer(refreshTokenRetryInSeconds * 1000);\n      }\n\n      return throwError(() => new Error(error));\n    }));\n  }\n\n}\n\nCodeFlowCallbackHandlerService.ɵfac = function CodeFlowCallbackHandlerService_Factory(t) {\n  return new (t || CodeFlowCallbackHandlerService)(i0.ɵɵinject(UrlService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(TokenValidationService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(DataService));\n};\n\nCodeFlowCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CodeFlowCallbackHandlerService,\n  factory: CodeFlowCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CodeFlowCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: UrlService\n    }, {\n      type: LoggerService\n    }, {\n      type: TokenValidationService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: DataService\n    }];\n  }, null);\n})();\n\nconst DEFAULT_USERRESULT = {\n  userData: null,\n  allUserData: []\n};\n\nclass UserService {\n  constructor(oidcDataService, storagePersistenceService, eventService, loggerService, tokenHelperService, flowHelper, configurationProvider) {\n    this.oidcDataService = oidcDataService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.eventService = eventService;\n    this.loggerService = loggerService;\n    this.tokenHelperService = tokenHelperService;\n    this.flowHelper = flowHelper;\n    this.configurationProvider = configurationProvider;\n    this.userDataInternal$ = new BehaviorSubject(DEFAULT_USERRESULT);\n  }\n\n  get userData$() {\n    return this.userDataInternal$.asObservable();\n  }\n\n  getAndPersistUserDataInStore(configId, isRenewProcess = false, idToken, decodedIdToken) {\n    idToken = idToken || this.storagePersistenceService.getIdToken(configId);\n    decodedIdToken = decodedIdToken || this.tokenHelperService.getPayloadFromToken(idToken, false, configId);\n    const existingUserDataFromStorage = this.getUserDataFromStore(configId);\n    const haveUserData = !!existingUserDataFromStorage;\n    const isCurrentFlowImplicitFlowWithAccessToken = this.flowHelper.isCurrentFlowImplicitFlowWithAccessToken(configId);\n    const isCurrentFlowCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(configId);\n    const accessToken = this.storagePersistenceService.getAccessToken(configId);\n\n    if (!(isCurrentFlowImplicitFlowWithAccessToken || isCurrentFlowCodeFlow)) {\n      this.loggerService.logDebug(configId, `authCallback idToken flow with accessToken ${accessToken}`);\n      this.setUserDataToStore(decodedIdToken, configId);\n      return of(decodedIdToken);\n    }\n\n    const {\n      renewUserInfoAfterTokenRenew\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!isRenewProcess || renewUserInfoAfterTokenRenew || !haveUserData) {\n      return this.getUserDataOidcFlowAndSave(decodedIdToken.sub, configId).pipe(switchMap(userData => {\n        this.loggerService.logDebug(configId, 'Received user data: ', userData);\n\n        if (!!userData) {\n          this.loggerService.logDebug(configId, 'accessToken: ', accessToken);\n          return of(userData);\n        } else {\n          return throwError(() => new Error('Received no user data, request failed'));\n        }\n      }));\n    }\n\n    return of(existingUserDataFromStorage);\n  }\n\n  getUserDataFromStore(configId) {\n    return this.storagePersistenceService.read('userData', configId) || null;\n  }\n\n  publishUserDataIfExists(configId) {\n    const userData = this.getUserDataFromStore(configId);\n\n    if (userData) {\n      this.fireUserDataEvent(configId, userData);\n    }\n  }\n\n  setUserDataToStore(userData, configId) {\n    this.storagePersistenceService.write('userData', userData, configId);\n    this.fireUserDataEvent(configId, userData);\n  }\n\n  resetUserDataInStore(configId) {\n    this.storagePersistenceService.remove('userData', configId);\n    this.fireUserDataEvent(configId, null);\n  }\n\n  getUserDataOidcFlowAndSave(idTokenSub, configId) {\n    return this.getIdentityUserData(configId).pipe(map(data => {\n      if (this.validateUserDataSubIdToken(idTokenSub, data === null || data === void 0 ? void 0 : data.sub)) {\n        this.setUserDataToStore(data, configId);\n        return data;\n      } else {\n        // something went wrong, user data sub does not match that from id_token\n        this.loggerService.logWarning(configId, `User data sub does not match sub in id_token, resetting`);\n        this.resetUserDataInStore(configId);\n        return null;\n      }\n    }));\n  }\n\n  getIdentityUserData(configId) {\n    const token = this.storagePersistenceService.getAccessToken(configId);\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n    if (!authWellKnownEndPoints) {\n      this.loggerService.logWarning(configId, 'init check session: authWellKnownEndpoints is undefined');\n      return throwError(() => new Error('authWellKnownEndpoints is undefined'));\n    }\n\n    const userInfoEndpoint = authWellKnownEndPoints.userInfoEndpoint;\n\n    if (!userInfoEndpoint) {\n      this.loggerService.logError(configId, 'init check session: authWellKnownEndpoints.userinfo_endpoint is undefined; set auto_userinfo = false in config');\n      return throwError(() => new Error('authWellKnownEndpoints.userinfo_endpoint is undefined'));\n    }\n\n    return this.oidcDataService.get(userInfoEndpoint, configId, token).pipe(retry(2));\n  }\n\n  validateUserDataSubIdToken(idTokenSub, userDataSub) {\n    if (!idTokenSub) {\n      return false;\n    }\n\n    if (!userDataSub) {\n      return false;\n    }\n\n    if (idTokenSub !== userDataSub) {\n      this.loggerService.logDebug('validateUserDataSubIdToken failed', idTokenSub, userDataSub);\n      return false;\n    }\n\n    return true;\n  }\n\n  fireUserDataEvent(configId, passedUserData) {\n    const userData = this.composeSingleOrMultipleUserDataObject(configId, passedUserData);\n    this.userDataInternal$.next(userData);\n    this.eventService.fireEvent(EventTypes.UserDataChanged, {\n      configId,\n      userData: passedUserData\n    });\n  }\n\n  composeSingleOrMultipleUserDataObject(configId, passedUserData) {\n    const hasManyConfigs = this.configurationProvider.hasManyConfigs();\n\n    if (!hasManyConfigs) {\n      return this.composeSingleUserDataResult(configId, passedUserData);\n    }\n\n    const configs = this.configurationProvider.getAllConfigurations();\n    const allUserData = configs.map(config => {\n      if (this.currentConfigIsToUpdate(configId, config)) {\n        return {\n          configId: config.configId,\n          userData: passedUserData\n        };\n      }\n\n      const alreadySavedUserData = this.storagePersistenceService.read('userData', config.configId) || null;\n      return {\n        configId: config.configId,\n        userData: alreadySavedUserData\n      };\n    });\n    return {\n      userData: null,\n      allUserData\n    };\n  }\n\n  composeSingleUserDataResult(configId, userData) {\n    return {\n      userData,\n      allUserData: [{\n        configId,\n        userData\n      }]\n    };\n  }\n\n  currentConfigIsToUpdate(configId, config) {\n    return config.configId === configId;\n  }\n\n}\n\nUserService.ɵfac = function UserService_Factory(t) {\n  return new (t || UserService)(i0.ɵɵinject(DataService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(TokenHelperService), i0.ɵɵinject(FlowHelper), i0.ɵɵinject(ConfigurationProvider));\n};\n\nUserService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: UserService,\n  factory: UserService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(UserService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: DataService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: PublicEventsService\n    }, {\n      type: LoggerService\n    }, {\n      type: TokenHelperService\n    }, {\n      type: FlowHelper\n    }, {\n      type: ConfigurationProvider\n    }];\n  }, null);\n})();\n\nclass ResetAuthDataService {\n  constructor(authStateService, flowsDataService, userService) {\n    this.authStateService = authStateService;\n    this.flowsDataService = flowsDataService;\n    this.userService = userService;\n  }\n\n  resetAuthorizationData(configId) {\n    this.userService.resetUserDataInStore(configId);\n    this.flowsDataService.resetStorageFlowData(configId);\n    this.authStateService.setUnauthenticatedAndFireEvent(configId);\n  }\n\n}\n\nResetAuthDataService.ɵfac = function ResetAuthDataService_Factory(t) {\n  return new (t || ResetAuthDataService)(i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(UserService));\n};\n\nResetAuthDataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ResetAuthDataService,\n  factory: ResetAuthDataService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ResetAuthDataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: AuthStateService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: UserService\n    }];\n  }, null);\n})();\n\nclass ImplicitFlowCallbackHandlerService {\n  constructor(resetAuthDataService, loggerService, flowsDataService, doc) {\n    this.resetAuthDataService = resetAuthDataService;\n    this.loggerService = loggerService;\n    this.flowsDataService = flowsDataService;\n    this.doc = doc;\n  } // STEP 1 Code Flow\n  // STEP 1 Implicit Flow\n\n\n  implicitFlowCallback(configId, hash) {\n    const isRenewProcessData = this.flowsDataService.isSilentRenewRunning(configId);\n    this.loggerService.logDebug(configId, 'BEGIN callback, no auth data');\n\n    if (!isRenewProcessData) {\n      this.resetAuthDataService.resetAuthorizationData(configId);\n    }\n\n    hash = hash || this.doc.location.hash.substr(1);\n    const authResult = hash.split('&').reduce((resultData, item) => {\n      const parts = item.split('=');\n      resultData[parts.shift()] = parts.join('=');\n      return resultData;\n    }, {});\n    const callbackContext = {\n      code: null,\n      refreshToken: null,\n      state: null,\n      sessionState: null,\n      authResult,\n      isRenewProcess: isRenewProcessData,\n      jwtKeys: null,\n      validationResult: null,\n      existingIdToken: null\n    };\n    return of(callbackContext);\n  }\n\n}\n\nImplicitFlowCallbackHandlerService.ɵfac = function ImplicitFlowCallbackHandlerService_Factory(t) {\n  return new (t || ImplicitFlowCallbackHandlerService)(i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(DOCUMENT));\n};\n\nImplicitFlowCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ImplicitFlowCallbackHandlerService,\n  factory: ImplicitFlowCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ImplicitFlowCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ResetAuthDataService\n    }, {\n      type: LoggerService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n/* eslint-disable no-shadow */\n\n\nvar ValidationResult;\n\n(function (ValidationResult) {\n  ValidationResult[\"NotSet\"] = \"NotSet\";\n  ValidationResult[\"StatesDoNotMatch\"] = \"StatesDoNotMatch\";\n  ValidationResult[\"SignatureFailed\"] = \"SignatureFailed\";\n  ValidationResult[\"IncorrectNonce\"] = \"IncorrectNonce\";\n  ValidationResult[\"RequiredPropertyMissing\"] = \"RequiredPropertyMissing\";\n  ValidationResult[\"MaxOffsetExpired\"] = \"MaxOffsetExpired\";\n  ValidationResult[\"IssDoesNotMatchIssuer\"] = \"IssDoesNotMatchIssuer\";\n  ValidationResult[\"NoAuthWellKnownEndPoints\"] = \"NoAuthWellKnownEndPoints\";\n  ValidationResult[\"IncorrectAud\"] = \"IncorrectAud\";\n  ValidationResult[\"IncorrectIdTokenClaimsAfterRefresh\"] = \"IncorrectIdTokenClaimsAfterRefresh\";\n  ValidationResult[\"IncorrectAzp\"] = \"IncorrectAzp\";\n  ValidationResult[\"TokenExpired\"] = \"TokenExpired\";\n  ValidationResult[\"IncorrectAtHash\"] = \"IncorrectAtHash\";\n  ValidationResult[\"Ok\"] = \"Ok\";\n  ValidationResult[\"LoginRequired\"] = \"LoginRequired\";\n  ValidationResult[\"SecureTokenServerError\"] = \"SecureTokenServerError\";\n})(ValidationResult || (ValidationResult = {}));\n\nclass SigninKeyDataService {\n  constructor(storagePersistenceService, loggerService, dataService) {\n    this.storagePersistenceService = storagePersistenceService;\n    this.loggerService = loggerService;\n    this.dataService = dataService;\n  }\n\n  getSigningKeys(configId) {\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n    const jwksUri = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.jwksUri;\n\n    if (!jwksUri) {\n      const error = `getSigningKeys: authWellKnownEndpoints.jwksUri is: '${jwksUri}'`;\n      this.loggerService.logWarning(configId, error);\n      return throwError(() => new Error(error));\n    }\n\n    this.loggerService.logDebug(configId, 'Getting signinkeys from ', jwksUri);\n    return this.dataService.get(jwksUri, configId).pipe(retry(2), catchError(e => this.handleErrorGetSigningKeys(e, configId)));\n  }\n\n  handleErrorGetSigningKeys(errorResponse, configId) {\n    let errMsg = '';\n\n    if (errorResponse instanceof HttpResponse) {\n      const body = errorResponse.body || {};\n      const err = JSON.stringify(body);\n      const {\n        status,\n        statusText\n      } = errorResponse;\n      errMsg = `${status || ''} - ${statusText || ''} ${err || ''}`;\n    } else {\n      const {\n        message\n      } = errorResponse;\n      errMsg = !!message ? message : `${errorResponse}`;\n    }\n\n    this.loggerService.logError(configId, errMsg);\n    return throwError(() => new Error(errMsg));\n  }\n\n}\n\nSigninKeyDataService.ɵfac = function SigninKeyDataService_Factory(t) {\n  return new (t || SigninKeyDataService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(DataService));\n};\n\nSigninKeyDataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: SigninKeyDataService,\n  factory: SigninKeyDataService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SigninKeyDataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: LoggerService\n    }, {\n      type: DataService\n    }];\n  }, null);\n})();\n\nconst JWT_KEYS = 'jwtKeys';\n\nclass HistoryJwtKeysCallbackHandlerService {\n  constructor(loggerService, configurationProvider, authStateService, flowsDataService, signInKeyDataService, storagePersistenceService, resetAuthDataService) {\n    this.loggerService = loggerService;\n    this.configurationProvider = configurationProvider;\n    this.authStateService = authStateService;\n    this.flowsDataService = flowsDataService;\n    this.signInKeyDataService = signInKeyDataService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.resetAuthDataService = resetAuthDataService;\n  } // STEP 3 Code Flow, STEP 2 Implicit Flow, STEP 3 Refresh Token\n\n\n  callbackHistoryAndResetJwtKeys(callbackContext, configId) {\n    this.storagePersistenceService.write('authnResult', callbackContext.authResult, configId);\n\n    if (this.historyCleanUpTurnedOn(configId) && !callbackContext.isRenewProcess) {\n      this.resetBrowserHistory();\n    } else {\n      this.loggerService.logDebug(configId, 'history clean up inactive');\n    }\n\n    if (callbackContext.authResult.error) {\n      const errorMessage = `AuthCallback AuthResult came with error: ${callbackContext.authResult.error}`;\n      this.loggerService.logDebug(configId, errorMessage);\n      this.resetAuthDataService.resetAuthorizationData(configId);\n      this.flowsDataService.setNonce('', configId);\n      this.handleResultErrorFromCallback(callbackContext.authResult, callbackContext.isRenewProcess);\n      return throwError(() => new Error(errorMessage));\n    }\n\n    this.loggerService.logDebug(configId, `AuthResult '${JSON.stringify(callbackContext.authResult, null, 2)}'.\n      AuthCallback created, begin token validation`);\n    return this.signInKeyDataService.getSigningKeys(configId).pipe(tap(jwtKeys => this.storeSigningKeys(jwtKeys, configId)), catchError(err => {\n      // fallback: try to load jwtKeys from storage\n      const storedJwtKeys = this.readSigningKeys(configId);\n\n      if (!!storedJwtKeys) {\n        this.loggerService.logWarning(configId, `Failed to retrieve signing keys, fallback to stored keys`);\n        return of(storedJwtKeys);\n      }\n\n      return throwError(() => new Error(err));\n    }), switchMap(jwtKeys => {\n      if (jwtKeys) {\n        callbackContext.jwtKeys = jwtKeys;\n        return of(callbackContext);\n      }\n\n      const errorMessage = `Failed to retrieve signing key`;\n      this.loggerService.logWarning(configId, errorMessage);\n      return throwError(() => new Error(errorMessage));\n    }), catchError(err => {\n      const errorMessage = `Failed to retrieve signing key with error: ${err}`;\n      this.loggerService.logWarning(configId, errorMessage);\n      return throwError(() => new Error(errorMessage));\n    }));\n  }\n\n  handleResultErrorFromCallback(result, isRenewProcess) {\n    let validationResult = ValidationResult.SecureTokenServerError;\n\n    if (result.error === 'login_required') {\n      validationResult = ValidationResult.LoginRequired;\n    }\n\n    this.authStateService.updateAndPublishAuthState({\n      isAuthenticated: false,\n      validationResult,\n      isRenewProcess\n    });\n  }\n\n  historyCleanUpTurnedOn(configId) {\n    const {\n      historyCleanupOff\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    return !historyCleanupOff;\n  }\n\n  resetBrowserHistory() {\n    window.history.replaceState({}, window.document.title, window.location.origin + window.location.pathname);\n  }\n\n  storeSigningKeys(jwtKeys, configId) {\n    this.storagePersistenceService.write(JWT_KEYS, jwtKeys, configId);\n  }\n\n  readSigningKeys(configId) {\n    return this.storagePersistenceService.read(JWT_KEYS, configId);\n  }\n\n}\n\nHistoryJwtKeysCallbackHandlerService.ɵfac = function HistoryJwtKeysCallbackHandlerService_Factory(t) {\n  return new (t || HistoryJwtKeysCallbackHandlerService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(SigninKeyDataService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(ResetAuthDataService));\n};\n\nHistoryJwtKeysCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: HistoryJwtKeysCallbackHandlerService,\n  factory: HistoryJwtKeysCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(HistoryJwtKeysCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: AuthStateService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: SigninKeyDataService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: ResetAuthDataService\n    }];\n  }, null);\n})();\n\nclass UserCallbackHandlerService {\n  constructor(loggerService, configurationProvider, authStateService, flowsDataService, userService, resetAuthDataService) {\n    this.loggerService = loggerService;\n    this.configurationProvider = configurationProvider;\n    this.authStateService = authStateService;\n    this.flowsDataService = flowsDataService;\n    this.userService = userService;\n    this.resetAuthDataService = resetAuthDataService;\n  } // STEP 5 userData\n\n\n  callbackUser(callbackContext, configId) {\n    const {\n      isRenewProcess,\n      validationResult,\n      authResult,\n      refreshToken\n    } = callbackContext;\n    const {\n      autoUserInfo,\n      renewUserInfoAfterTokenRenew\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!autoUserInfo) {\n      if (!isRenewProcess || renewUserInfoAfterTokenRenew) {\n        // userData is set to the id_token decoded, auto get user data set to false\n        if (validationResult.decodedIdToken) {\n          this.userService.setUserDataToStore(validationResult.decodedIdToken, configId);\n        }\n      }\n\n      if (!isRenewProcess && !refreshToken) {\n        this.flowsDataService.setSessionState(authResult.session_state, configId);\n      }\n\n      this.publishAuthState(validationResult, isRenewProcess);\n      return of(callbackContext);\n    }\n\n    return this.userService.getAndPersistUserDataInStore(configId, isRenewProcess, validationResult.idToken, validationResult.decodedIdToken).pipe(switchMap(userData => {\n      if (!!userData) {\n        if (!refreshToken) {\n          this.flowsDataService.setSessionState(authResult.session_state, configId);\n        }\n\n        this.publishAuthState(validationResult, isRenewProcess);\n        return of(callbackContext);\n      } else {\n        this.resetAuthDataService.resetAuthorizationData(configId);\n        this.publishUnauthenticatedState(validationResult, isRenewProcess);\n        const errorMessage = `Called for userData but they were ${userData}`;\n        this.loggerService.logWarning(configId, errorMessage);\n        return throwError(() => new Error(errorMessage));\n      }\n    }), catchError(err => {\n      const errorMessage = `Failed to retrieve user info with error:  ${err}`;\n      this.loggerService.logWarning(configId, errorMessage);\n      return throwError(() => new Error(errorMessage));\n    }));\n  }\n\n  publishAuthState(stateValidationResult, isRenewProcess) {\n    this.authStateService.updateAndPublishAuthState({\n      isAuthenticated: true,\n      validationResult: stateValidationResult.state,\n      isRenewProcess\n    });\n  }\n\n  publishUnauthenticatedState(stateValidationResult, isRenewProcess) {\n    this.authStateService.updateAndPublishAuthState({\n      isAuthenticated: false,\n      validationResult: stateValidationResult.state,\n      isRenewProcess\n    });\n  }\n\n}\n\nUserCallbackHandlerService.ɵfac = function UserCallbackHandlerService_Factory(t) {\n  return new (t || UserCallbackHandlerService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(UserService), i0.ɵɵinject(ResetAuthDataService));\n};\n\nUserCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: UserCallbackHandlerService,\n  factory: UserCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(UserCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: AuthStateService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: UserService\n    }, {\n      type: ResetAuthDataService\n    }];\n  }, null);\n})();\n\nclass StateValidationResult {\n  constructor(accessToken = '', idToken = '', authResponseIsValid = false, decodedIdToken = {\n    at_hash: ''\n  }, state = ValidationResult.NotSet) {\n    this.accessToken = accessToken;\n    this.idToken = idToken;\n    this.authResponseIsValid = authResponseIsValid;\n    this.decodedIdToken = decodedIdToken;\n    this.state = state;\n  }\n\n}\n\nclass EqualityService {\n  isStringEqualOrNonOrderedArrayEqual(value1, value2) {\n    if (this.isNullOrUndefined(value1)) {\n      return false;\n    }\n\n    if (this.isNullOrUndefined(value2)) {\n      return false;\n    }\n\n    if (this.oneValueIsStringAndTheOtherIsArray(value1, value2)) {\n      return false;\n    }\n\n    if (this.bothValuesAreStrings(value1, value2)) {\n      return value1 === value2;\n    }\n\n    if (this.bothValuesAreArrays(value1, value2)) {\n      return this.arraysHaveEqualContent(value1, value2);\n    }\n\n    return false;\n  }\n\n  areEqual(value1, value2) {\n    if (!value1 || !value2) {\n      return false;\n    }\n\n    if (this.bothValuesAreArrays(value1, value2)) {\n      return this.arraysStrictEqual(value1, value2);\n    }\n\n    if (this.bothValuesAreStrings(value1, value2)) {\n      return value1 === value2;\n    }\n\n    if (this.bothValuesAreObjects(value1, value2)) {\n      return JSON.stringify(value1).toLowerCase() === JSON.stringify(value2).toLowerCase();\n    }\n\n    if (this.oneValueIsStringAndTheOtherIsArray(value1, value2)) {\n      if (Array.isArray(value1) && this.valueIsString(value2)) {\n        return value1[0] === value2;\n      }\n\n      if (Array.isArray(value2) && this.valueIsString(value1)) {\n        return value2[0] === value1;\n      }\n    }\n\n    return false;\n  }\n\n  oneValueIsStringAndTheOtherIsArray(value1, value2) {\n    return Array.isArray(value1) && this.valueIsString(value2) || Array.isArray(value2) && this.valueIsString(value1);\n  }\n\n  bothValuesAreObjects(value1, value2) {\n    return this.valueIsObject(value1) && this.valueIsObject(value2);\n  }\n\n  bothValuesAreStrings(value1, value2) {\n    return this.valueIsString(value1) && this.valueIsString(value2);\n  }\n\n  bothValuesAreArrays(value1, value2) {\n    return Array.isArray(value1) && Array.isArray(value2);\n  }\n\n  valueIsString(value) {\n    return typeof value === 'string' || value instanceof String;\n  }\n\n  valueIsObject(value) {\n    return typeof value === 'object';\n  }\n\n  arraysStrictEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n      return false;\n    }\n\n    for (let i = arr1.length; i--;) {\n      if (arr1[i] !== arr2[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  arraysHaveEqualContent(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n      return false;\n    }\n\n    return arr1.some(v => arr2.includes(v));\n  }\n\n  isNullOrUndefined(val) {\n    return val === null || val === undefined;\n  }\n\n}\n\nEqualityService.ɵfac = function EqualityService_Factory(t) {\n  return new (t || EqualityService)();\n};\n\nEqualityService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: EqualityService,\n  factory: EqualityService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(EqualityService, [{\n    type: Injectable\n  }], null, null);\n})();\n\nclass StateValidationService {\n  constructor(storagePersistenceService, tokenValidationService, tokenHelperService, loggerService, configurationProvider, equalityService, flowHelper) {\n    this.storagePersistenceService = storagePersistenceService;\n    this.tokenValidationService = tokenValidationService;\n    this.tokenHelperService = tokenHelperService;\n    this.loggerService = loggerService;\n    this.configurationProvider = configurationProvider;\n    this.equalityService = equalityService;\n    this.flowHelper = flowHelper;\n  }\n\n  getValidatedStateResult(callbackContext, configId) {\n    if (!callbackContext || callbackContext.authResult.error) {\n      return of(new StateValidationResult('', '', false, {}));\n    }\n\n    return this.validateState(callbackContext, configId);\n  }\n\n  validateState(callbackContext, configId) {\n    const toReturn = new StateValidationResult();\n    const authStateControl = this.storagePersistenceService.read('authStateControl', configId);\n\n    if (!this.tokenValidationService.validateStateFromHashCallback(callbackContext.authResult.state, authStateControl, configId)) {\n      this.loggerService.logWarning(configId, 'authCallback incorrect state');\n      toReturn.state = ValidationResult.StatesDoNotMatch;\n      this.handleUnsuccessfulValidation(configId);\n      return of(toReturn);\n    }\n\n    const isCurrentFlowImplicitFlowWithAccessToken = this.flowHelper.isCurrentFlowImplicitFlowWithAccessToken(configId);\n    const isCurrentFlowCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(configId);\n\n    if (isCurrentFlowImplicitFlowWithAccessToken || isCurrentFlowCodeFlow) {\n      toReturn.accessToken = callbackContext.authResult.access_token;\n    }\n\n    if (callbackContext.authResult.id_token) {\n      const {\n        clientId,\n        issValidationOff,\n        maxIdTokenIatOffsetAllowedInSeconds,\n        disableIatOffsetValidation,\n        ignoreNonceAfterRefresh\n      } = this.configurationProvider.getOpenIDConfiguration(configId);\n      toReturn.idToken = callbackContext.authResult.id_token;\n      toReturn.decodedIdToken = this.tokenHelperService.getPayloadFromToken(toReturn.idToken, false, configId);\n      return this.tokenValidationService.validateSignatureIdToken(toReturn.idToken, callbackContext.jwtKeys, configId).pipe(mergeMap(isSignatureIdTokenValid => {\n        if (!isSignatureIdTokenValid) {\n          this.loggerService.logDebug(configId, 'authCallback Signature validation failed id_token');\n          toReturn.state = ValidationResult.SignatureFailed;\n          this.handleUnsuccessfulValidation(configId);\n          return of(toReturn);\n        }\n\n        const authNonce = this.storagePersistenceService.read('authNonce', configId);\n\n        if (!this.tokenValidationService.validateIdTokenNonce(toReturn.decodedIdToken, authNonce, ignoreNonceAfterRefresh, configId)) {\n          this.loggerService.logWarning(configId, 'authCallback incorrect nonce, did you call the checkAuth() method multiple times?');\n          toReturn.state = ValidationResult.IncorrectNonce;\n          this.handleUnsuccessfulValidation(configId);\n          return of(toReturn);\n        }\n\n        if (!this.tokenValidationService.validateRequiredIdToken(toReturn.decodedIdToken, configId)) {\n          this.loggerService.logDebug(configId, 'authCallback Validation, one of the REQUIRED properties missing from id_token');\n          toReturn.state = ValidationResult.RequiredPropertyMissing;\n          this.handleUnsuccessfulValidation(configId);\n          return of(toReturn);\n        }\n\n        if (!this.tokenValidationService.validateIdTokenIatMaxOffset(toReturn.decodedIdToken, maxIdTokenIatOffsetAllowedInSeconds, disableIatOffsetValidation, configId)) {\n          this.loggerService.logWarning(configId, 'authCallback Validation, iat rejected id_token was issued too far away from the current time');\n          toReturn.state = ValidationResult.MaxOffsetExpired;\n          this.handleUnsuccessfulValidation(configId);\n          return of(toReturn);\n        }\n\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n        if (authWellKnownEndPoints) {\n          if (issValidationOff) {\n            this.loggerService.logDebug(configId, 'iss validation is turned off, this is not recommended!');\n          } else if (!issValidationOff && !this.tokenValidationService.validateIdTokenIss(toReturn.decodedIdToken, authWellKnownEndPoints.issuer, configId)) {\n            this.loggerService.logWarning(configId, 'authCallback incorrect iss does not match authWellKnownEndpoints issuer');\n            toReturn.state = ValidationResult.IssDoesNotMatchIssuer;\n            this.handleUnsuccessfulValidation(configId);\n            return of(toReturn);\n          }\n        } else {\n          this.loggerService.logWarning(configId, 'authWellKnownEndpoints is undefined');\n          toReturn.state = ValidationResult.NoAuthWellKnownEndPoints;\n          this.handleUnsuccessfulValidation(configId);\n          return of(toReturn);\n        }\n\n        if (!this.tokenValidationService.validateIdTokenAud(toReturn.decodedIdToken, clientId, configId)) {\n          this.loggerService.logWarning(configId, 'authCallback incorrect aud');\n          toReturn.state = ValidationResult.IncorrectAud;\n          this.handleUnsuccessfulValidation(configId);\n          return of(toReturn);\n        }\n\n        if (!this.tokenValidationService.validateIdTokenAzpExistsIfMoreThanOneAud(toReturn.decodedIdToken)) {\n          this.loggerService.logWarning(configId, 'authCallback missing azp');\n          toReturn.state = ValidationResult.IncorrectAzp;\n          this.handleUnsuccessfulValidation(configId);\n          return of(toReturn);\n        }\n\n        if (!this.tokenValidationService.validateIdTokenAzpValid(toReturn.decodedIdToken, clientId)) {\n          this.loggerService.logWarning(configId, 'authCallback incorrect azp');\n          toReturn.state = ValidationResult.IncorrectAzp;\n          this.handleUnsuccessfulValidation(configId);\n          return of(toReturn);\n        }\n\n        if (!this.isIdTokenAfterRefreshTokenRequestValid(callbackContext, toReturn.decodedIdToken, configId)) {\n          this.loggerService.logWarning(configId, 'authCallback pre, post id_token claims do not match in refresh');\n          toReturn.state = ValidationResult.IncorrectIdTokenClaimsAfterRefresh;\n          this.handleUnsuccessfulValidation(configId);\n          return of(toReturn);\n        }\n\n        if (!this.tokenValidationService.validateIdTokenExpNotExpired(toReturn.decodedIdToken, configId)) {\n          this.loggerService.logWarning(configId, 'authCallback id token expired');\n          toReturn.state = ValidationResult.TokenExpired;\n          this.handleUnsuccessfulValidation(configId);\n          return of(toReturn);\n        }\n\n        return this.validateDefault(isCurrentFlowImplicitFlowWithAccessToken, isCurrentFlowCodeFlow, toReturn, configId, callbackContext);\n      }));\n    } else {\n      this.loggerService.logDebug(configId, 'No id_token found, skipping id_token validation');\n    }\n\n    return this.validateDefault(isCurrentFlowImplicitFlowWithAccessToken, isCurrentFlowCodeFlow, toReturn, configId, callbackContext);\n  }\n\n  validateDefault(isCurrentFlowImplicitFlowWithAccessToken, isCurrentFlowCodeFlow, toReturn, configId, callbackContext) {\n    // flow id_token\n    if (!isCurrentFlowImplicitFlowWithAccessToken && !isCurrentFlowCodeFlow) {\n      toReturn.authResponseIsValid = true;\n      toReturn.state = ValidationResult.Ok;\n      this.handleSuccessfulValidation(configId);\n      this.handleUnsuccessfulValidation(configId);\n      return of(toReturn);\n    } // only do check if id_token returned, no always the case when using refresh tokens\n\n\n    if (callbackContext.authResult.id_token) {\n      const idTokenHeader = this.tokenHelperService.getHeaderFromToken(toReturn.idToken, false, configId);\n\n      if (isCurrentFlowCodeFlow && !toReturn.decodedIdToken.at_hash) {\n        this.loggerService.logDebug(configId, 'Code Flow active, and no at_hash in the id_token, skipping check!');\n      } else {\n        return this.tokenValidationService.validateIdTokenAtHash(toReturn.accessToken, toReturn.decodedIdToken.at_hash, idTokenHeader.alg, // 'RS256'\n        configId).pipe(map(valid => {\n          if (!valid || !toReturn.accessToken) {\n            this.loggerService.logWarning(configId, 'authCallback incorrect at_hash');\n            toReturn.state = ValidationResult.IncorrectAtHash;\n            this.handleUnsuccessfulValidation(configId);\n            return toReturn;\n          } else {\n            toReturn.authResponseIsValid = true;\n            toReturn.state = ValidationResult.Ok;\n            this.handleSuccessfulValidation(configId);\n            return toReturn;\n          }\n        }));\n      }\n    }\n\n    toReturn.authResponseIsValid = true;\n    toReturn.state = ValidationResult.Ok;\n    this.handleSuccessfulValidation(configId);\n    return of(toReturn);\n  }\n\n  isIdTokenAfterRefreshTokenRequestValid(callbackContext, newIdToken, configId) {\n    const {\n      useRefreshToken,\n      disableRefreshIdTokenAuthTimeValidation\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!useRefreshToken) {\n      return true;\n    }\n\n    if (!callbackContext.existingIdToken) {\n      return true;\n    }\n\n    const decodedIdToken = this.tokenHelperService.getPayloadFromToken(callbackContext.existingIdToken, false, configId); // Upon successful validation of the Refresh Token, the response body is the Token Response of Section 3.1.3.3\n    // except that it might not contain an id_token.\n    // If an ID Token is returned as a result of a token refresh request, the following requirements apply:\n    // its iss Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\n\n    if (decodedIdToken.iss !== newIdToken.iss) {\n      this.loggerService.logDebug(configId, `iss do not match: ${decodedIdToken.iss} ${newIdToken.iss}`);\n      return false;\n    } // its azp Claim Value MUST be the same as in the ID Token issued when the original authentication occurred;\n    //   if no azp Claim was present in the original ID Token, one MUST NOT be present in the new ID Token, and\n    // otherwise, the same rules apply as apply when issuing an ID Token at the time of the original authentication.\n\n\n    if (decodedIdToken.azp !== newIdToken.azp) {\n      this.loggerService.logDebug(configId, `azp do not match: ${decodedIdToken.azp} ${newIdToken.azp}`);\n      return false;\n    } // its sub Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\n\n\n    if (decodedIdToken.sub !== newIdToken.sub) {\n      this.loggerService.logDebug(configId, `sub do not match: ${decodedIdToken.sub} ${newIdToken.sub}`);\n      return false;\n    } // its aud Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\n\n\n    if (!this.equalityService.isStringEqualOrNonOrderedArrayEqual(decodedIdToken === null || decodedIdToken === void 0 ? void 0 : decodedIdToken.aud, newIdToken === null || newIdToken === void 0 ? void 0 : newIdToken.aud)) {\n      this.loggerService.logDebug(configId, `aud in new id_token is not valid: '${decodedIdToken === null || decodedIdToken === void 0 ? void 0 : decodedIdToken.aud}' '${newIdToken.aud}'`);\n      return false;\n    }\n\n    if (disableRefreshIdTokenAuthTimeValidation) {\n      return true;\n    } // its iat Claim MUST represent the time that the new ID Token is issued,\n    // if the ID Token contains an auth_time Claim, its value MUST represent the time of the original authentication\n    // - not the time that the new ID token is issued,\n\n\n    if (decodedIdToken.auth_time !== newIdToken.auth_time) {\n      this.loggerService.logDebug(configId, `auth_time do not match: ${decodedIdToken.auth_time} ${newIdToken.auth_time}`);\n      return false;\n    }\n\n    return true;\n  }\n\n  handleSuccessfulValidation(configId) {\n    const {\n      autoCleanStateAfterAuthentication\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    this.storagePersistenceService.write('authNonce', null, configId);\n\n    if (autoCleanStateAfterAuthentication) {\n      this.storagePersistenceService.write('authStateControl', '', configId);\n    }\n\n    this.loggerService.logDebug(configId, 'authCallback token(s) validated, continue');\n  }\n\n  handleUnsuccessfulValidation(configId) {\n    const {\n      autoCleanStateAfterAuthentication\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    this.storagePersistenceService.write('authNonce', null, configId);\n\n    if (autoCleanStateAfterAuthentication) {\n      this.storagePersistenceService.write('authStateControl', '', configId);\n    }\n\n    this.loggerService.logDebug(configId, 'authCallback token(s) invalid');\n  }\n\n}\n\nStateValidationService.ɵfac = function StateValidationService_Factory(t) {\n  return new (t || StateValidationService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(TokenValidationService), i0.ɵɵinject(TokenHelperService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(EqualityService), i0.ɵɵinject(FlowHelper));\n};\n\nStateValidationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StateValidationService,\n  factory: StateValidationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StateValidationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: TokenValidationService\n    }, {\n      type: TokenHelperService\n    }, {\n      type: LoggerService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: EqualityService\n    }, {\n      type: FlowHelper\n    }];\n  }, null);\n})();\n\nclass StateValidationCallbackHandlerService {\n  constructor(loggerService, stateValidationService, authStateService, resetAuthDataService, doc) {\n    this.loggerService = loggerService;\n    this.stateValidationService = stateValidationService;\n    this.authStateService = authStateService;\n    this.resetAuthDataService = resetAuthDataService;\n    this.doc = doc;\n  } // STEP 4 All flows\n\n\n  callbackStateValidation(callbackContext, configId) {\n    return this.stateValidationService.getValidatedStateResult(callbackContext, configId).pipe(map(validationResult => {\n      callbackContext.validationResult = validationResult;\n\n      if (validationResult.authResponseIsValid) {\n        this.authStateService.setAuthorizationData(validationResult.accessToken, callbackContext.authResult, configId);\n        return callbackContext;\n      } else {\n        const errorMessage = `authorizedCallback, token(s) validation failed, resetting. Hash: ${this.doc.location.hash}`;\n        this.loggerService.logWarning(configId, errorMessage);\n        this.resetAuthDataService.resetAuthorizationData(configId);\n        this.publishUnauthorizedState(callbackContext.validationResult, callbackContext.isRenewProcess);\n        throw new Error(errorMessage);\n      }\n    }));\n  }\n\n  publishUnauthorizedState(stateValidationResult, isRenewProcess) {\n    this.authStateService.updateAndPublishAuthState({\n      isAuthenticated: false,\n      validationResult: stateValidationResult.state,\n      isRenewProcess\n    });\n  }\n\n}\n\nStateValidationCallbackHandlerService.ɵfac = function StateValidationCallbackHandlerService_Factory(t) {\n  return new (t || StateValidationCallbackHandlerService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(StateValidationService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(DOCUMENT));\n};\n\nStateValidationCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StateValidationCallbackHandlerService,\n  factory: StateValidationCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StateValidationCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: StateValidationService\n    }, {\n      type: AuthStateService\n    }, {\n      type: ResetAuthDataService\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nclass RefreshSessionCallbackHandlerService {\n  constructor(loggerService, authStateService, flowsDataService) {\n    this.loggerService = loggerService;\n    this.authStateService = authStateService;\n    this.flowsDataService = flowsDataService;\n  } // STEP 1 Refresh session\n\n\n  refreshSessionWithRefreshTokens(configId) {\n    const stateData = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\n    this.loggerService.logDebug(configId, 'RefreshSession created. Adding myautostate: ' + stateData);\n    const refreshToken = this.authStateService.getRefreshToken(configId);\n    const idToken = this.authStateService.getIdToken(configId);\n\n    if (refreshToken) {\n      const callbackContext = {\n        code: null,\n        refreshToken,\n        state: stateData,\n        sessionState: null,\n        authResult: null,\n        isRenewProcess: true,\n        jwtKeys: null,\n        validationResult: null,\n        existingIdToken: idToken\n      };\n      this.loggerService.logDebug(configId, 'found refresh code, obtaining new credentials with refresh code'); // Nonce is not used with refresh tokens; but Key cloak may send it anyway\n\n      this.flowsDataService.setNonce(TokenValidationService.refreshTokenNoncePlaceholder, configId);\n      return of(callbackContext);\n    } else {\n      const errorMessage = 'no refresh token found, please login';\n      this.loggerService.logError(configId, errorMessage);\n      return throwError(() => new Error(errorMessage));\n    }\n  }\n\n}\n\nRefreshSessionCallbackHandlerService.ɵfac = function RefreshSessionCallbackHandlerService_Factory(t) {\n  return new (t || RefreshSessionCallbackHandlerService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService));\n};\n\nRefreshSessionCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RefreshSessionCallbackHandlerService,\n  factory: RefreshSessionCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RefreshSessionCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: AuthStateService\n    }, {\n      type: FlowsDataService\n    }];\n  }, null);\n})();\n\nclass RefreshTokenCallbackHandlerService {\n  constructor(urlService, loggerService, configurationProvider, dataService, storagePersistenceService) {\n    this.urlService = urlService;\n    this.loggerService = loggerService;\n    this.configurationProvider = configurationProvider;\n    this.dataService = dataService;\n    this.storagePersistenceService = storagePersistenceService;\n  } // STEP 2 Refresh Token\n\n\n  refreshTokensRequestTokens(callbackContext, configId, customParamsRefresh) {\n    let headers = new HttpHeaders();\n    headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n    const authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n    const tokenEndpoint = authWellknownEndpoints === null || authWellknownEndpoints === void 0 ? void 0 : authWellknownEndpoints.tokenEndpoint;\n\n    if (!tokenEndpoint) {\n      return throwError(() => new Error('Token Endpoint not defined'));\n    }\n\n    const data = this.urlService.createBodyForCodeFlowRefreshTokensRequest(callbackContext.refreshToken, configId, customParamsRefresh);\n    return this.dataService.post(tokenEndpoint, data, configId, headers).pipe(switchMap(response => {\n      this.loggerService.logDebug(configId, 'token refresh response: ', response);\n      let authResult = new Object();\n      authResult = response;\n      authResult.state = callbackContext.state;\n      callbackContext.authResult = authResult;\n      return of(callbackContext);\n    }), retryWhen(error => this.handleRefreshRetry(error, configId)), catchError(error => {\n      const {\n        authority\n      } = this.configurationProvider.getOpenIDConfiguration(configId);\n      const errorMessage = `OidcService code request ${authority}`;\n      this.loggerService.logError(configId, errorMessage, error);\n      return throwError(() => new Error(errorMessage));\n    }));\n  }\n\n  handleRefreshRetry(errors, configId) {\n    return errors.pipe(mergeMap(error => {\n      // retry token refresh if there is no internet connection\n      if (error && error instanceof HttpErrorResponse && error.error instanceof ProgressEvent && error.error.type === 'error') {\n        const {\n          authority,\n          refreshTokenRetryInSeconds\n        } = this.configurationProvider.getOpenIDConfiguration(configId);\n        const errorMessage = `OidcService code request ${authority} - no internet connection`;\n        this.loggerService.logWarning(configId, errorMessage, error);\n        return timer(refreshTokenRetryInSeconds * 1000);\n      }\n\n      return throwError(() => new Error(error));\n    }));\n  }\n\n}\n\nRefreshTokenCallbackHandlerService.ɵfac = function RefreshTokenCallbackHandlerService_Factory(t) {\n  return new (t || RefreshTokenCallbackHandlerService)(i0.ɵɵinject(UrlService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(DataService), i0.ɵɵinject(StoragePersistenceService));\n};\n\nRefreshTokenCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RefreshTokenCallbackHandlerService,\n  factory: RefreshTokenCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RefreshTokenCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: UrlService\n    }, {\n      type: LoggerService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: DataService\n    }, {\n      type: StoragePersistenceService\n    }];\n  }, null);\n})();\n\nclass FlowsService {\n  constructor(codeFlowCallbackHandlerService, implicitFlowCallbackHandlerService, historyJwtKeysCallbackHandlerService, userHandlerService, stateValidationCallbackHandlerService, refreshSessionCallbackHandlerService, refreshTokenCallbackHandlerService) {\n    this.codeFlowCallbackHandlerService = codeFlowCallbackHandlerService;\n    this.implicitFlowCallbackHandlerService = implicitFlowCallbackHandlerService;\n    this.historyJwtKeysCallbackHandlerService = historyJwtKeysCallbackHandlerService;\n    this.userHandlerService = userHandlerService;\n    this.stateValidationCallbackHandlerService = stateValidationCallbackHandlerService;\n    this.refreshSessionCallbackHandlerService = refreshSessionCallbackHandlerService;\n    this.refreshTokenCallbackHandlerService = refreshTokenCallbackHandlerService;\n  }\n\n  processCodeFlowCallback(urlToCheck, configId) {\n    return this.codeFlowCallbackHandlerService.codeFlowCallback(urlToCheck, configId).pipe(concatMap(callbackContext => this.codeFlowCallbackHandlerService.codeFlowCodeRequest(callbackContext, configId)), concatMap(callbackContext => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, configId)), concatMap(callbackContext => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, configId)), concatMap(callbackContext => this.userHandlerService.callbackUser(callbackContext, configId)));\n  }\n\n  processSilentRenewCodeFlowCallback(firstContext, configId) {\n    return this.codeFlowCallbackHandlerService.codeFlowCodeRequest(firstContext, configId).pipe(concatMap(callbackContext => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, configId)), concatMap(callbackContext => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, configId)), concatMap(callbackContext => this.userHandlerService.callbackUser(callbackContext, configId)));\n  }\n\n  processImplicitFlowCallback(configId, hash) {\n    return this.implicitFlowCallbackHandlerService.implicitFlowCallback(configId, hash).pipe(concatMap(callbackContext => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, configId)), concatMap(callbackContext => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, configId)), concatMap(callbackContext => this.userHandlerService.callbackUser(callbackContext, configId)));\n  }\n\n  processRefreshToken(configId, customParamsRefresh) {\n    return this.refreshSessionCallbackHandlerService.refreshSessionWithRefreshTokens(configId).pipe(concatMap(callbackContext => this.refreshTokenCallbackHandlerService.refreshTokensRequestTokens(callbackContext, configId, customParamsRefresh)), concatMap(callbackContext => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, configId)), concatMap(callbackContext => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, configId)), concatMap(callbackContext => this.userHandlerService.callbackUser(callbackContext, configId)));\n  }\n\n}\n\nFlowsService.ɵfac = function FlowsService_Factory(t) {\n  return new (t || FlowsService)(i0.ɵɵinject(CodeFlowCallbackHandlerService), i0.ɵɵinject(ImplicitFlowCallbackHandlerService), i0.ɵɵinject(HistoryJwtKeysCallbackHandlerService), i0.ɵɵinject(UserCallbackHandlerService), i0.ɵɵinject(StateValidationCallbackHandlerService), i0.ɵɵinject(RefreshSessionCallbackHandlerService), i0.ɵɵinject(RefreshTokenCallbackHandlerService));\n};\n\nFlowsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: FlowsService,\n  factory: FlowsService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(FlowsService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: CodeFlowCallbackHandlerService\n    }, {\n      type: ImplicitFlowCallbackHandlerService\n    }, {\n      type: HistoryJwtKeysCallbackHandlerService\n    }, {\n      type: UserCallbackHandlerService\n    }, {\n      type: StateValidationCallbackHandlerService\n    }, {\n      type: RefreshSessionCallbackHandlerService\n    }, {\n      type: RefreshTokenCallbackHandlerService\n    }];\n  }, null);\n})();\n\nclass IntervalService {\n  constructor(zone) {\n    this.zone = zone;\n    this.runTokenValidationRunning = null;\n  }\n\n  stopPeriodicTokenCheck() {\n    if (this.runTokenValidationRunning) {\n      this.runTokenValidationRunning.unsubscribe();\n      this.runTokenValidationRunning = null;\n    }\n  }\n\n  startPeriodicTokenCheck(repeatAfterSeconds) {\n    const millisecondsDelayBetweenTokenCheck = repeatAfterSeconds * 1000;\n    return new Observable(subscriber => {\n      let intervalId;\n      this.zone.runOutsideAngular(() => {\n        intervalId = setInterval(() => this.zone.run(() => subscriber.next()), millisecondsDelayBetweenTokenCheck);\n      });\n      return () => {\n        clearInterval(intervalId);\n      };\n    });\n  }\n\n}\n\nIntervalService.ɵfac = function IntervalService_Factory(t) {\n  return new (t || IntervalService)(i0.ɵɵinject(i0.NgZone));\n};\n\nIntervalService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: IntervalService,\n  factory: IntervalService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(IntervalService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: i0.NgZone\n    }];\n  }, null);\n})();\n\nclass ImplicitFlowCallbackService {\n  constructor(flowsService, configurationProvider, router, flowsDataService, intervalService) {\n    this.flowsService = flowsService;\n    this.configurationProvider = configurationProvider;\n    this.router = router;\n    this.flowsDataService = flowsDataService;\n    this.intervalService = intervalService;\n  }\n\n  authenticatedImplicitFlowCallback(configId, hash) {\n    const isRenewProcess = this.flowsDataService.isSilentRenewRunning(configId);\n    const {\n      triggerAuthorizationResultEvent,\n      postLoginRoute,\n      unauthorizedRoute\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    return this.flowsService.processImplicitFlowCallback(configId, hash).pipe(tap(callbackContext => {\n      if (!triggerAuthorizationResultEvent && !callbackContext.isRenewProcess) {\n        this.router.navigateByUrl(postLoginRoute);\n      }\n    }), catchError(error => {\n      this.flowsDataService.resetSilentRenewRunning(configId);\n      this.intervalService.stopPeriodicTokenCheck();\n\n      if (!triggerAuthorizationResultEvent && !isRenewProcess) {\n        this.router.navigateByUrl(unauthorizedRoute);\n      }\n\n      return throwError(() => new Error(error));\n    }));\n  }\n\n}\n\nImplicitFlowCallbackService.ɵfac = function ImplicitFlowCallbackService_Factory(t) {\n  return new (t || ImplicitFlowCallbackService)(i0.ɵɵinject(FlowsService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(i2.Router), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(IntervalService));\n};\n\nImplicitFlowCallbackService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ImplicitFlowCallbackService,\n  factory: ImplicitFlowCallbackService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ImplicitFlowCallbackService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: FlowsService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: i2.Router\n    }, {\n      type: FlowsDataService\n    }, {\n      type: IntervalService\n    }];\n  }, null);\n})();\n\nclass IFrameService {\n  constructor(doc, loggerService) {\n    this.doc = doc;\n    this.loggerService = loggerService;\n  }\n\n  getExistingIFrame(identifier) {\n    const iFrameOnParent = this.getIFrameFromParentWindow(identifier);\n\n    if (this.isIFrameElement(iFrameOnParent)) {\n      return iFrameOnParent;\n    }\n\n    const iFrameOnSelf = this.getIFrameFromWindow(identifier);\n\n    if (this.isIFrameElement(iFrameOnSelf)) {\n      return iFrameOnSelf;\n    }\n\n    return null;\n  }\n\n  addIFrameToWindowBody(identifier, configId) {\n    const sessionIframe = this.doc.createElement('iframe');\n    sessionIframe.id = identifier;\n    sessionIframe.title = identifier;\n    this.loggerService.logDebug(configId, sessionIframe);\n    sessionIframe.style.display = 'none';\n    this.doc.body.appendChild(sessionIframe);\n    return sessionIframe;\n  }\n\n  getIFrameFromParentWindow(identifier) {\n    try {\n      const iFrameElement = this.doc.defaultView.parent.document.getElementById(identifier);\n\n      if (this.isIFrameElement(iFrameElement)) {\n        return iFrameElement;\n      }\n\n      return null;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  getIFrameFromWindow(identifier) {\n    const iFrameElement = this.doc.getElementById(identifier);\n\n    if (this.isIFrameElement(iFrameElement)) {\n      return iFrameElement;\n    }\n\n    return null;\n  }\n\n  isIFrameElement(element) {\n    return !!element && element instanceof HTMLIFrameElement;\n  }\n\n}\n\nIFrameService.ɵfac = function IFrameService_Factory(t) {\n  return new (t || IFrameService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(LoggerService));\n};\n\nIFrameService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: IFrameService,\n  factory: IFrameService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(IFrameService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: LoggerService\n    }];\n  }, null);\n})();\n\nconst IFRAME_FOR_CHECK_SESSION_IDENTIFIER = 'myiFrameForCheckSession'; // http://openid.net/specs/openid-connect-session-1_0-ID4.html\n\nclass CheckSessionService {\n  constructor(storagePersistenceService, loggerService, iFrameService, eventService, configurationProvider, zone) {\n    this.storagePersistenceService = storagePersistenceService;\n    this.loggerService = loggerService;\n    this.iFrameService = iFrameService;\n    this.eventService = eventService;\n    this.configurationProvider = configurationProvider;\n    this.zone = zone;\n    this.checkSessionReceived = false;\n    this.lastIFrameRefresh = 0;\n    this.outstandingMessages = 0;\n    this.heartBeatInterval = 3000;\n    this.iframeRefreshInterval = 60000;\n    this.checkSessionChangedInternal$ = new BehaviorSubject(false);\n  }\n\n  get checkSessionChanged$() {\n    return this.checkSessionChangedInternal$.asObservable();\n  }\n\n  isCheckSessionConfigured(configId) {\n    const {\n      startCheckSession\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    return startCheckSession;\n  }\n\n  start(configId) {\n    if (!!this.scheduledHeartBeatRunning) {\n      return;\n    }\n\n    const {\n      clientId\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    this.pollServerSession(clientId, configId);\n  }\n\n  stop() {\n    if (!this.scheduledHeartBeatRunning) {\n      return;\n    }\n\n    this.clearScheduledHeartBeat();\n    this.checkSessionReceived = false;\n  }\n\n  serverStateChanged(configId) {\n    const {\n      startCheckSession\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    return startCheckSession && this.checkSessionReceived;\n  }\n\n  getExistingIframe() {\n    return this.iFrameService.getExistingIFrame(IFRAME_FOR_CHECK_SESSION_IDENTIFIER);\n  }\n\n  init(configId) {\n    if (this.lastIFrameRefresh + this.iframeRefreshInterval > Date.now()) {\n      return of(undefined);\n    }\n\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n    if (!authWellKnownEndPoints) {\n      this.loggerService.logWarning(configId, 'CheckSession - init check session: authWellKnownEndpoints is undefined. Returning.');\n      return of();\n    }\n\n    const existingIframe = this.getOrCreateIframe(configId);\n    const checkSessionIframe = authWellKnownEndPoints.checkSessionIframe;\n\n    if (checkSessionIframe) {\n      existingIframe.contentWindow.location.replace(checkSessionIframe);\n    } else {\n      this.loggerService.logWarning(configId, 'CheckSession - init check session: checkSessionIframe is not configured to run');\n    }\n\n    return new Observable(observer => {\n      existingIframe.onload = () => {\n        this.lastIFrameRefresh = Date.now();\n        observer.next();\n        observer.complete();\n      };\n    });\n  }\n\n  pollServerSession(clientId, configId) {\n    this.outstandingMessages = 0;\n\n    const pollServerSessionRecur = () => {\n      this.init(configId).pipe(take(1)).subscribe(() => {\n        var _a;\n\n        const existingIframe = this.getExistingIframe();\n\n        if (existingIframe && clientId) {\n          this.loggerService.logDebug(configId, `CheckSession - clientId : '${clientId}' - existingIframe: '${existingIframe}'`);\n          const sessionState = this.storagePersistenceService.read('session_state', configId);\n          const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n          if (sessionState && (authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.checkSessionIframe)) {\n            const iframeOrigin = (_a = new URL(authWellKnownEndPoints.checkSessionIframe)) === null || _a === void 0 ? void 0 : _a.origin;\n            this.outstandingMessages++;\n            existingIframe.contentWindow.postMessage(clientId + ' ' + sessionState, iframeOrigin);\n          } else {\n            this.loggerService.logDebug(configId, `CheckSession - session_state is '${sessionState}' - AuthWellKnownEndPoints is '${JSON.stringify(authWellKnownEndPoints, null, 2)}'`);\n            this.checkSessionChangedInternal$.next(true);\n          }\n        } else {\n          this.loggerService.logWarning(configId, `CheckSession - OidcSecurityCheckSession pollServerSession checkSession IFrame does not exist:\n               clientId : '${clientId}' - existingIframe: '${existingIframe}'`);\n        } // after sending three messages with no response, fail.\n\n\n        if (this.outstandingMessages > 3) {\n          this.loggerService.logError(configId, `CheckSession - OidcSecurityCheckSession not receiving check session response messages.\n                            Outstanding messages: '${this.outstandingMessages}'. Server unreachable?`);\n        }\n\n        this.zone.runOutsideAngular(() => {\n          this.scheduledHeartBeatRunning = setTimeout(() => this.zone.run(pollServerSessionRecur), this.heartBeatInterval);\n        });\n      });\n    };\n\n    pollServerSessionRecur();\n  }\n\n  clearScheduledHeartBeat() {\n    clearTimeout(this.scheduledHeartBeatRunning);\n    this.scheduledHeartBeatRunning = null;\n  }\n\n  messageHandler(configId, e) {\n    var _a;\n\n    const existingIFrame = this.getExistingIframe();\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n    const startsWith = !!((_a = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.checkSessionIframe) === null || _a === void 0 ? void 0 : _a.startsWith(e.origin));\n    this.outstandingMessages = 0;\n\n    if (existingIFrame && startsWith && e.source === existingIFrame.contentWindow) {\n      if (e.data === 'error') {\n        this.loggerService.logWarning(configId, 'CheckSession - error from check session messageHandler');\n      } else if (e.data === 'changed') {\n        this.loggerService.logDebug(configId, `CheckSession - ${e} from check session messageHandler`);\n        this.checkSessionReceived = true;\n        this.eventService.fireEvent(EventTypes.CheckSessionReceived, e.data);\n        this.checkSessionChangedInternal$.next(true);\n      } else {\n        this.eventService.fireEvent(EventTypes.CheckSessionReceived, e.data);\n        this.loggerService.logDebug(configId, `CheckSession - ${e.data} from check session messageHandler`);\n      }\n    }\n  }\n\n  bindMessageEventToIframe(configId) {\n    const iframeMessageEvent = this.messageHandler.bind(this, configId);\n    window.addEventListener('message', iframeMessageEvent, false);\n  }\n\n  getOrCreateIframe(configId) {\n    const existingIframe = this.getExistingIframe();\n\n    if (!existingIframe) {\n      const frame = this.iFrameService.addIFrameToWindowBody(IFRAME_FOR_CHECK_SESSION_IDENTIFIER, configId);\n      this.bindMessageEventToIframe(configId);\n      return frame;\n    }\n\n    return existingIframe;\n  }\n\n}\n\nCheckSessionService.ɵfac = function CheckSessionService_Factory(t) {\n  return new (t || CheckSessionService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(IFrameService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(i0.NgZone));\n};\n\nCheckSessionService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CheckSessionService,\n  factory: CheckSessionService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CheckSessionService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: LoggerService\n    }, {\n      type: IFrameService\n    }, {\n      type: PublicEventsService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: i0.NgZone\n    }];\n  }, null);\n})();\n\nclass CurrentUrlService {\n  constructor(doc) {\n    this.doc = doc;\n  }\n\n  getStateParamFromCurrentUrl() {\n    const currentUrl = this.getCurrentUrl();\n    const parsedUrl = new URL(currentUrl);\n    const urlParams = new URLSearchParams(parsedUrl.search);\n    const stateFromUrl = urlParams.get('state');\n    return stateFromUrl;\n  }\n\n  currentUrlHasStateParam() {\n    return !!this.getStateParamFromCurrentUrl();\n  }\n\n  getCurrentUrl() {\n    return this.doc.defaultView.location.toString();\n  }\n\n}\n\nCurrentUrlService.ɵfac = function CurrentUrlService_Factory(t) {\n  return new (t || CurrentUrlService)(i0.ɵɵinject(DOCUMENT));\n};\n\nCurrentUrlService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CurrentUrlService,\n  factory: CurrentUrlService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CurrentUrlService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nconst IFRAME_FOR_SILENT_RENEW_IDENTIFIER = 'myiFrameForSilentRenew';\n\nclass SilentRenewService {\n  constructor(configurationProvider, iFrameService, flowsService, resetAuthDataService, flowsDataService, authStateService, loggerService, flowHelper, implicitFlowCallbackService, intervalService) {\n    this.configurationProvider = configurationProvider;\n    this.iFrameService = iFrameService;\n    this.flowsService = flowsService;\n    this.resetAuthDataService = resetAuthDataService;\n    this.flowsDataService = flowsDataService;\n    this.authStateService = authStateService;\n    this.loggerService = loggerService;\n    this.flowHelper = flowHelper;\n    this.implicitFlowCallbackService = implicitFlowCallbackService;\n    this.intervalService = intervalService;\n    this.refreshSessionWithIFrameCompletedInternal$ = new Subject();\n  }\n\n  get refreshSessionWithIFrameCompleted$() {\n    return this.refreshSessionWithIFrameCompletedInternal$.asObservable();\n  }\n\n  getOrCreateIframe(configId) {\n    const existingIframe = this.getExistingIframe();\n\n    if (!existingIframe) {\n      return this.iFrameService.addIFrameToWindowBody(IFRAME_FOR_SILENT_RENEW_IDENTIFIER, configId);\n    }\n\n    return existingIframe;\n  }\n\n  isSilentRenewConfigured(configId) {\n    const {\n      useRefreshToken,\n      silentRenew\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    return !useRefreshToken && silentRenew;\n  }\n\n  codeFlowCallbackSilentRenewIframe(urlParts, configId) {\n    const params = new HttpParams({\n      fromString: urlParts[1]\n    });\n    const error = params.get('error');\n\n    if (error) {\n      this.authStateService.updateAndPublishAuthState({\n        isAuthenticated: false,\n        validationResult: ValidationResult.LoginRequired,\n        isRenewProcess: true\n      });\n      this.resetAuthDataService.resetAuthorizationData(configId);\n      this.flowsDataService.setNonce('', configId);\n      this.intervalService.stopPeriodicTokenCheck();\n      return throwError(() => new Error(error));\n    }\n\n    const code = params.get('code');\n    const state = params.get('state');\n    const sessionState = params.get('session_state');\n    const callbackContext = {\n      code,\n      refreshToken: null,\n      state,\n      sessionState,\n      authResult: null,\n      isRenewProcess: true,\n      jwtKeys: null,\n      validationResult: null,\n      existingIdToken: null\n    };\n    return this.flowsService.processSilentRenewCodeFlowCallback(callbackContext, configId).pipe(catchError(errorFromFlow => {\n      this.intervalService.stopPeriodicTokenCheck();\n      this.resetAuthDataService.resetAuthorizationData(configId);\n      return throwError(() => new Error(error));\n    }));\n  }\n\n  silentRenewEventHandler(e, configId) {\n    this.loggerService.logDebug(configId, 'silentRenewEventHandler');\n\n    if (!e.detail) {\n      return;\n    }\n\n    let callback$ = of(null);\n    const isCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(configId);\n\n    if (isCodeFlow) {\n      const urlParts = e.detail.toString().split('?');\n      callback$ = this.codeFlowCallbackSilentRenewIframe(urlParts, configId);\n    } else {\n      callback$ = this.implicitFlowCallbackService.authenticatedImplicitFlowCallback(configId, e.detail);\n    }\n\n    callback$.subscribe({\n      next: callbackContext => {\n        this.refreshSessionWithIFrameCompletedInternal$.next(callbackContext);\n        this.flowsDataService.resetSilentRenewRunning(configId);\n      },\n      error: err => {\n        this.loggerService.logError(configId, 'Error: ' + err);\n        this.refreshSessionWithIFrameCompletedInternal$.next(null);\n        this.flowsDataService.resetSilentRenewRunning(configId);\n      }\n    });\n  }\n\n  getExistingIframe() {\n    return this.iFrameService.getExistingIFrame(IFRAME_FOR_SILENT_RENEW_IDENTIFIER);\n  }\n\n}\n\nSilentRenewService.ɵfac = function SilentRenewService_Factory(t) {\n  return new (t || SilentRenewService)(i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(IFrameService), i0.ɵɵinject(FlowsService), i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(FlowHelper), i0.ɵɵinject(ImplicitFlowCallbackService), i0.ɵɵinject(IntervalService));\n};\n\nSilentRenewService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: SilentRenewService,\n  factory: SilentRenewService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SilentRenewService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ConfigurationProvider\n    }, {\n      type: IFrameService\n    }, {\n      type: FlowsService\n    }, {\n      type: ResetAuthDataService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: AuthStateService\n    }, {\n      type: LoggerService\n    }, {\n      type: FlowHelper\n    }, {\n      type: ImplicitFlowCallbackService\n    }, {\n      type: IntervalService\n    }];\n  }, null);\n})();\n\nclass CodeFlowCallbackService {\n  constructor(flowsService, flowsDataService, intervalService, configurationProvider, router) {\n    this.flowsService = flowsService;\n    this.flowsDataService = flowsDataService;\n    this.intervalService = intervalService;\n    this.configurationProvider = configurationProvider;\n    this.router = router;\n  }\n\n  authenticatedCallbackWithCode(urlToCheck, configId) {\n    const isRenewProcess = this.flowsDataService.isSilentRenewRunning(configId);\n    const {\n      triggerAuthorizationResultEvent,\n      postLoginRoute,\n      unauthorizedRoute\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    return this.flowsService.processCodeFlowCallback(urlToCheck, configId).pipe(tap(callbackContext => {\n      if (!triggerAuthorizationResultEvent && !callbackContext.isRenewProcess) {\n        this.router.navigateByUrl(postLoginRoute);\n      }\n    }), catchError(error => {\n      this.flowsDataService.resetSilentRenewRunning(configId);\n      this.intervalService.stopPeriodicTokenCheck();\n\n      if (!triggerAuthorizationResultEvent && !isRenewProcess) {\n        this.router.navigateByUrl(unauthorizedRoute);\n      }\n\n      return throwError(() => new Error(error));\n    }));\n  }\n\n}\n\nCodeFlowCallbackService.ɵfac = function CodeFlowCallbackService_Factory(t) {\n  return new (t || CodeFlowCallbackService)(i0.ɵɵinject(FlowsService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(IntervalService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(i2.Router));\n};\n\nCodeFlowCallbackService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CodeFlowCallbackService,\n  factory: CodeFlowCallbackService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CodeFlowCallbackService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: FlowsService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: IntervalService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: i2.Router\n    }];\n  }, null);\n})();\n\nclass CallbackService {\n  constructor(urlService, flowHelper, implicitFlowCallbackService, codeFlowCallbackService) {\n    this.urlService = urlService;\n    this.flowHelper = flowHelper;\n    this.implicitFlowCallbackService = implicitFlowCallbackService;\n    this.codeFlowCallbackService = codeFlowCallbackService;\n    this.stsCallbackInternal$ = new Subject();\n  }\n\n  get stsCallback$() {\n    return this.stsCallbackInternal$.asObservable();\n  }\n\n  isCallback(currentUrl) {\n    return this.urlService.isCallbackFromSts(currentUrl);\n  }\n\n  handleCallbackAndFireEvents(currentCallbackUrl, configId) {\n    let callback$;\n\n    if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\n      callback$ = this.codeFlowCallbackService.authenticatedCallbackWithCode(currentCallbackUrl, configId);\n    } else if (this.flowHelper.isCurrentFlowAnyImplicitFlow(configId)) {\n      callback$ = this.implicitFlowCallbackService.authenticatedImplicitFlowCallback(configId);\n    }\n\n    return callback$.pipe(tap(() => this.stsCallbackInternal$.next()));\n  }\n\n}\n\nCallbackService.ɵfac = function CallbackService_Factory(t) {\n  return new (t || CallbackService)(i0.ɵɵinject(UrlService), i0.ɵɵinject(FlowHelper), i0.ɵɵinject(ImplicitFlowCallbackService), i0.ɵɵinject(CodeFlowCallbackService));\n};\n\nCallbackService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CallbackService,\n  factory: CallbackService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CallbackService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: UrlService\n    }, {\n      type: FlowHelper\n    }, {\n      type: ImplicitFlowCallbackService\n    }, {\n      type: CodeFlowCallbackService\n    }];\n  }, null);\n})();\n\nconst WELL_KNOWN_SUFFIX = `/.well-known/openid-configuration`;\n\nclass AuthWellKnownDataService {\n  constructor(http) {\n    this.http = http;\n  }\n\n  getWellKnownEndPointsFromUrl(authWellknownEndpoint, configId) {\n    return this.getWellKnownDocument(authWellknownEndpoint, configId).pipe(map(wellKnownEndpoints => ({\n      issuer: wellKnownEndpoints.issuer,\n      jwksUri: wellKnownEndpoints.jwks_uri,\n      authorizationEndpoint: wellKnownEndpoints.authorization_endpoint,\n      tokenEndpoint: wellKnownEndpoints.token_endpoint,\n      userInfoEndpoint: wellKnownEndpoints.userinfo_endpoint,\n      endSessionEndpoint: wellKnownEndpoints.end_session_endpoint,\n      checkSessionIframe: wellKnownEndpoints.check_session_iframe,\n      revocationEndpoint: wellKnownEndpoints.revocation_endpoint,\n      introspectionEndpoint: wellKnownEndpoints.introspection_endpoint,\n      parEndpoint: wellKnownEndpoints.pushed_authorization_request_endpoint\n    })));\n  }\n\n  getWellKnownDocument(wellKnownEndpoint, configId) {\n    let url = wellKnownEndpoint;\n\n    if (!wellKnownEndpoint.includes(WELL_KNOWN_SUFFIX)) {\n      url = `${wellKnownEndpoint}${WELL_KNOWN_SUFFIX}`;\n    }\n\n    return this.http.get(url, configId).pipe(retry(2));\n  }\n\n}\n\nAuthWellKnownDataService.ɵfac = function AuthWellKnownDataService_Factory(t) {\n  return new (t || AuthWellKnownDataService)(i0.ɵɵinject(DataService));\n};\n\nAuthWellKnownDataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AuthWellKnownDataService,\n  factory: AuthWellKnownDataService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthWellKnownDataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: DataService\n    }];\n  }, null);\n})();\n\nclass AuthWellKnownService {\n  constructor(publicEventsService, dataService, storagePersistenceService) {\n    this.publicEventsService = publicEventsService;\n    this.dataService = dataService;\n    this.storagePersistenceService = storagePersistenceService;\n  }\n\n  getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId) {\n    const alreadySavedWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n    if (!!alreadySavedWellKnownEndpoints) {\n      return of(alreadySavedWellKnownEndpoints);\n    }\n\n    return this.getWellKnownEndPointsFromUrl(authWellknownEndpointUrl, configId).pipe(tap(mappedWellKnownEndpoints => this.storeWellKnownEndpoints(configId, mappedWellKnownEndpoints)), catchError(error => {\n      this.publicEventsService.fireEvent(EventTypes.ConfigLoadingFailed, null);\n      return throwError(() => new Error(error));\n    }));\n  }\n\n  storeWellKnownEndpoints(configId, mappedWellKnownEndpoints) {\n    this.storagePersistenceService.write('authWellKnownEndPoints', mappedWellKnownEndpoints, configId);\n  }\n\n  getWellKnownEndPointsFromUrl(authWellknownEndpointUrl, configId) {\n    return this.dataService.getWellKnownEndPointsFromUrl(authWellknownEndpointUrl, configId);\n  }\n\n}\n\nAuthWellKnownService.ɵfac = function AuthWellKnownService_Factory(t) {\n  return new (t || AuthWellKnownService)(i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(AuthWellKnownDataService), i0.ɵɵinject(StoragePersistenceService));\n};\n\nAuthWellKnownService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AuthWellKnownService,\n  factory: AuthWellKnownService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthWellKnownService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: PublicEventsService\n    }, {\n      type: AuthWellKnownDataService\n    }, {\n      type: StoragePersistenceService\n    }];\n  }, null);\n})();\n\nclass RefreshSessionIframeService {\n  constructor(doc, loggerService, urlService, silentRenewService, rendererFactory) {\n    this.doc = doc;\n    this.loggerService = loggerService;\n    this.urlService = urlService;\n    this.silentRenewService = silentRenewService;\n    this.renderer = rendererFactory.createRenderer(null, null);\n  }\n\n  refreshSessionWithIframe(configId, customParams) {\n    this.loggerService.logDebug(configId, 'BEGIN refresh session Authorize Iframe renew');\n    return this.urlService.getRefreshSessionSilentRenewUrl(configId, customParams).pipe(switchMap(url => {\n      return this.sendAuthorizeRequestUsingSilentRenew(url, configId);\n    }));\n  }\n\n  sendAuthorizeRequestUsingSilentRenew(url, configId) {\n    const sessionIframe = this.silentRenewService.getOrCreateIframe(configId);\n    this.initSilentRenewRequest(configId);\n    this.loggerService.logDebug(configId, 'sendAuthorizeRequestUsingSilentRenew for URL:' + url);\n    return new Observable(observer => {\n      const onLoadHandler = () => {\n        sessionIframe.removeEventListener('load', onLoadHandler);\n        this.loggerService.logDebug(configId, 'removed event listener from IFrame');\n        observer.next(true);\n        observer.complete();\n      };\n\n      sessionIframe.addEventListener('load', onLoadHandler);\n      sessionIframe.contentWindow.location.replace(url);\n    });\n  }\n\n  initSilentRenewRequest(configId) {\n    const instanceId = Math.random();\n    const initDestroyHandler = this.renderer.listen('window', 'oidc-silent-renew-init', e => {\n      if (e.detail !== instanceId) {\n        initDestroyHandler();\n        renewDestroyHandler();\n      }\n    });\n    const renewDestroyHandler = this.renderer.listen('window', 'oidc-silent-renew-message', e => this.silentRenewService.silentRenewEventHandler(e, configId));\n    this.doc.defaultView.dispatchEvent(new CustomEvent('oidc-silent-renew-init', {\n      detail: instanceId\n    }));\n  }\n\n}\n\nRefreshSessionIframeService.ɵfac = function RefreshSessionIframeService_Factory(t) {\n  return new (t || RefreshSessionIframeService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(LoggerService), i0.ɵɵinject(UrlService), i0.ɵɵinject(SilentRenewService), i0.ɵɵinject(i0.RendererFactory2));\n};\n\nRefreshSessionIframeService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RefreshSessionIframeService,\n  factory: RefreshSessionIframeService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RefreshSessionIframeService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: LoggerService\n    }, {\n      type: UrlService\n    }, {\n      type: SilentRenewService\n    }, {\n      type: i0.RendererFactory2\n    }];\n  }, null);\n})();\n\nclass RefreshSessionRefreshTokenService {\n  constructor(loggerService, resetAuthDataService, flowsService, intervalService) {\n    this.loggerService = loggerService;\n    this.resetAuthDataService = resetAuthDataService;\n    this.flowsService = flowsService;\n    this.intervalService = intervalService;\n  }\n\n  refreshSessionWithRefreshTokens(configId, customParamsRefresh) {\n    this.loggerService.logDebug(configId, 'BEGIN refresh session Authorize');\n    return this.flowsService.processRefreshToken(configId, customParamsRefresh).pipe(catchError(error => {\n      this.intervalService.stopPeriodicTokenCheck();\n      this.resetAuthDataService.resetAuthorizationData(configId);\n      return throwError(() => new Error(error));\n    }));\n  }\n\n}\n\nRefreshSessionRefreshTokenService.ɵfac = function RefreshSessionRefreshTokenService_Factory(t) {\n  return new (t || RefreshSessionRefreshTokenService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(FlowsService), i0.ɵɵinject(IntervalService));\n};\n\nRefreshSessionRefreshTokenService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RefreshSessionRefreshTokenService,\n  factory: RefreshSessionRefreshTokenService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RefreshSessionRefreshTokenService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: ResetAuthDataService\n    }, {\n      type: FlowsService\n    }, {\n      type: IntervalService\n    }];\n  }, null);\n})();\n\nconst MAX_RETRY_ATTEMPTS = 3;\n\nclass RefreshSessionService {\n  constructor(flowHelper, configurationProvider, flowsDataService, loggerService, silentRenewService, authStateService, authWellKnownService, refreshSessionIframeService, storagePersistenceService, refreshSessionRefreshTokenService, userService) {\n    this.flowHelper = flowHelper;\n    this.configurationProvider = configurationProvider;\n    this.flowsDataService = flowsDataService;\n    this.loggerService = loggerService;\n    this.silentRenewService = silentRenewService;\n    this.authStateService = authStateService;\n    this.authWellKnownService = authWellKnownService;\n    this.refreshSessionIframeService = refreshSessionIframeService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.refreshSessionRefreshTokenService = refreshSessionRefreshTokenService;\n    this.userService = userService;\n  }\n\n  userForceRefreshSession(configId, extraCustomParams) {\n    this.persistCustomParams(extraCustomParams, configId);\n    return this.forceRefreshSession(configId, extraCustomParams);\n  }\n\n  forceRefreshSession(configId, extraCustomParams) {\n    const {\n      customParamsRefreshTokenRequest\n    } = this.configurationProvider.getOpenIDConfiguration();\n    const mergedParams = Object.assign(Object.assign({}, customParamsRefreshTokenRequest), extraCustomParams);\n\n    if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(configId)) {\n      return this.startRefreshSession(configId, mergedParams).pipe(map(() => {\n        const isAuthenticated = this.authStateService.areAuthStorageTokensValid(configId);\n\n        if (isAuthenticated) {\n          return {\n            idToken: this.authStateService.getIdToken(configId),\n            accessToken: this.authStateService.getAccessToken(configId),\n            userData: this.userService.getUserDataFromStore(configId),\n            isAuthenticated,\n            configId\n          };\n        }\n\n        return null;\n      }));\n    }\n\n    const {\n      silentRenewTimeoutInSeconds\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    const timeOutTime = silentRenewTimeoutInSeconds * 1000;\n    return forkJoin([this.startRefreshSession(configId, extraCustomParams), this.silentRenewService.refreshSessionWithIFrameCompleted$.pipe(take(1))]).pipe(timeout(timeOutTime), retryWhen(this.timeoutRetryStrategy.bind(this)), map(([_, callbackContext]) => {\n      var _a, _b;\n\n      const isAuthenticated = this.authStateService.areAuthStorageTokensValid(configId);\n\n      if (isAuthenticated) {\n        return {\n          idToken: (_a = callbackContext === null || callbackContext === void 0 ? void 0 : callbackContext.authResult) === null || _a === void 0 ? void 0 : _a.id_token,\n          accessToken: (_b = callbackContext === null || callbackContext === void 0 ? void 0 : callbackContext.authResult) === null || _b === void 0 ? void 0 : _b.access_token,\n          userData: this.userService.getUserDataFromStore(configId),\n          isAuthenticated,\n          configId\n        };\n      }\n\n      return null;\n    }));\n  }\n\n  persistCustomParams(extraCustomParams, configId) {\n    const {\n      useRefreshToken\n    } = this.configurationProvider.getOpenIDConfiguration();\n\n    if (extraCustomParams) {\n      if (useRefreshToken) {\n        this.storagePersistenceService.write('storageCustomParamsRefresh', extraCustomParams, configId);\n      } else {\n        this.storagePersistenceService.write('storageCustomParamsAuthRequest', extraCustomParams, configId);\n      }\n    }\n  }\n\n  startRefreshSession(configId, extraCustomParams) {\n    const isSilentRenewRunning = this.flowsDataService.isSilentRenewRunning(configId);\n    this.loggerService.logDebug(configId, `Checking: silentRenewRunning: ${isSilentRenewRunning}`);\n    const shouldBeExecuted = !isSilentRenewRunning;\n\n    if (!shouldBeExecuted) {\n      return of(null);\n    }\n\n    const {\n      authWellknownEndpointUrl\n    } = this.configurationProvider.getOpenIDConfiguration(configId) || {};\n\n    if (!authWellknownEndpointUrl) {\n      this.loggerService.logError(configId, 'no authWellKnownEndpoint given!');\n      return of(null);\n    }\n\n    return this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).pipe(switchMap(() => {\n      this.flowsDataService.setSilentRenewRunning(configId);\n\n      if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(configId)) {\n        // Refresh Session using Refresh tokens\n        return this.refreshSessionRefreshTokenService.refreshSessionWithRefreshTokens(configId, extraCustomParams);\n      }\n\n      return this.refreshSessionIframeService.refreshSessionWithIframe(configId, extraCustomParams);\n    }));\n  }\n\n  timeoutRetryStrategy(errorAttempts, configId) {\n    return errorAttempts.pipe(mergeMap((error, index) => {\n      const scalingDuration = 1000;\n      const currentAttempt = index + 1;\n\n      if (!(error instanceof TimeoutError) || currentAttempt > MAX_RETRY_ATTEMPTS) {\n        return throwError(() => new Error(error));\n      }\n\n      this.loggerService.logDebug(configId, `forceRefreshSession timeout. Attempt #${currentAttempt}`);\n      this.flowsDataService.resetSilentRenewRunning(configId);\n      return timer(currentAttempt * scalingDuration);\n    }));\n  }\n\n}\n\nRefreshSessionService.ɵfac = function RefreshSessionService_Factory(t) {\n  return new (t || RefreshSessionService)(i0.ɵɵinject(FlowHelper), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(SilentRenewService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(AuthWellKnownService), i0.ɵɵinject(RefreshSessionIframeService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(RefreshSessionRefreshTokenService), i0.ɵɵinject(UserService));\n};\n\nRefreshSessionService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RefreshSessionService,\n  factory: RefreshSessionService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RefreshSessionService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: FlowHelper\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: FlowsDataService\n    }, {\n      type: LoggerService\n    }, {\n      type: SilentRenewService\n    }, {\n      type: AuthStateService\n    }, {\n      type: AuthWellKnownService\n    }, {\n      type: RefreshSessionIframeService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: RefreshSessionRefreshTokenService\n    }, {\n      type: UserService\n    }];\n  }, null);\n})();\n\nclass PeriodicallyTokenCheckService {\n  constructor(resetAuthDataService, flowHelper, configurationProvider, flowsDataService, loggerService, userService, authStateService, refreshSessionIframeService, refreshSessionRefreshTokenService, intervalService, storagePersistenceService, publicEventsService) {\n    this.resetAuthDataService = resetAuthDataService;\n    this.flowHelper = flowHelper;\n    this.configurationProvider = configurationProvider;\n    this.flowsDataService = flowsDataService;\n    this.loggerService = loggerService;\n    this.userService = userService;\n    this.authStateService = authStateService;\n    this.refreshSessionIframeService = refreshSessionIframeService;\n    this.refreshSessionRefreshTokenService = refreshSessionRefreshTokenService;\n    this.intervalService = intervalService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.publicEventsService = publicEventsService;\n  }\n\n  startTokenValidationPeriodically() {\n    const configsWithSilentRenewEnabled = this.getConfigsWithSilentRenewEnabled();\n\n    if (configsWithSilentRenewEnabled.length <= 0) {\n      return;\n    }\n\n    const refreshTimeInSeconds = this.getSmallestRefreshTimeFromConfigs(configsWithSilentRenewEnabled);\n\n    if (!!this.intervalService.runTokenValidationRunning) {\n      return;\n    } // START PERIODICALLY CHECK ONCE AND CHECK EACH CONFIG WHICH HAS IT ENABLED\n\n\n    const periodicallyCheck$ = this.intervalService.startPeriodicTokenCheck(refreshTimeInSeconds).pipe(switchMap(() => {\n      const objectWithConfigIdsAndRefreshEvent = {};\n      configsWithSilentRenewEnabled.forEach(({\n        configId\n      }) => {\n        objectWithConfigIdsAndRefreshEvent[configId] = this.getRefreshEvent(configId);\n      });\n      return forkJoin(objectWithConfigIdsAndRefreshEvent);\n    }));\n    this.intervalService.runTokenValidationRunning = periodicallyCheck$.subscribe(objectWithConfigIds => {\n      for (const [key, _] of Object.entries(objectWithConfigIds)) {\n        this.loggerService.logDebug(key, 'silent renew, periodic check finished!');\n\n        if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(key)) {\n          this.flowsDataService.resetSilentRenewRunning(key);\n        }\n      }\n    });\n  }\n\n  getRefreshEvent(configId) {\n    const shouldStartRefreshEvent = this.shouldStartPeriodicallyCheckForConfig(configId);\n\n    if (!shouldStartRefreshEvent) {\n      return of(null);\n    }\n\n    const refreshEvent$ = this.createRefreshEventForConfig(configId);\n    this.publicEventsService.fireEvent(EventTypes.SilentRenewStarted);\n    const refreshEventWithErrorHandler$ = refreshEvent$.pipe(catchError(error => {\n      this.loggerService.logError(configId, 'silent renew failed!', error);\n      this.flowsDataService.resetSilentRenewRunning(configId);\n      return throwError(() => new Error(error));\n    }));\n    return refreshEventWithErrorHandler$;\n  }\n\n  getSmallestRefreshTimeFromConfigs(configsWithSilentRenewEnabled) {\n    const result = configsWithSilentRenewEnabled.reduce((prev, curr) => prev.tokenRefreshInSeconds < curr.tokenRefreshInSeconds ? prev : curr);\n    return result.tokenRefreshInSeconds;\n  }\n\n  getConfigsWithSilentRenewEnabled() {\n    return this.configurationProvider.getAllConfigurations().filter(x => x.silentRenew);\n  }\n\n  createRefreshEventForConfig(configId) {\n    this.loggerService.logDebug(configId, 'starting silent renew...');\n    const config = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!(config === null || config === void 0 ? void 0 : config.silentRenew)) {\n      this.resetAuthDataService.resetAuthorizationData(configId);\n      return of(null);\n    }\n\n    this.flowsDataService.setSilentRenewRunning(configId);\n\n    if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(configId)) {\n      // Retrieve Dynamically Set Custom Params for refresh body\n      const customParamsRefresh = this.storagePersistenceService.read('storageCustomParamsRefresh', configId) || {};\n      const {\n        customParamsRefreshTokenRequest\n      } = this.configurationProvider.getOpenIDConfiguration(configId);\n      const mergedParams = Object.assign(Object.assign({}, customParamsRefreshTokenRequest), customParamsRefresh); // Refresh Session using Refresh tokens\n\n      return this.refreshSessionRefreshTokenService.refreshSessionWithRefreshTokens(configId, mergedParams);\n    } // Retrieve Dynamically Set Custom Params\n\n\n    const customParams = this.storagePersistenceService.read('storageCustomParamsAuthRequest', configId);\n    return this.refreshSessionIframeService.refreshSessionWithIframe(configId, customParams);\n  }\n\n  shouldStartPeriodicallyCheckForConfig(configId) {\n    const idToken = this.authStateService.getIdToken(configId);\n    const isSilentRenewRunning = this.flowsDataService.isSilentRenewRunning(configId);\n    const userDataFromStore = this.userService.getUserDataFromStore(configId);\n    this.loggerService.logDebug(configId, `Checking: silentRenewRunning: ${isSilentRenewRunning} - has idToken: ${!!idToken} - has userData: ${!!userDataFromStore}`);\n    const shouldBeExecuted = !!userDataFromStore && !isSilentRenewRunning && !!idToken;\n\n    if (!shouldBeExecuted) {\n      return false;\n    }\n\n    const idTokenStillValid = this.authStateService.hasIdTokenExpiredAndRenewCheckIsEnabled(configId);\n    const accessTokenHasExpired = this.authStateService.hasAccessTokenExpiredIfExpiryExists(configId);\n\n    if (!idTokenStillValid && !accessTokenHasExpired) {\n      return false;\n    }\n\n    return true;\n  }\n\n}\n\nPeriodicallyTokenCheckService.ɵfac = function PeriodicallyTokenCheckService_Factory(t) {\n  return new (t || PeriodicallyTokenCheckService)(i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(FlowHelper), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(UserService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(RefreshSessionIframeService), i0.ɵɵinject(RefreshSessionRefreshTokenService), i0.ɵɵinject(IntervalService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(PublicEventsService));\n};\n\nPeriodicallyTokenCheckService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PeriodicallyTokenCheckService,\n  factory: PeriodicallyTokenCheckService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PeriodicallyTokenCheckService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: ResetAuthDataService\n    }, {\n      type: FlowHelper\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: FlowsDataService\n    }, {\n      type: LoggerService\n    }, {\n      type: UserService\n    }, {\n      type: AuthStateService\n    }, {\n      type: RefreshSessionIframeService\n    }, {\n      type: RefreshSessionRefreshTokenService\n    }, {\n      type: IntervalService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: PublicEventsService\n    }];\n  }, null);\n})();\n\nclass PopUpService {\n  constructor() {\n    this.STORAGE_IDENTIFIER = 'popupauth';\n    this.resultInternal$ = new Subject();\n  }\n\n  get result$() {\n    return this.resultInternal$.asObservable();\n  }\n\n  isCurrentlyInPopup() {\n    if (this.canAccessSessionStorage()) {\n      const popup = sessionStorage.getItem(this.STORAGE_IDENTIFIER);\n      return !!window.opener && window.opener !== window && !!popup;\n    }\n\n    return false;\n  }\n\n  openPopUp(url, popupOptions) {\n    const optionsToPass = this.getOptions(popupOptions);\n    this.popUp = window.open(url, '_blank', optionsToPass);\n    this.popUp.sessionStorage.setItem(this.STORAGE_IDENTIFIER, 'true');\n\n    const listener = event => {\n      if (!(event === null || event === void 0 ? void 0 : event.data) || typeof event.data !== 'string') {\n        return;\n      }\n\n      this.resultInternal$.next({\n        userClosed: false,\n        receivedUrl: event.data\n      });\n      this.cleanUp(listener);\n    };\n\n    window.addEventListener('message', listener, false);\n    this.handle = window.setInterval(() => {\n      if (this.popUp.closed) {\n        this.resultInternal$.next({\n          userClosed: true\n        });\n        this.cleanUp(listener);\n      }\n    }, 200);\n  }\n\n  sendMessageToMainWindow(url) {\n    if (window.opener) {\n      this.sendMessage(url, window.location.href);\n    }\n  }\n\n  cleanUp(listener) {\n    var _a;\n\n    window.removeEventListener('message', listener, false);\n    window.clearInterval(this.handle);\n\n    if (this.popUp) {\n      (_a = this.popUp.sessionStorage) === null || _a === void 0 ? void 0 : _a.removeItem(this.STORAGE_IDENTIFIER);\n      this.popUp.close();\n      this.popUp = null;\n    }\n  }\n\n  sendMessage(url, href) {\n    window.opener.postMessage(url, href);\n  }\n\n  getOptions(popupOptions) {\n    const popupDefaultOptions = {\n      width: 500,\n      height: 500,\n      left: 50,\n      top: 50\n    };\n    const options = Object.assign(Object.assign({}, popupDefaultOptions), popupOptions || {});\n    const left = window.screenLeft + (window.outerWidth - options.width) / 2;\n    const top = window.screenTop + (window.outerHeight - options.height) / 2;\n    options.left = left;\n    options.top = top;\n    return Object.entries(options).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`).join(',');\n  }\n\n  canAccessSessionStorage() {\n    return typeof navigator !== 'undefined' && navigator.cookieEnabled && typeof Storage !== 'undefined';\n  }\n\n}\n\nPopUpService.ɵfac = function PopUpService_Factory(t) {\n  return new (t || PopUpService)();\n};\n\nPopUpService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PopUpService,\n  factory: PopUpService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PopUpService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n\nclass CheckAuthService {\n  constructor(checkSessionService, currentUrlService, silentRenewService, userService, loggerService, configurationProvider, authStateService, callbackService, refreshSessionService, periodicallyTokenCheckService, popupService, autoLoginService, storagePersistenceService) {\n    this.checkSessionService = checkSessionService;\n    this.currentUrlService = currentUrlService;\n    this.silentRenewService = silentRenewService;\n    this.userService = userService;\n    this.loggerService = loggerService;\n    this.configurationProvider = configurationProvider;\n    this.authStateService = authStateService;\n    this.callbackService = callbackService;\n    this.refreshSessionService = refreshSessionService;\n    this.periodicallyTokenCheckService = periodicallyTokenCheckService;\n    this.popupService = popupService;\n    this.autoLoginService = autoLoginService;\n    this.storagePersistenceService = storagePersistenceService;\n  }\n\n  checkAuth(passedConfigId, url) {\n    if (this.currentUrlService.currentUrlHasStateParam()) {\n      const stateParamFromUrl = this.currentUrlService.getStateParamFromCurrentUrl();\n      const config = this.getConfigurationWithUrlState(stateParamFromUrl);\n\n      if (!config) {\n        return throwError(() => new Error(`could not find matching config for state ${stateParamFromUrl}`));\n      }\n\n      return this.checkAuthWithConfig(config, url);\n    }\n\n    if (!!passedConfigId) {\n      const config = this.configurationProvider.getOpenIDConfiguration(passedConfigId);\n      return this.checkAuthWithConfig(config, url);\n    }\n\n    const onlyExistingConfig = this.configurationProvider.getOpenIDConfiguration();\n    return this.checkAuthWithConfig(onlyExistingConfig, url);\n  }\n\n  checkAuthMultiple(passedConfigId, url) {\n    if (this.currentUrlService.currentUrlHasStateParam()) {\n      const stateParamFromUrl = this.currentUrlService.getStateParamFromCurrentUrl();\n      const config = this.getConfigurationWithUrlState(stateParamFromUrl);\n\n      if (!config) {\n        return throwError(() => new Error(`could not find matching config for state ${stateParamFromUrl}`));\n      }\n\n      return this.composeMultipleLoginResults(config, url);\n    }\n\n    if (!!passedConfigId) {\n      const config = this.configurationProvider.getOpenIDConfiguration(passedConfigId);\n\n      if (!config) {\n        return throwError(() => new Error(`could not find matching config for id ${passedConfigId}`));\n      }\n\n      return this.composeMultipleLoginResults(config, url);\n    }\n\n    const allConfigs = this.configurationProvider.getAllConfigurations();\n    const allChecks$ = allConfigs.map(x => this.checkAuthWithConfig(x, url));\n    return forkJoin(allChecks$);\n  }\n\n  checkAuthIncludingServer(configId) {\n    const config = this.configurationProvider.getOpenIDConfiguration(configId);\n    return this.checkAuthWithConfig(config).pipe(switchMap(loginResponse => {\n      const {\n        isAuthenticated\n      } = loginResponse;\n\n      if (isAuthenticated) {\n        return of(loginResponse);\n      }\n\n      return this.refreshSessionService.forceRefreshSession(configId).pipe(tap(loginResponseAfterRefreshSession => {\n        if (loginResponseAfterRefreshSession === null || loginResponseAfterRefreshSession === void 0 ? void 0 : loginResponseAfterRefreshSession.isAuthenticated) {\n          this.startCheckSessionAndValidation(configId);\n        }\n      }));\n    }));\n  }\n\n  checkAuthWithConfig(config, url) {\n    const {\n      configId,\n      authority\n    } = config;\n\n    if (!this.configurationProvider.hasAtLeastOneConfig()) {\n      const errorMessage = 'Please provide at least one configuration before setting up the module';\n      this.loggerService.logError(configId, errorMessage);\n      return of({\n        isAuthenticated: false,\n        errorMessage,\n        userData: null,\n        idToken: null,\n        accessToken: null,\n        configId\n      });\n    }\n\n    const currentUrl = url || this.currentUrlService.getCurrentUrl();\n    this.loggerService.logDebug(configId, `Working with config '${configId}' using ${authority}`);\n\n    if (this.popupService.isCurrentlyInPopup()) {\n      this.popupService.sendMessageToMainWindow(currentUrl);\n      return of(null);\n    }\n\n    const isCallback = this.callbackService.isCallback(currentUrl);\n    this.loggerService.logDebug(configId, 'currentUrl to check auth with: ', currentUrl);\n    const callback$ = isCallback ? this.callbackService.handleCallbackAndFireEvents(currentUrl, configId) : of(null);\n    return callback$.pipe(map(() => {\n      const isAuthenticated = this.authStateService.areAuthStorageTokensValid(configId);\n\n      if (isAuthenticated) {\n        this.startCheckSessionAndValidation(configId);\n\n        if (!isCallback) {\n          this.authStateService.setAuthenticatedAndFireEvent();\n          this.userService.publishUserDataIfExists(configId);\n        }\n      }\n\n      this.loggerService.logDebug(configId, 'checkAuth completed - firing events now. isAuthenticated: ' + isAuthenticated);\n      return {\n        isAuthenticated,\n        userData: this.userService.getUserDataFromStore(configId),\n        accessToken: this.authStateService.getAccessToken(configId),\n        idToken: this.authStateService.getIdToken(configId),\n        configId\n      };\n    }), tap(({\n      isAuthenticated\n    }) => {\n      if (isAuthenticated) {\n        this.autoLoginService.checkSavedRedirectRouteAndNavigate(configId);\n      }\n    }), catchError(({\n      message\n    }) => {\n      this.loggerService.logError(configId, message);\n      return of({\n        isAuthenticated: false,\n        errorMessage: message,\n        userData: null,\n        idToken: null,\n        accessToken: null,\n        configId\n      });\n    }));\n  }\n\n  startCheckSessionAndValidation(configId) {\n    if (this.checkSessionService.isCheckSessionConfigured(configId)) {\n      this.checkSessionService.start(configId);\n    }\n\n    this.periodicallyTokenCheckService.startTokenValidationPeriodically();\n\n    if (this.silentRenewService.isSilentRenewConfigured(configId)) {\n      this.silentRenewService.getOrCreateIframe(configId);\n    }\n  }\n\n  getConfigurationWithUrlState(stateFromUrl) {\n    const allConfigs = this.configurationProvider.getAllConfigurations();\n\n    for (const config of allConfigs) {\n      const storedState = this.storagePersistenceService.read('authStateControl', config.configId);\n\n      if (storedState === stateFromUrl) {\n        return config;\n      }\n    }\n\n    return null;\n  }\n\n  composeMultipleLoginResults(activeConfig, url) {\n    const allOtherConfigs = this.configurationProvider.getAllConfigurations().filter(x => x.configId !== activeConfig.configId);\n    const currentConfigResult = this.checkAuthWithConfig(activeConfig, url);\n    const allOtherConfigResults = allOtherConfigs.map(config => {\n      const {\n        redirectUrl\n      } = config;\n      return this.checkAuthWithConfig(config, redirectUrl);\n    });\n    return forkJoin([currentConfigResult, ...allOtherConfigResults]);\n  }\n\n}\n\nCheckAuthService.ɵfac = function CheckAuthService_Factory(t) {\n  return new (t || CheckAuthService)(i0.ɵɵinject(CheckSessionService), i0.ɵɵinject(CurrentUrlService), i0.ɵɵinject(SilentRenewService), i0.ɵɵinject(UserService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(CallbackService), i0.ɵɵinject(RefreshSessionService), i0.ɵɵinject(PeriodicallyTokenCheckService), i0.ɵɵinject(PopUpService), i0.ɵɵinject(AutoLoginService), i0.ɵɵinject(StoragePersistenceService));\n};\n\nCheckAuthService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CheckAuthService,\n  factory: CheckAuthService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CheckAuthService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: CheckSessionService\n    }, {\n      type: CurrentUrlService\n    }, {\n      type: SilentRenewService\n    }, {\n      type: UserService\n    }, {\n      type: LoggerService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: AuthStateService\n    }, {\n      type: CallbackService\n    }, {\n      type: RefreshSessionService\n    }, {\n      type: PeriodicallyTokenCheckService\n    }, {\n      type: PopUpService\n    }, {\n      type: AutoLoginService\n    }, {\n      type: StoragePersistenceService\n    }];\n  }, null);\n})();\n\nconst DEFAULT_CONFIG = {\n  authority: 'https://please_set',\n  authWellknownEndpointUrl: '',\n  authWellknownEndpoints: null,\n  redirectUrl: 'https://please_set',\n  clientId: 'please_set',\n  responseType: 'code',\n  scope: 'openid email profile',\n  hdParam: '',\n  postLogoutRedirectUri: 'https://please_set',\n  startCheckSession: false,\n  silentRenew: false,\n  silentRenewUrl: 'https://please_set',\n  silentRenewTimeoutInSeconds: 20,\n  renewTimeBeforeTokenExpiresInSeconds: 0,\n  useRefreshToken: false,\n  usePushedAuthorisationRequests: false,\n  ignoreNonceAfterRefresh: false,\n  postLoginRoute: '/',\n  forbiddenRoute: '/forbidden',\n  unauthorizedRoute: '/unauthorized',\n  autoUserInfo: true,\n  autoCleanStateAfterAuthentication: true,\n  triggerAuthorizationResultEvent: false,\n  logLevel: LogLevel.Warn,\n  issValidationOff: false,\n  historyCleanupOff: false,\n  maxIdTokenIatOffsetAllowedInSeconds: 120,\n  disableIatOffsetValidation: false,\n  storage: null,\n  customParamsAuthRequest: {},\n  customParamsRefreshTokenRequest: {},\n  customParamsEndSessionRequest: {},\n  customParamsCodeRequest: {},\n  eagerLoadAuthWellKnownEndpoints: true,\n  disableRefreshIdTokenAuthTimeValidation: false,\n  enableIdTokenExpiredValidationInRenew: true,\n  tokenRefreshInSeconds: 4,\n  refreshTokenRetryInSeconds: 3,\n  ngswBypass: false\n};\nconst POSITIVE_VALIDATION_RESULT = {\n  result: true,\n  messages: [],\n  level: null\n};\n\nconst ensureAuthority = passedConfig => {\n  if (!passedConfig.authority) {\n    return {\n      result: false,\n      messages: ['The authority URL MUST be provided in the configuration! '],\n      level: 'error'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst ensureClientId = passedConfig => {\n  if (!passedConfig.clientId) {\n    return {\n      result: false,\n      messages: ['The clientId is required and missing from your config!'],\n      level: 'error'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst createIdentifierToCheck = passedConfig => {\n  if (!passedConfig) {\n    return null;\n  }\n\n  const {\n    authority,\n    clientId,\n    scope\n  } = passedConfig;\n  return `${authority}${clientId}${scope}`;\n};\n\nconst arrayHasDuplicates = array => new Set(array).size !== array.length;\n\nconst ensureNoDuplicatedConfigsRule = passedConfigs => {\n  const allIdentifiers = passedConfigs.map(x => createIdentifierToCheck(x));\n  const someAreNull = allIdentifiers.some(x => x === null);\n\n  if (someAreNull) {\n    return {\n      result: false,\n      messages: [`Please make sure you add an object with a 'config' property: ....({ config }) instead of ...(config)`],\n      level: 'error'\n    };\n  }\n\n  const hasDuplicates = arrayHasDuplicates(allIdentifiers);\n\n  if (hasDuplicates) {\n    return {\n      result: false,\n      messages: ['You added multiple configs with the same authority, clientId and scope'],\n      level: 'warning'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst ensureRedirectRule = passedConfig => {\n  if (!passedConfig.redirectUrl) {\n    return {\n      result: false,\n      messages: ['The redirectUrl is required and missing from your config'],\n      level: 'error'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst ensureSilentRenewUrlWhenNoRefreshTokenUsed = passedConfig => {\n  const usesSilentRenew = passedConfig.silentRenew;\n  const usesRefreshToken = passedConfig.useRefreshToken;\n  const hasSilentRenewUrl = passedConfig.silentRenewUrl;\n\n  if (usesSilentRenew && !usesRefreshToken && !hasSilentRenewUrl) {\n    return {\n      result: false,\n      messages: ['Please provide a silent renew URL if using renew and not refresh tokens'],\n      level: 'error'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst useOfflineScopeWithSilentRenew = passedConfig => {\n  const hasRefreshToken = passedConfig.useRefreshToken;\n  const hasSilentRenew = passedConfig.silentRenew;\n  const scope = passedConfig.scope || '';\n  const hasOfflineScope = scope.split(' ').includes('offline_access');\n\n  if (hasRefreshToken && hasSilentRenew && !hasOfflineScope) {\n    return {\n      result: false,\n      messages: ['When using silent renew and refresh tokens please set the `offline_access` scope'],\n      level: 'warning'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst allRules = [ensureAuthority, useOfflineScopeWithSilentRenew, ensureRedirectRule, ensureClientId, ensureSilentRenewUrlWhenNoRefreshTokenUsed];\nconst allMultipleConfigRules = [ensureNoDuplicatedConfigsRule];\n\nclass ConfigValidationService {\n  constructor(loggerService) {\n    this.loggerService = loggerService;\n  }\n\n  validateConfigs(passedConfigs) {\n    return this.validateConfigsInternal(passedConfigs, allMultipleConfigRules);\n  }\n\n  validateConfig(passedConfig) {\n    return this.validateConfigInternal(passedConfig, allRules);\n  }\n\n  validateConfigsInternal(passedConfigs, allRulesToUse) {\n    const allValidationResults = allRulesToUse.map(rule => rule(passedConfigs));\n    let overallErrorCount = 0;\n    passedConfigs.forEach(passedConfig => {\n      const errorCount = this.processValidationResultsAndGetErrorCount(allValidationResults, passedConfig === null || passedConfig === void 0 ? void 0 : passedConfig.configId);\n      overallErrorCount += errorCount;\n    });\n    return overallErrorCount === 0;\n  }\n\n  validateConfigInternal(passedConfig, allRulesToUse) {\n    const allValidationResults = allRulesToUse.map(rule => rule(passedConfig));\n    const errorCount = this.processValidationResultsAndGetErrorCount(allValidationResults, passedConfig.configId);\n    return errorCount === 0;\n  }\n\n  processValidationResultsAndGetErrorCount(allValidationResults, configId) {\n    const allMessages = allValidationResults.filter(x => x.messages.length > 0);\n    const allErrorMessages = this.getAllMessagesOfType('error', allMessages);\n    const allWarnings = this.getAllMessagesOfType('warning', allMessages);\n    allErrorMessages.forEach(message => this.loggerService.logError(configId, message));\n    allWarnings.forEach(message => this.loggerService.logWarning(configId, message));\n    return allErrorMessages.length;\n  }\n\n  getAllMessagesOfType(type, results) {\n    const allMessages = results.filter(x => x.level === type).map(result => result.messages);\n    return allMessages.reduce((acc, val) => acc.concat(val), []);\n  }\n\n}\n\nConfigValidationService.ɵfac = function ConfigValidationService_Factory(t) {\n  return new (t || ConfigValidationService)(i0.ɵɵinject(LoggerService));\n};\n\nConfigValidationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ConfigValidationService,\n  factory: ConfigValidationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ConfigValidationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }];\n  }, null);\n})();\n\nclass PlatformProvider {\n  constructor(platformId) {\n    this.platformId = platformId;\n  }\n\n  get isBrowser() {\n    return isPlatformBrowser(this.platformId);\n  }\n\n}\n\nPlatformProvider.ɵfac = function PlatformProvider_Factory(t) {\n  return new (t || PlatformProvider)(i0.ɵɵinject(PLATFORM_ID));\n};\n\nPlatformProvider.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PlatformProvider,\n  factory: PlatformProvider.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PlatformProvider, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\n\nclass DefaultSessionStorageService {\n  read(key) {\n    return sessionStorage.getItem(key);\n  }\n\n  write(key, value) {\n    sessionStorage.setItem(key, value);\n  }\n\n  remove(key) {\n    sessionStorage.removeItem(key);\n  }\n\n  clear() {\n    sessionStorage.clear();\n  }\n\n}\n\nDefaultSessionStorageService.ɵfac = function DefaultSessionStorageService_Factory(t) {\n  return new (t || DefaultSessionStorageService)();\n};\n\nDefaultSessionStorageService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DefaultSessionStorageService,\n  factory: DefaultSessionStorageService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DefaultSessionStorageService, [{\n    type: Injectable\n  }], null, null);\n})();\n\nclass OidcConfigService {\n  constructor(loggerService, publicEventsService, configurationProvider, authWellKnownService, storagePersistenceService, configValidationService, platformProvider, defaultSessionStorageService) {\n    this.loggerService = loggerService;\n    this.publicEventsService = publicEventsService;\n    this.configurationProvider = configurationProvider;\n    this.authWellKnownService = authWellKnownService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.configValidationService = configValidationService;\n    this.platformProvider = platformProvider;\n    this.defaultSessionStorageService = defaultSessionStorageService;\n  }\n\n  withConfigs(passedConfigs) {\n    if (!this.configValidationService.validateConfigs(passedConfigs)) {\n      return of(null);\n    }\n\n    this.createUniqueIds(passedConfigs);\n    const allHandleConfigs$ = passedConfigs.map(x => this.handleConfig(x));\n    return forkJoin(allHandleConfigs$);\n  }\n\n  createUniqueIds(passedConfigs) {\n    passedConfigs.forEach((config, index) => {\n      if (!config.configId) {\n        config.configId = `${index}-${config.clientId}`;\n      }\n    });\n  }\n\n  handleConfig(passedConfig) {\n    if (!this.configValidationService.validateConfig(passedConfig)) {\n      this.loggerService.logError(passedConfig.configId, 'Validation of config rejected with errors. Config is NOT set.');\n      return of(null);\n    }\n\n    if (!passedConfig.authWellknownEndpointUrl) {\n      passedConfig.authWellknownEndpointUrl = passedConfig.authority;\n    }\n\n    const usedConfig = this.prepareConfig(passedConfig);\n    this.configurationProvider.setConfig(usedConfig);\n    const alreadyExistingAuthWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', usedConfig.configId);\n\n    if (!!alreadyExistingAuthWellKnownEndpoints) {\n      usedConfig.authWellknownEndpoints = alreadyExistingAuthWellKnownEndpoints;\n      this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, usedConfig);\n      return of(usedConfig);\n    }\n\n    const passedAuthWellKnownEndpoints = usedConfig.authWellknownEndpoints;\n\n    if (!!passedAuthWellKnownEndpoints) {\n      this.authWellKnownService.storeWellKnownEndpoints(usedConfig.configId, passedAuthWellKnownEndpoints);\n      usedConfig.authWellknownEndpoints = passedAuthWellKnownEndpoints;\n      this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, usedConfig);\n      return of(usedConfig);\n    }\n\n    if (usedConfig.eagerLoadAuthWellKnownEndpoints) {\n      return this.authWellKnownService.getAuthWellKnownEndPoints(usedConfig.authWellknownEndpointUrl, usedConfig.configId).pipe(catchError(error => {\n        this.loggerService.logError(usedConfig.configId, 'Getting auth well known endpoints failed on start', error);\n        return throwError(() => new Error(error));\n      }), tap(wellknownEndPoints => {\n        usedConfig.authWellknownEndpoints = wellknownEndPoints;\n        this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, usedConfig);\n      }), switchMap(() => of(usedConfig)));\n    } else {\n      this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, usedConfig);\n      return of(usedConfig);\n    }\n  }\n\n  prepareConfig(configuration) {\n    const openIdConfigurationInternal = Object.assign(Object.assign({}, DEFAULT_CONFIG), configuration);\n    this.setSpecialCases(openIdConfigurationInternal);\n    this.setStorage(openIdConfigurationInternal);\n    return openIdConfigurationInternal;\n  }\n\n  setSpecialCases(currentConfig) {\n    if (!this.platformProvider.isBrowser) {\n      currentConfig.startCheckSession = false;\n      currentConfig.silentRenew = false;\n      currentConfig.useRefreshToken = false;\n      currentConfig.usePushedAuthorisationRequests = false;\n    }\n  }\n\n  setStorage(currentConfig) {\n    if (currentConfig.storage) {\n      return;\n    }\n\n    if (this.hasBrowserStorage()) {\n      currentConfig.storage = this.defaultSessionStorageService;\n    } else {\n      currentConfig.storage = null;\n    }\n  }\n\n  hasBrowserStorage() {\n    return typeof navigator !== 'undefined' && navigator.cookieEnabled && typeof Storage !== 'undefined';\n  }\n\n}\n\nOidcConfigService.ɵfac = function OidcConfigService_Factory(t) {\n  return new (t || OidcConfigService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(AuthWellKnownService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(ConfigValidationService), i0.ɵɵinject(PlatformProvider), i0.ɵɵinject(DefaultSessionStorageService));\n};\n\nOidcConfigService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: OidcConfigService,\n  factory: OidcConfigService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OidcConfigService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: PublicEventsService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: AuthWellKnownService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: ConfigValidationService\n    }, {\n      type: PlatformProvider\n    }, {\n      type: DefaultSessionStorageService\n    }];\n  }, null);\n})();\n\nclass OpenIdConfigLoader {}\n\nclass StsConfigLoader {}\n\nclass StsConfigStaticLoader {\n  constructor(passedConfigs) {\n    this.passedConfigs = passedConfigs;\n  }\n\n  loadConfigs() {\n    if (Array.isArray(this.passedConfigs)) {\n      return this.passedConfigs.map(x => of(x));\n    }\n\n    const singleStaticConfig$ = of(this.passedConfigs);\n    return [singleStaticConfig$];\n  }\n\n}\n\nclass StsConfigHttpLoader {\n  constructor(configs$) {\n    this.configs$ = configs$;\n  }\n\n  loadConfigs() {\n    return Array.isArray(this.configs$) ? this.configs$ : [this.configs$];\n  }\n\n}\n\nclass ClosestMatchingRouteService {\n  constructor(configProvider) {\n    this.configProvider = configProvider;\n  }\n\n  getConfigIdForClosestMatchingRoute(route) {\n    const allConfiguredRoutes = this.getAllConfiguredRoutes();\n\n    for (const routesWithConfig of allConfiguredRoutes) {\n      const allRoutesForConfig = routesWithConfig.routes;\n\n      for (const configuredRoute of allRoutesForConfig) {\n        if (route.startsWith(configuredRoute)) {\n          return {\n            matchingRoute: configuredRoute,\n            matchingConfigId: routesWithConfig.configId\n          };\n        }\n      }\n    }\n\n    return {\n      matchingRoute: null,\n      matchingConfigId: null\n    };\n  }\n\n  getAllConfiguredRoutes() {\n    const allConfigurations = this.configProvider.getAllConfigurations();\n    return allConfigurations.map(x => ({\n      routes: x.secureRoutes,\n      configId: x.configId\n    }));\n  }\n\n}\n\nClosestMatchingRouteService.ɵfac = function ClosestMatchingRouteService_Factory(t) {\n  return new (t || ClosestMatchingRouteService)(i0.ɵɵinject(ConfigurationProvider));\n};\n\nClosestMatchingRouteService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ClosestMatchingRouteService,\n  factory: ClosestMatchingRouteService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ClosestMatchingRouteService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ConfigurationProvider\n    }];\n  }, null);\n})();\n\nclass ResponseTypeValidationService {\n  constructor(loggerService, flowHelper) {\n    this.loggerService = loggerService;\n    this.flowHelper = flowHelper;\n  }\n\n  hasConfigValidResponseType(configId) {\n    if (this.flowHelper.isCurrentFlowAnyImplicitFlow(configId)) {\n      return true;\n    }\n\n    if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\n      return true;\n    }\n\n    this.loggerService.logWarning(configId, 'module configured incorrectly, invalid response_type. Check the responseType in the config');\n    return false;\n  }\n\n}\n\nResponseTypeValidationService.ɵfac = function ResponseTypeValidationService_Factory(t) {\n  return new (t || ResponseTypeValidationService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(FlowHelper));\n};\n\nResponseTypeValidationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ResponseTypeValidationService,\n  factory: ResponseTypeValidationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ResponseTypeValidationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: FlowHelper\n    }];\n  }, null);\n})();\n\nclass RedirectService {\n  constructor(doc) {\n    this.doc = doc;\n  }\n\n  redirectTo(url) {\n    this.doc.location.href = url;\n  }\n\n}\n\nRedirectService.ɵfac = function RedirectService_Factory(t) {\n  return new (t || RedirectService)(i0.ɵɵinject(DOCUMENT));\n};\n\nRedirectService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RedirectService,\n  factory: RedirectService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RedirectService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nclass ParService {\n  constructor(loggerService, urlService, dataService, storagePersistenceService) {\n    this.loggerService = loggerService;\n    this.urlService = urlService;\n    this.dataService = dataService;\n    this.storagePersistenceService = storagePersistenceService;\n  }\n\n  postParRequest(configId, customParams) {\n    let headers = new HttpHeaders();\n    headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n    const authWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n    if (!authWellKnownEndpoints) {\n      return throwError(() => new Error('Could not read PAR endpoint because authWellKnownEndPoints are not given'));\n    }\n\n    const parEndpoint = authWellKnownEndpoints.parEndpoint;\n\n    if (!parEndpoint) {\n      return throwError(() => new Error('Could not read PAR endpoint from authWellKnownEndpoints'));\n    }\n\n    return this.urlService.createBodyForParCodeFlowRequest(configId, customParams).pipe(switchMap(data => {\n      return this.dataService.post(parEndpoint, data, configId, headers).pipe(retry(2), map(response => {\n        this.loggerService.logDebug(configId, 'par response: ', response);\n        return {\n          expiresIn: response.expires_in,\n          requestUri: response.request_uri\n        };\n      }), catchError(error => {\n        const errorMessage = `There was an error on ParService postParRequest`;\n        this.loggerService.logError(configId, errorMessage, error);\n        return throwError(() => new Error(errorMessage));\n      }));\n    }));\n  }\n\n}\n\nParService.ɵfac = function ParService_Factory(t) {\n  return new (t || ParService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(UrlService), i0.ɵɵinject(DataService), i0.ɵɵinject(StoragePersistenceService));\n};\n\nParService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ParService,\n  factory: ParService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ParService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: UrlService\n    }, {\n      type: DataService\n    }, {\n      type: StoragePersistenceService\n    }];\n  }, null);\n})();\n\nclass ParLoginService {\n  constructor(loggerService, responseTypeValidationService, urlService, redirectService, configurationProvider, authWellKnownService, popupService, checkAuthService, parService) {\n    this.loggerService = loggerService;\n    this.responseTypeValidationService = responseTypeValidationService;\n    this.urlService = urlService;\n    this.redirectService = redirectService;\n    this.configurationProvider = configurationProvider;\n    this.authWellKnownService = authWellKnownService;\n    this.popupService = popupService;\n    this.checkAuthService = checkAuthService;\n    this.parService = parService;\n  }\n\n  loginPar(configId, authOptions) {\n    if (!this.responseTypeValidationService.hasConfigValidResponseType(configId)) {\n      this.loggerService.logError(configId, 'Invalid response type!');\n      return;\n    }\n\n    const {\n      authWellknownEndpointUrl\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!authWellknownEndpointUrl) {\n      this.loggerService.logError(configId, 'no authWellknownEndpoint given!');\n      return;\n    }\n\n    this.loggerService.logDebug(configId, 'BEGIN Authorize OIDC Flow, no auth data');\n    const {\n      urlHandler,\n      customParams\n    } = authOptions || {};\n    this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).pipe(switchMap(() => this.parService.postParRequest(configId, customParams))).subscribe(response => {\n      this.loggerService.logDebug(configId, 'par response: ', response);\n      const url = this.urlService.getAuthorizeParUrl(response.requestUri, configId);\n      this.loggerService.logDebug(configId, 'par request url: ', url);\n\n      if (!url) {\n        this.loggerService.logError(configId, `Could not create URL with param ${response.requestUri}: '${url}'`);\n        return;\n      }\n\n      if (urlHandler) {\n        urlHandler(url);\n      } else {\n        this.redirectService.redirectTo(url);\n      }\n    });\n  }\n\n  loginWithPopUpPar(configId, authOptions, popupOptions) {\n    if (!this.responseTypeValidationService.hasConfigValidResponseType(configId)) {\n      const errorMessage = 'Invalid response type!';\n      this.loggerService.logError(configId, errorMessage);\n      return throwError(() => new Error(errorMessage));\n    }\n\n    const {\n      authWellknownEndpointUrl\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!authWellknownEndpointUrl) {\n      const errorMessage = 'no authWellknownEndpoint given!';\n      this.loggerService.logError(configId, errorMessage);\n      return throwError(() => new Error(errorMessage));\n    }\n\n    this.loggerService.logDebug(configId, 'BEGIN Authorize OIDC Flow with popup, no auth data');\n    const {\n      customParams\n    } = authOptions || {};\n    return this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).pipe(switchMap(() => this.parService.postParRequest(configId, customParams)), switchMap(response => {\n      this.loggerService.logDebug(configId, 'par response: ', response);\n      const url = this.urlService.getAuthorizeParUrl(response.requestUri, configId);\n      this.loggerService.logDebug(configId, 'par request url: ', url);\n\n      if (!url) {\n        const errorMessage = `Could not create URL with param ${response.requestUri}: 'url'`;\n        this.loggerService.logError(configId, errorMessage);\n        return throwError(() => new Error(errorMessage));\n      }\n\n      this.popupService.openPopUp(url, popupOptions);\n      return this.popupService.result$.pipe(take(1), switchMap(result => {\n        const {\n          userClosed,\n          receivedUrl\n        } = result;\n\n        if (userClosed) {\n          return of({\n            isAuthenticated: false,\n            errorMessage: 'User closed popup',\n            userData: null,\n            idToken: null,\n            accessToken: null,\n            configId\n          });\n        }\n\n        return this.checkAuthService.checkAuth(configId, receivedUrl);\n      }));\n    }));\n  }\n\n}\n\nParLoginService.ɵfac = function ParLoginService_Factory(t) {\n  return new (t || ParLoginService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ResponseTypeValidationService), i0.ɵɵinject(UrlService), i0.ɵɵinject(RedirectService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(AuthWellKnownService), i0.ɵɵinject(PopUpService), i0.ɵɵinject(CheckAuthService), i0.ɵɵinject(ParService));\n};\n\nParLoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ParLoginService,\n  factory: ParLoginService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ParLoginService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: ResponseTypeValidationService\n    }, {\n      type: UrlService\n    }, {\n      type: RedirectService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: AuthWellKnownService\n    }, {\n      type: PopUpService\n    }, {\n      type: CheckAuthService\n    }, {\n      type: ParService\n    }];\n  }, null);\n})();\n\nclass PopUpLoginService {\n  constructor(loggerService, responseTypeValidationService, urlService, configurationProvider, authWellKnownService, popupService, checkAuthService) {\n    this.loggerService = loggerService;\n    this.responseTypeValidationService = responseTypeValidationService;\n    this.urlService = urlService;\n    this.configurationProvider = configurationProvider;\n    this.authWellKnownService = authWellKnownService;\n    this.popupService = popupService;\n    this.checkAuthService = checkAuthService;\n  }\n\n  loginWithPopUpStandard(configId, authOptions, popupOptions) {\n    if (!this.responseTypeValidationService.hasConfigValidResponseType(configId)) {\n      const errorMessage = 'Invalid response type!';\n      this.loggerService.logError(configId, errorMessage);\n      return throwError(() => new Error(errorMessage));\n    }\n\n    const {\n      authWellknownEndpointUrl\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!authWellknownEndpointUrl) {\n      const errorMessage = 'no authWellknownEndpoint given!';\n      this.loggerService.logError(configId, errorMessage);\n      return throwError(() => new Error(errorMessage));\n    }\n\n    this.loggerService.logDebug(configId, 'BEGIN Authorize OIDC Flow with popup, no auth data');\n    return this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).pipe(switchMap(() => {\n      const {\n        customParams\n      } = authOptions || {};\n      return this.urlService.getAuthorizeUrl(configId, customParams);\n    }), tap(authUrl => this.popupService.openPopUp(authUrl, popupOptions)), switchMap(() => {\n      return this.popupService.result$.pipe(take(1), switchMap(result => {\n        const {\n          userClosed,\n          receivedUrl\n        } = result;\n\n        if (userClosed) {\n          return of({\n            isAuthenticated: false,\n            errorMessage: 'User closed popup',\n            userData: null,\n            idToken: null,\n            accessToken: null,\n            configId\n          });\n        }\n\n        return this.checkAuthService.checkAuth(configId, receivedUrl);\n      }));\n    }));\n  }\n\n}\n\nPopUpLoginService.ɵfac = function PopUpLoginService_Factory(t) {\n  return new (t || PopUpLoginService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ResponseTypeValidationService), i0.ɵɵinject(UrlService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(AuthWellKnownService), i0.ɵɵinject(PopUpService), i0.ɵɵinject(CheckAuthService));\n};\n\nPopUpLoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PopUpLoginService,\n  factory: PopUpLoginService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PopUpLoginService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: ResponseTypeValidationService\n    }, {\n      type: UrlService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: AuthWellKnownService\n    }, {\n      type: PopUpService\n    }, {\n      type: CheckAuthService\n    }];\n  }, null);\n})();\n\nclass StandardLoginService {\n  constructor(loggerService, responseTypeValidationService, urlService, redirectService, configurationProvider, authWellKnownService) {\n    this.loggerService = loggerService;\n    this.responseTypeValidationService = responseTypeValidationService;\n    this.urlService = urlService;\n    this.redirectService = redirectService;\n    this.configurationProvider = configurationProvider;\n    this.authWellKnownService = authWellKnownService;\n  }\n\n  loginStandard(configId, authOptions) {\n    if (!this.responseTypeValidationService.hasConfigValidResponseType(configId)) {\n      this.loggerService.logError(configId, 'Invalid response type!');\n      return;\n    }\n\n    const {\n      authWellknownEndpointUrl\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!authWellknownEndpointUrl) {\n      this.loggerService.logError(configId, 'no authWellknownEndpoint given!');\n      return;\n    }\n\n    this.loggerService.logDebug(configId, 'BEGIN Authorize OIDC Flow, no auth data');\n    this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).subscribe(() => {\n      const {\n        urlHandler,\n        customParams\n      } = authOptions || {};\n      this.urlService.getAuthorizeUrl(configId, customParams).subscribe(url => {\n        if (!url) {\n          this.loggerService.logError(configId, 'Could not create URL', url);\n          return;\n        }\n\n        if (urlHandler) {\n          urlHandler(url);\n        } else {\n          this.redirectService.redirectTo(url);\n        }\n      });\n    });\n  }\n\n}\n\nStandardLoginService.ɵfac = function StandardLoginService_Factory(t) {\n  return new (t || StandardLoginService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ResponseTypeValidationService), i0.ɵɵinject(UrlService), i0.ɵɵinject(RedirectService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(AuthWellKnownService));\n};\n\nStandardLoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StandardLoginService,\n  factory: StandardLoginService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StandardLoginService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: ResponseTypeValidationService\n    }, {\n      type: UrlService\n    }, {\n      type: RedirectService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: AuthWellKnownService\n    }];\n  }, null);\n})();\n\nclass LoginService {\n  constructor(configurationProvider, parLoginService, popUpLoginService, standardLoginService, storagePersistenceService) {\n    this.configurationProvider = configurationProvider;\n    this.parLoginService = parLoginService;\n    this.popUpLoginService = popUpLoginService;\n    this.standardLoginService = standardLoginService;\n    this.storagePersistenceService = storagePersistenceService;\n  }\n\n  login(configId, authOptions) {\n    if (authOptions === null || authOptions === void 0 ? void 0 : authOptions.customParams) {\n      this.storagePersistenceService.write('storageCustomParamsAuthRequest', authOptions.customParams, configId);\n    }\n\n    const {\n      usePushedAuthorisationRequests\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (usePushedAuthorisationRequests) {\n      return this.parLoginService.loginPar(configId, authOptions);\n    } else {\n      return this.standardLoginService.loginStandard(configId, authOptions);\n    }\n  }\n\n  loginWithPopUp(configId, authOptions, popupOptions) {\n    if (authOptions === null || authOptions === void 0 ? void 0 : authOptions.customParams) {\n      this.storagePersistenceService.write('storageCustomParamsAuthRequest', authOptions.customParams, configId);\n    }\n\n    const {\n      usePushedAuthorisationRequests\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (usePushedAuthorisationRequests) {\n      return this.parLoginService.loginWithPopUpPar(configId, authOptions, popupOptions);\n    } else {\n      return this.popUpLoginService.loginWithPopUpStandard(configId, authOptions, popupOptions);\n    }\n  }\n\n}\n\nLoginService.ɵfac = function LoginService_Factory(t) {\n  return new (t || LoginService)(i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(ParLoginService), i0.ɵɵinject(PopUpLoginService), i0.ɵɵinject(StandardLoginService), i0.ɵɵinject(StoragePersistenceService));\n};\n\nLoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: LoginService,\n  factory: LoginService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LoginService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ConfigurationProvider\n    }, {\n      type: ParLoginService\n    }, {\n      type: PopUpLoginService\n    }, {\n      type: StandardLoginService\n    }, {\n      type: StoragePersistenceService\n    }];\n  }, null);\n})();\n\nclass LogoffRevocationService {\n  constructor(dataService, storagePersistenceService, loggerService, urlService, checkSessionService, resetAuthDataService, redirectService, configurationProvider) {\n    this.dataService = dataService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.loggerService = loggerService;\n    this.urlService = urlService;\n    this.checkSessionService = checkSessionService;\n    this.resetAuthDataService = resetAuthDataService;\n    this.redirectService = redirectService;\n    this.configurationProvider = configurationProvider;\n  } // Logs out on the server and the local client.\n  // If the server state has changed, check session, then only a local logout.\n\n\n  logoff(configId, authOptions) {\n    const {\n      urlHandler,\n      customParams\n    } = authOptions || {};\n    this.loggerService.logDebug(configId, 'logoff, remove auth ');\n    const endSessionUrl = this.getEndSessionUrl(configId, customParams);\n    this.resetAuthDataService.resetAuthorizationData(configId);\n\n    if (!endSessionUrl) {\n      this.loggerService.logDebug(configId, 'only local login cleaned up, no end_session_endpoint');\n      return;\n    }\n\n    if (this.checkSessionService.serverStateChanged(configId)) {\n      this.loggerService.logDebug(configId, 'only local login cleaned up, server session has changed');\n    } else if (urlHandler) {\n      urlHandler(endSessionUrl);\n    } else {\n      this.redirectService.redirectTo(endSessionUrl);\n    }\n  }\n\n  logoffLocal(configId) {\n    this.resetAuthDataService.resetAuthorizationData(configId);\n    this.checkSessionService.stop();\n  }\n\n  logoffLocalMultiple() {\n    const allConfigs = this.configurationProvider.getAllConfigurations();\n    allConfigs.forEach(({\n      configId\n    }) => this.logoffLocal(configId));\n  } // The refresh token and and the access token are revoked on the server. If the refresh token does not exist\n  // only the access token is revoked. Then the logout run.\n\n\n  logoffAndRevokeTokens(configId, authOptions) {\n    const {\n      revocationEndpoint\n    } = this.storagePersistenceService.read('authWellKnownEndPoints', configId) || {};\n\n    if (!revocationEndpoint) {\n      this.loggerService.logDebug(configId, 'revocation endpoint not supported');\n      this.logoff(configId, authOptions);\n    }\n\n    if (this.storagePersistenceService.getRefreshToken(configId)) {\n      return this.revokeRefreshToken(configId).pipe(switchMap(result => this.revokeAccessToken(configId, result)), catchError(error => {\n        const errorMessage = `revoke token failed`;\n        this.loggerService.logError(configId, errorMessage, error);\n        return throwError(() => new Error(errorMessage));\n      }), tap(() => this.logoff(configId, authOptions)));\n    } else {\n      return this.revokeAccessToken(configId).pipe(catchError(error => {\n        const errorMessage = `revoke accessToken failed`;\n        this.loggerService.logError(configId, errorMessage, error);\n        return throwError(() => new Error(errorMessage));\n      }), tap(() => this.logoff(configId, authOptions)));\n    }\n  } // https://tools.ietf.org/html/rfc7009\n  // revokes an access token on the STS. If no token is provided, then the token from\n  // the storage is revoked. You can pass any token to revoke. This makes it possible to\n  // manage your own tokens. The is a public API.\n\n\n  revokeAccessToken(configId, accessToken) {\n    const accessTok = accessToken || this.storagePersistenceService.getAccessToken(configId);\n    const body = this.urlService.createRevocationEndpointBodyAccessToken(accessTok, configId);\n    return this.sendRevokeRequest(configId, body);\n  } // https://tools.ietf.org/html/rfc7009\n  // revokes an refresh token on the STS. This is only required in the code flow with refresh tokens.\n  // If no token is provided, then the token from the storage is revoked. You can pass any token to revoke.\n  // This makes it possible to manage your own tokens.\n\n\n  revokeRefreshToken(configId, refreshToken) {\n    const refreshTok = refreshToken || this.storagePersistenceService.getRefreshToken(configId);\n    const body = this.urlService.createRevocationEndpointBodyRefreshToken(refreshTok, configId);\n    return this.sendRevokeRequest(configId, body);\n  }\n\n  getEndSessionUrl(configId, customParams) {\n    const idToken = this.storagePersistenceService.getIdToken(configId);\n    const {\n      customParamsEndSessionRequest\n    } = this.configurationProvider.getOpenIDConfiguration();\n    const mergedParams = Object.assign(Object.assign({}, customParamsEndSessionRequest), customParams);\n    return this.urlService.createEndSessionUrl(idToken, configId, mergedParams);\n  }\n\n  sendRevokeRequest(configId, body) {\n    const url = this.urlService.getRevocationEndpointUrl(configId);\n    let headers = new HttpHeaders();\n    headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n    return this.dataService.post(url, body, configId, headers).pipe(retry(2), switchMap(response => {\n      this.loggerService.logDebug(configId, 'revocation endpoint post response: ', response);\n      return of(response);\n    }), catchError(error => {\n      const errorMessage = `Revocation request failed`;\n      this.loggerService.logError(configId, errorMessage, error);\n      return throwError(() => new Error(errorMessage));\n    }));\n  }\n\n}\n\nLogoffRevocationService.ɵfac = function LogoffRevocationService_Factory(t) {\n  return new (t || LogoffRevocationService)(i0.ɵɵinject(DataService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(UrlService), i0.ɵɵinject(CheckSessionService), i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(RedirectService), i0.ɵɵinject(ConfigurationProvider));\n};\n\nLogoffRevocationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: LogoffRevocationService,\n  factory: LogoffRevocationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LogoffRevocationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: DataService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: LoggerService\n    }, {\n      type: UrlService\n    }, {\n      type: CheckSessionService\n    }, {\n      type: ResetAuthDataService\n    }, {\n      type: RedirectService\n    }, {\n      type: ConfigurationProvider\n    }];\n  }, null);\n})();\n\nclass OidcSecurityService {\n  constructor(checkSessionService, checkAuthService, userService, tokenHelperService, configurationProvider, authStateService, flowsDataService, callbackService, logoffRevocationService, loginService, refreshSessionService, urlService) {\n    this.checkSessionService = checkSessionService;\n    this.checkAuthService = checkAuthService;\n    this.userService = userService;\n    this.tokenHelperService = tokenHelperService;\n    this.configurationProvider = configurationProvider;\n    this.authStateService = authStateService;\n    this.flowsDataService = flowsDataService;\n    this.callbackService = callbackService;\n    this.logoffRevocationService = logoffRevocationService;\n    this.loginService = loginService;\n    this.refreshSessionService = refreshSessionService;\n    this.urlService = urlService;\n  }\n  /**\r\n   * Provides information about the user after they have logged in.\r\n   *\r\n   * @returns Returns an object containing either the user data directly (single config) or\r\n   * the user data per config in case you are running with multiple configs\r\n   */\n\n\n  get userData$() {\n    return this.userService.userData$;\n  }\n  /**\r\n   * Emits each time an authorization event occurs.\r\n   *\r\n   * @returns Returns an object containing if you are authenticated or not.\r\n   * Single Config: true if config is authenticated, false if not.\r\n   * Multiple Configs: true is all configs are authenticated, false if only one of them is not\r\n   *\r\n   * The `allConfigsAuthenticated` property contains the auth information _per config_.\r\n   */\n\n\n  get isAuthenticated$() {\n    return this.authStateService.authenticated$;\n  }\n  /**\r\n   * Emits each time the server sends a CheckSession event and the value changed. This property will always return\r\n   * true.\r\n   */\n\n\n  get checkSessionChanged$() {\n    return this.checkSessionService.checkSessionChanged$;\n  }\n  /**\r\n   * Emits on a Security Token Service callback. The observable will never contain a value.\r\n   */\n\n\n  get stsCallback$() {\n    return this.callbackService.stsCallback$;\n  }\n  /**\r\n   * Returns the currently active OpenID configurations.\r\n   *\r\n   * @returns an array of OpenIdConfigurations.\r\n   */\n\n\n  getConfigurations() {\n    return this.configurationProvider.getAllConfigurations();\n  }\n  /**\r\n   * Returns a single active OpenIdConfiguration.\r\n   *\r\n   * @param configId The configId to identify the config. If not passed, the first one is being returned\r\n   */\n\n\n  getConfiguration(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration().configId;\n    return this.configurationProvider.getOpenIDConfiguration(configId);\n  }\n  /**\r\n   * Returns the userData for a configuration\r\n   *\r\n   * @param configId The configId to identify the config. If not passed, the first one is being used\r\n   */\n\n\n  getUserData(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration().configId;\n    return this.userService.getUserDataFromStore(configId);\n  }\n  /**\r\n   * Starts the complete setup flow for one configuration. Calling will start the entire authentication flow, and the returned observable\r\n   * will denote whether the user was successfully authenticated including the user data, the access token, the configId and\r\n   * an error message in case an error happened\r\n   *\r\n   * @param url The URL to perform the authorization on the behalf of.\r\n   * @param configId The configId to perform the authorization on the behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns An object `LoginResponse` containing all information about the login\r\n   */\n\n\n  checkAuth(url, configId) {\n    return this.checkAuthService.checkAuth(configId, url);\n  }\n  /**\r\n   * Starts the complete setup flow for multiple configurations.\r\n   * Calling will start the entire authentication flow, and the returned observable\r\n   * will denote whether the user was successfully authenticated including the user data, the access token, the configId and\r\n   * an error message in case an error happened in an array for each config which was provided\r\n   *\r\n   * @param url The URL to perform the authorization on the behalf of.\r\n   * @param configId The configId to perform the authorization on the behalf of. If not passed, all of the current\r\n   * configured ones will be used to check.\r\n   *\r\n   * @returns An array of `LoginResponse` objects containing all information about the logins\r\n   */\n\n\n  checkAuthMultiple(url, configId) {\n    return this.checkAuthService.checkAuthMultiple(configId, url);\n  }\n  /**\r\n   * Provides information about the current authenticated state\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A boolean whether the config is authenticated or not.\r\n   */\n\n\n  isAuthenticated(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.authStateService.isAuthenticated(configId);\n  }\n  /**\r\n   * Checks the server for an authenticated session using the iframe silent renew if not locally authenticated.\r\n   */\n\n\n  checkAuthIncludingServer(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.checkAuthService.checkAuthIncludingServer(configId);\n  }\n  /**\r\n   * Returns the access token for the login scenario.\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A string with the access token.\r\n   */\n\n\n  getAccessToken(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.authStateService.getAccessToken(configId);\n  }\n  /**\r\n   * Returns the ID token for the sign-in.\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A string with the id token.\r\n   */\n\n\n  getIdToken(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.authStateService.getIdToken(configId);\n  }\n  /**\r\n   * Returns the refresh token, if present, for the sign-in.\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A string with the refresh token.\r\n   */\n\n\n  getRefreshToken(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.authStateService.getRefreshToken(configId);\n  }\n  /**\r\n   * Returns the authentication result, if present, for the sign-in.\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A object with the authentication result\r\n   */\n\n\n  getAuthenticationResult(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.authStateService.getAuthenticationResult(configId);\n  }\n  /**\r\n   * Returns the payload from the ID token.\r\n   *\r\n   * @param encode Set to true if the payload is base64 encoded\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns The payload from the id token.\r\n   */\n\n\n  getPayloadFromIdToken(encode = false, configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    const token = this.authStateService.getIdToken(configId);\n    return this.tokenHelperService.getPayloadFromToken(token, encode, configId);\n  }\n  /**\r\n   * Sets a custom state for the authorize request.\r\n   *\r\n   * @param state The state to set.\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   */\n\n\n  setState(state, configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    this.flowsDataService.setAuthStateControl(state, configId);\n  }\n  /**\r\n   * Gets the state value used for the authorize request.\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns The state value used for the authorize request.\r\n   */\n\n\n  getState(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.flowsDataService.getAuthStateControl(configId);\n  }\n  /**\r\n   * Redirects the user to the Security Token Service to begin the authentication process.\r\n   *\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   * @param authOptions The custom options for the the authentication request.\r\n   */\n\n\n  authorize(configId, authOptions) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    this.loginService.login(configId, authOptions);\n  }\n  /**\r\n   * Opens the Security Token Service in a new window to begin the authentication process.\r\n   *\r\n   * @param authOptions The custom options for the authentication request.\r\n   * @param popupOptions The configuration for the popup window.\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns An `Observable<LoginResponse>` containing all information about the login\r\n   */\n\n\n  authorizeWithPopUp(authOptions, popupOptions, configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.loginService.loginWithPopUp(configId, authOptions, popupOptions);\n  }\n  /**\r\n   * Manually refreshes the session.\r\n   *\r\n   * @param customParams Custom parameters to pass to the refresh request.\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns An `Observable<LoginResponse>` containing all information about the login\r\n   */\n\n\n  forceRefreshSession(customParams, configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.refreshSessionService.userForceRefreshSession(configId, customParams);\n  }\n  /**\r\n   * Revokes the refresh token (if present) and the access token on the server and then performs the logoff operation.\r\n   * The refresh token and and the access token are revoked on the server. If the refresh token does not exist\r\n   * only the access token is revoked. Then the logout run.\r\n   *\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   * @param authOptions The custom options for the request.\r\n   *\r\n   * @returns An observable when the action is finished\r\n   */\n\n\n  logoffAndRevokeTokens(configId, authOptions) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.logoffRevocationService.logoffAndRevokeTokens(configId, authOptions);\n  }\n  /**\r\n   * Logs out on the server and the local client. If the server state has changed, confirmed via check session,\r\n   * then only a local logout is performed.\r\n   *\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   * @param authOptions with custom parameters and/or an custom url handler\r\n   */\n\n\n  logoff(configId, authOptions) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.logoffRevocationService.logoff(configId, authOptions);\n  }\n  /**\r\n   * Logs the user out of the application without logging them out of the server.\r\n   * Use this method if you have _one_ config enabled.\r\n   *\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   */\n\n\n  logoffLocal(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.logoffRevocationService.logoffLocal(configId);\n  }\n  /**\r\n   * Logs the user out of the application for all configs without logging them out of the server.\r\n   * Use this method if you have _multiple_ configs enabled.\r\n   */\n\n\n  logoffLocalMultiple() {\n    return this.logoffRevocationService.logoffLocalMultiple();\n  }\n  /**\r\n   * Revokes an access token on the Security Token Service. This is only required in the code flow with refresh tokens. If no token is\r\n   * provided, then the token from the storage is revoked. You can pass any token to revoke.\r\n   * https://tools.ietf.org/html/rfc7009\r\n   *\r\n   * @param accessToken The access token to revoke.\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns An observable when the action is finished\r\n   */\n\n\n  revokeAccessToken(accessToken, configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.logoffRevocationService.revokeAccessToken(configId, accessToken);\n  }\n  /**\r\n   * Revokes a refresh token on the Security Token Service. This is only required in the code flow with refresh tokens. If no token is\r\n   * provided, then the token from the storage is revoked. You can pass any token to revoke.\r\n   * https://tools.ietf.org/html/rfc7009\r\n   *\r\n   * @param refreshToken The access token to revoke.\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns An observable when the action is finished\r\n   */\n\n\n  revokeRefreshToken(refreshToken, configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.logoffRevocationService.revokeRefreshToken(configId, refreshToken);\n  }\n  /**\r\n   * Creates the end session URL which can be used to implement an alternate server logout.\r\n   *\r\n   * @param customParams\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A string with the end session url or null\r\n   */\n\n\n  getEndSessionUrl(customParams, configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.logoffRevocationService.getEndSessionUrl(configId, customParams);\n  }\n  /**\r\n   * Creates the authorize URL based on your flow\r\n   *\r\n   * @param customParams\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A string with the authorize URL or null\r\n   */\n\n\n  getAuthorizeUrl(customParams, configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.urlService.getAuthorizeUrl(configId, customParams);\n  }\n\n}\n\nOidcSecurityService.ɵfac = function OidcSecurityService_Factory(t) {\n  return new (t || OidcSecurityService)(i0.ɵɵinject(CheckSessionService), i0.ɵɵinject(CheckAuthService), i0.ɵɵinject(UserService), i0.ɵɵinject(TokenHelperService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(CallbackService), i0.ɵɵinject(LogoffRevocationService), i0.ɵɵinject(LoginService), i0.ɵɵinject(RefreshSessionService), i0.ɵɵinject(UrlService));\n};\n\nOidcSecurityService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: OidcSecurityService,\n  factory: OidcSecurityService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OidcSecurityService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: CheckSessionService\n    }, {\n      type: CheckAuthService\n    }, {\n      type: UserService\n    }, {\n      type: TokenHelperService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: AuthStateService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: CallbackService\n    }, {\n      type: LogoffRevocationService\n    }, {\n      type: LoginService\n    }, {\n      type: RefreshSessionService\n    }, {\n      type: UrlService\n    }];\n  }, null);\n})(); // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n\n\nfunction createStaticLoader(passedConfig) {\n  return new StsConfigStaticLoader(passedConfig.config);\n} // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n\n\nfunction configurationProviderFactory(oidcConfigService, loader) {\n  const allConfigs$ = forkJoin(loader.loadConfigs());\n\n  const fn = () => allConfigs$.pipe(switchMap(configs => oidcConfigService.withConfigs(configs)));\n\n  return fn;\n}\n\nconst PASSED_CONFIG = new InjectionToken('PASSED_CONFIG');\n\nclass AuthModule {\n  static forRoot(passedConfig) {\n    return {\n      ngModule: AuthModule,\n      providers: [// Make the PASSED_CONFIG available through injection\n      {\n        provide: PASSED_CONFIG,\n        useValue: passedConfig\n      }, // Create the loader: Either the one getting passed or a static one\n      (passedConfig === null || passedConfig === void 0 ? void 0 : passedConfig.loader) || {\n        provide: StsConfigLoader,\n        useFactory: createStaticLoader,\n        deps: [PASSED_CONFIG]\n      }, // Load the config when the app starts\n      {\n        provide: APP_INITIALIZER,\n        multi: true,\n        deps: [OidcConfigService, StsConfigLoader, PASSED_CONFIG],\n        useFactory: configurationProviderFactory\n      }, OidcConfigService, PublicEventsService, FlowHelper, ConfigurationProvider, OidcSecurityService, TokenValidationService, PlatformProvider, CheckSessionService, FlowsDataService, FlowsService, SilentRenewService, LogoffRevocationService, UserService, RandomService, HttpBaseService, UrlService, AuthStateService, SigninKeyDataService, StoragePersistenceService, TokenHelperService, LoggerService, IFrameService, EqualityService, LoginService, ParService, AuthWellKnownDataService, AuthWellKnownService, DataService, StateValidationService, ConfigValidationService, CheckAuthService, ResetAuthDataService, ImplicitFlowCallbackService, HistoryJwtKeysCallbackHandlerService, ResponseTypeValidationService, UserCallbackHandlerService, StateValidationCallbackHandlerService, RefreshSessionCallbackHandlerService, RefreshTokenCallbackHandlerService, CodeFlowCallbackHandlerService, ImplicitFlowCallbackHandlerService, ParLoginService, PopUpLoginService, StandardLoginService, AutoLoginService, JwtWindowCryptoService, CurrentUrlService, ClosestMatchingRouteService, DefaultSessionStorageService, BrowserStorageService]\n    };\n  }\n\n}\n\nAuthModule.ɵfac = function AuthModule_Factory(t) {\n  return new (t || AuthModule)();\n};\n\nAuthModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: AuthModule\n});\nAuthModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[CommonModule, HttpClientModule]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule, HttpClientModule],\n      declarations: [],\n      exports: []\n    }]\n  }], null, null);\n})();\n\nclass AutoLoginAllRoutesGuard {\n  constructor(autoLoginService, checkAuthService, loginService, configurationProvider) {\n    this.autoLoginService = autoLoginService;\n    this.checkAuthService = checkAuthService;\n    this.loginService = loginService;\n    this.configurationProvider = configurationProvider;\n  }\n\n  canLoad(route, segments) {\n    const routeToRedirect = segments.join('/');\n    return this.checkAuth(routeToRedirect);\n  }\n\n  canActivate(route, state) {\n    return this.checkAuth(state.url);\n  }\n\n  canActivateChild(route, state) {\n    return this.checkAuth(state.url);\n  }\n\n  checkAuth(url) {\n    const configId = this.getId();\n    return this.checkAuthService.checkAuth().pipe(take(1), map(({\n      isAuthenticated\n    }) => {\n      if (isAuthenticated) {\n        this.autoLoginService.checkSavedRedirectRouteAndNavigate(configId);\n      }\n\n      if (!isAuthenticated) {\n        this.autoLoginService.saveRedirectRoute(configId, url);\n        this.loginService.login(configId);\n      }\n\n      return isAuthenticated;\n    }));\n  }\n\n  getId() {\n    return this.configurationProvider.getOpenIDConfiguration().configId;\n  }\n\n}\n\nAutoLoginAllRoutesGuard.ɵfac = function AutoLoginAllRoutesGuard_Factory(t) {\n  return new (t || AutoLoginAllRoutesGuard)(i0.ɵɵinject(AutoLoginService), i0.ɵɵinject(CheckAuthService), i0.ɵɵinject(LoginService), i0.ɵɵinject(ConfigurationProvider));\n};\n\nAutoLoginAllRoutesGuard.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AutoLoginAllRoutesGuard,\n  factory: AutoLoginAllRoutesGuard.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AutoLoginAllRoutesGuard, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: AutoLoginService\n    }, {\n      type: CheckAuthService\n    }, {\n      type: LoginService\n    }, {\n      type: ConfigurationProvider\n    }];\n  }, null);\n})();\n\nclass AutoLoginPartialRoutesGuard {\n  constructor(autoLoginService, authStateService, loginService, configurationProvider) {\n    this.autoLoginService = autoLoginService;\n    this.authStateService = authStateService;\n    this.loginService = loginService;\n    this.configurationProvider = configurationProvider;\n  }\n\n  canLoad(route, segments) {\n    const routeToRedirect = segments.join('/');\n    return this.checkAuth(routeToRedirect);\n  }\n\n  canActivate(route, state) {\n    return this.checkAuth(state.url);\n  }\n\n  canActivateChild(route, state) {\n    return this.checkAuth(state.url);\n  }\n\n  checkAuth(url) {\n    const configId = this.getId();\n    const isAuthenticated = this.authStateService.areAuthStorageTokensValid(configId);\n\n    if (isAuthenticated) {\n      this.autoLoginService.checkSavedRedirectRouteAndNavigate(configId);\n    }\n\n    if (!isAuthenticated) {\n      this.autoLoginService.saveRedirectRoute(configId, url);\n      this.loginService.login(configId);\n    }\n\n    return isAuthenticated;\n  }\n\n  getId() {\n    return this.configurationProvider.getOpenIDConfiguration().configId;\n  }\n\n}\n\nAutoLoginPartialRoutesGuard.ɵfac = function AutoLoginPartialRoutesGuard_Factory(t) {\n  return new (t || AutoLoginPartialRoutesGuard)(i0.ɵɵinject(AutoLoginService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(LoginService), i0.ɵɵinject(ConfigurationProvider));\n};\n\nAutoLoginPartialRoutesGuard.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AutoLoginPartialRoutesGuard,\n  factory: AutoLoginPartialRoutesGuard.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AutoLoginPartialRoutesGuard, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: AutoLoginService\n    }, {\n      type: AuthStateService\n    }, {\n      type: LoginService\n    }, {\n      type: ConfigurationProvider\n    }];\n  }, null);\n})();\n\nclass AuthInterceptor {\n  constructor(authStateService, configurationProvider, loggerService, closestMatchingRouteService) {\n    this.authStateService = authStateService;\n    this.configurationProvider = configurationProvider;\n    this.loggerService = loggerService;\n    this.closestMatchingRouteService = closestMatchingRouteService;\n  }\n\n  intercept(req, next) {\n    if (!this.configurationProvider.hasAtLeastOneConfig()) {\n      return next.handle(req);\n    }\n\n    const allConfigurations = this.configurationProvider.getAllConfigurations();\n    const allRoutesConfigured = allConfigurations.map(x => x.secureRoutes || []);\n    const allRoutesConfiguredFlat = [].concat.apply([], allRoutesConfigured);\n\n    if (allRoutesConfiguredFlat.length === 0) {\n      const {\n        configId\n      } = allConfigurations[0];\n      this.loggerService.logDebug(configId, `No routes to check configured`);\n      return next.handle(req);\n    }\n\n    const {\n      matchingConfigId,\n      matchingRoute\n    } = this.closestMatchingRouteService.getConfigIdForClosestMatchingRoute(req.url);\n\n    if (!matchingConfigId) {\n      const {\n        configId\n      } = allConfigurations[0];\n      this.loggerService.logDebug(configId, `Did not find any configured route for route ${req.url}`);\n      return next.handle(req);\n    }\n\n    this.loggerService.logDebug(matchingConfigId, `'${req.url}' matches configured route '${matchingRoute}'`);\n    const token = this.authStateService.getAccessToken(matchingConfigId);\n\n    if (!token) {\n      this.loggerService.logDebug(matchingConfigId, `Wanted to add token to ${req.url} but found no token: '${token}'`);\n      return next.handle(req);\n    }\n\n    this.loggerService.logDebug(matchingConfigId, `'${req.url}' matches configured route '${matchingRoute}', adding token`);\n    req = req.clone({\n      headers: req.headers.set('Authorization', 'Bearer ' + token)\n    });\n    return next.handle(req);\n  }\n\n}\n\nAuthInterceptor.ɵfac = function AuthInterceptor_Factory(t) {\n  return new (t || AuthInterceptor)(i0.ɵɵinject(AuthStateService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(LoggerService), i0.ɵɵinject(ClosestMatchingRouteService));\n};\n\nAuthInterceptor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AuthInterceptor,\n  factory: AuthInterceptor.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthInterceptor, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: AuthStateService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: LoggerService\n    }, {\n      type: ClosestMatchingRouteService\n    }];\n  }, null);\n})();\n/**\r\n * Implement this class-interface to create a custom storage.\r\n */\n\n\nclass AbstractSecurityStorage {}\n\nAbstractSecurityStorage.ɵfac = function AbstractSecurityStorage_Factory(t) {\n  return new (t || AbstractSecurityStorage)();\n};\n\nAbstractSecurityStorage.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AbstractSecurityStorage,\n  factory: AbstractSecurityStorage.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AbstractSecurityStorage, [{\n    type: Injectable\n  }], null, null);\n})(); // Public classes.\n\n/*\r\n * Public API Surface of angular-auth-oidc-client\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { AbstractSecurityStorage, AuthInterceptor, AuthModule, AutoLoginAllRoutesGuard, AutoLoginPartialRoutesGuard, EventTypes, LogLevel, LoggerService, OidcConfigService, OidcSecurityService, OpenIdConfigLoader, PASSED_CONFIG, PopUpService, PublicEventsService, StateValidationResult, StsConfigHttpLoader, StsConfigLoader, StsConfigStaticLoader, TokenHelperService, TokenValidationService, ValidationResult, configurationProviderFactory, createStaticLoader };","map":{"version":3,"sources":["C:/repos/git/damienbod/AzureADAuthRazorUiServiceApiCertificate/AngularAzureADMultipleApis/AngularAzureAD/node_modules/angular-auth-oidc-client/fesm2015/angular-auth-oidc-client.mjs"],"names":["DOCUMENT","isPlatformBrowser","CommonModule","i1","HttpHeaders","HttpParams","HttpErrorResponse","HttpResponse","HttpClientModule","i0","Injectable","Inject","PLATFORM_ID","InjectionToken","APP_INITIALIZER","NgModule","ReplaySubject","from","of","BehaviorSubject","throwError","timer","Observable","Subject","forkJoin","TimeoutError","map","mergeMap","tap","distinctUntilChanged","switchMap","retryWhen","catchError","retry","concatMap","take","timeout","base64url","i2","HttpBaseService","constructor","http","get","url","params","post","body","ɵfac","HttpClient","ɵprov","type","ConfigurationProvider","configsInternal","hasAtLeastOneConfig","Object","keys","length","hasManyConfigs","setConfig","readyConfig","configId","getOpenIDConfiguration","value","entries","getAllConfigurations","values","NGSW_CUSTOM_PARAM","DataService","httpClient","configurationProvider","token","headers","prepareHeaders","prepareParams","headersParams","set","decodeURIComponent","ngswBypass","EventTypes","LogLevel","LoggerService","logError","message","args","logErrorWithConfig","logErrorWithoutConfig","logWarning","logWarningWithConfig","logWarningWithoutConfig","logDebug","logLevelIsSet","loggingIsTurnedOff","currentLogLevelIsEqualOrSmallerThan","Debug","console","log","warn","Warn","error","logLevelToCompare","logLevel","undefined","None","BrowserStorageService","configProvider","loggerService","read","key","hasStorage","storage","getStorage","storedConfig","JSON","parse","write","stringify","remove","clear","Storage","StoragePersistenceService","browserStorageService","resetStorageFlowData","resetAuthStateInStorage","getAccessToken","getIdToken","_a","id_token","getRefreshToken","refresh_token","getAuthenticationResult","PublicEventsService","notify","fireEvent","next","registerForEvents","asObservable","PARTS_OF_TOKEN","TokenHelperService","getTokenExpirationDate","dataIdToken","hasOwnProperty","Date","toUTCString","date","setUTCSeconds","exp","getSigningInputFromToken","encoded","tokenIsValid","header","getHeaderFromToken","payload","getPayloadFromToken","join","getPartOfToken","getSignatureFromToken","index","partOfToken","extractPartOfToken","result","urlBase64Decode","str","output","replace","Error","decoded","window","atob","Buffer","toString","split","c","charCodeAt","slice","err","includes","parts","JwtWindowCryptoService","crypto","msCrypto","generateCodeChallenge","codeVerifier","calcHash","pipe","challengeRaw","base64UrlEncode","generateAtHash","accessToken","algorithm","tokenHash","substr","tokenHashBase64","btoa","valueToHash","msgBuffer","TextEncoder","encode","subtle","digest","hashBuffer","hashArray","Array","Uint8Array","toHashString","byteArray","e","String","fromCharCode","base64","TokenValidationService","tokenHelperService","jwtWindowCryptoService","keyAlgorithms","cyptoObj","hasIdTokenExpired","offsetSeconds","validateIdTokenExpNotExpired","decodedIdToken","tokenExpirationDate","tokenExpirationValue","valueOf","nowWithOffset","tokenNotExpired","millisToMinutesAndSeconds","toLocaleTimeString","validateAccessTokenNotExpired","accessTokenExpiresAt","accessTokenExpirationValue","validateRequiredIdToken","validated","validateIdTokenIatMaxOffset","maxOffsetAllowedInSeconds","disableIatOffsetValidation","dateTimeIatIdToken","iat","nowInUtc","diff","maxOffsetAllowedInMilliseconds","validateIdTokenNonce","localNonce","ignoreNonceAfterRefresh","isFromRefreshToken","nonce","refreshTokenNoncePlaceholder","validateIdTokenIss","authWellKnownEndpointsIssuer","iss","validateIdTokenAud","aud","isArray","validateIdTokenAzpExistsIfMoreThanOneAud","azp","validateIdTokenAzpValid","clientId","validateStateFromHashCallback","state","localState","validateSignatureIdToken","idToken","jwtkeys","headerData","kid","alg","find","k","kty","alg2kty","matchingKeys","filter","use","getImportAlg","signingInput","rawSignature","agent","navigator","userAgent","toLowerCase","indexOf","importKey","cryptoKey","signature","loose","getVerifyAlg","verify","isValid","charAt","name","hash","namedCurve","validateIdTokenAtHash","atHash","idTokenAlg","sha","newHash","millis","minutes","Math","floor","seconds","toFixed","DEFAULT_AUTHRESULT","isAuthenticated","allConfigsAuthenticated","AuthStateService","storagePersistenceService","publicEventsService","tokenValidationService","authenticatedInternal$","authenticated$","setAuthenticatedAndFireEvent","composeAuthenticatedResult","setUnauthenticatedAndFireEvent","configIdToReset","composeUnAuthenticatedResult","updateAndPublishAuthState","authenticationResult","NewAuthenticationResult","setAuthorizationData","authResult","persistAccessTokenExpirationTime","decodeURIComponentSafely","areAuthStorageTokensValid","hasIdTokenExpiredAndRenewCheckIsEnabled","hasAccessTokenExpiredIfExpiryExists","renewTimeBeforeTokenExpiresInSeconds","enableIdTokenExpiredValidationInRenew","tokenToCheck","idTokenExpired","IdTokenExpired","accessTokenExpiresIn","accessTokenHasNotExpired","hasExpired","TokenExpired","expires_in","accessTokenExpiryTime","checkAllConfigsIfTheyAreAuthenticated","configs","every","x","STORAGE_KEY","AutoLoginService","storageService","router","checkSavedRedirectRouteAndNavigate","savedRouteForRedirect","getStoredRedirectRoute","deleteStoredRedirectRoute","navigateByUrl","saveRedirectRoute","Router","UriEncoder","encodeKey","encodeURIComponent","encodeValue","decodeKey","decodeValue","RandomService","doc","createRandom","requiredLength","arr","getCrypto","getRandomValues","toHex","randomString","dec","characters","Uint32Array","i","defaultView","decorators","FlowsDataService","randomService","createNonce","setNonce","getAuthStateControl","setAuthStateControl","authStateControl","getExistingOrCreateAuthStateControl","setSessionState","sessionState","getCodeVerifier","createCodeVerifier","isSilentRenewRunning","storageObject","getSilentRenewRunningStorageEntry","silentRenewTimeoutInSeconds","timeOutInMilliseconds","dateOfLaunchedProcessUtc","currentDateUtc","toISOString","elapsedTimeInMilliseconds","abs","isProbablyStuck","resetSilentRenewRunning","setSilentRenewRunning","storageEntry","FlowHelper","isCurrentFlowCodeFlow","currentFlowIs","isCurrentFlowAnyImplicitFlow","isCurrentFlowImplicitFlowWithAccessToken","isCurrentFlowImplicitFlowWithoutAccessToken","isCurrentFlowCodeFlowWithRefreshTokens","useRefreshToken","flowTypes","responseType","some","CALLBACK_PARAMS_TO_CHECK","AUTH0_ENDPOINT","UrlService","flowsDataService","flowHelper","getUrlParameter","urlToCheck","regex","RegExp","results","exec","isCallbackFromSts","currentUrl","getRefreshSessionSilentRenewUrl","customParams","createUrlCodeFlowWithSilentRenew","createUrlImplicitFlowWithSilentRenew","getAuthorizeParUrl","requestUri","authWellKnownEndPoints","authorizationEndpoint","urlParts","authorizationUrl","existingParams","createHttpParams","append","getAuthorizeUrl","createUrlCodeFlowAuthorize","createUrlImplicitFlowAuthorize","createEndSessionUrl","idTokenHint","customParamsEndSession","isAuth0Endpoint","composeAuth0Endpoint","endSessionEndpoint","authorizationEndSessionUrl","postLogoutRedirectUri","getPostLogoutRedirectUrl","appendCustomParams","assign","createRevocationEndpointBodyAccessToken","getClientId","createRevocationEndpointBodyRefreshToken","getRevocationEndpointUrl","revocationEndpoint","revocationEndpointUrl","createBodyForCodeFlowCodeRequest","code","customTokenParams","silentRenewUrl","getSilentRenewUrl","redirectUrl","getRedirectUrl","createBodyForCodeFlowRefreshTokensRequest","refreshToken","customParamsRefresh","createBodyForParCodeFlowRequest","customParamsRequest","codeChallenge","scope","hdParam","customParamsAuthRequest","createAuthorizeUrl","prompt","customRequestParams","mergedParams","overWriteParam","fromString","encoder","authority","endsWith","postLogoutRedirectUrl","CodeFlowCallbackHandlerService","urlService","dataService","codeFlowCallback","initialCallbackContext","isRenewProcess","jwtKeys","validationResult","existingIdToken","codeFlowCodeRequest","callbackContext","isStateCorrect","authWellknownEndpoints","tokenEndpoint","config","bodyForCodeFlow","customParamsCodeRequest","response","session_state","handleRefreshRetry","errorMessage","errors","ProgressEvent","refreshTokenRetryInSeconds","DEFAULT_USERRESULT","userData","allUserData","UserService","oidcDataService","eventService","userDataInternal$","userData$","getAndPersistUserDataInStore","existingUserDataFromStorage","getUserDataFromStore","haveUserData","setUserDataToStore","renewUserInfoAfterTokenRenew","getUserDataOidcFlowAndSave","sub","publishUserDataIfExists","fireUserDataEvent","resetUserDataInStore","idTokenSub","getIdentityUserData","data","validateUserDataSubIdToken","userInfoEndpoint","userDataSub","passedUserData","composeSingleOrMultipleUserDataObject","UserDataChanged","composeSingleUserDataResult","currentConfigIsToUpdate","alreadySavedUserData","ResetAuthDataService","authStateService","userService","resetAuthorizationData","ImplicitFlowCallbackHandlerService","resetAuthDataService","implicitFlowCallback","isRenewProcessData","location","reduce","resultData","item","shift","ValidationResult","SigninKeyDataService","getSigningKeys","jwksUri","handleErrorGetSigningKeys","errorResponse","errMsg","status","statusText","JWT_KEYS","HistoryJwtKeysCallbackHandlerService","signInKeyDataService","callbackHistoryAndResetJwtKeys","historyCleanUpTurnedOn","resetBrowserHistory","handleResultErrorFromCallback","storeSigningKeys","storedJwtKeys","readSigningKeys","SecureTokenServerError","LoginRequired","historyCleanupOff","history","replaceState","document","title","origin","pathname","UserCallbackHandlerService","callbackUser","autoUserInfo","publishAuthState","publishUnauthenticatedState","stateValidationResult","StateValidationResult","authResponseIsValid","at_hash","NotSet","EqualityService","isStringEqualOrNonOrderedArrayEqual","value1","value2","isNullOrUndefined","oneValueIsStringAndTheOtherIsArray","bothValuesAreStrings","bothValuesAreArrays","arraysHaveEqualContent","areEqual","arraysStrictEqual","bothValuesAreObjects","valueIsString","valueIsObject","arr1","arr2","v","val","StateValidationService","equalityService","getValidatedStateResult","validateState","toReturn","StatesDoNotMatch","handleUnsuccessfulValidation","access_token","issValidationOff","maxIdTokenIatOffsetAllowedInSeconds","isSignatureIdTokenValid","SignatureFailed","authNonce","IncorrectNonce","RequiredPropertyMissing","MaxOffsetExpired","issuer","IssDoesNotMatchIssuer","NoAuthWellKnownEndPoints","IncorrectAud","IncorrectAzp","isIdTokenAfterRefreshTokenRequestValid","IncorrectIdTokenClaimsAfterRefresh","validateDefault","Ok","handleSuccessfulValidation","idTokenHeader","valid","IncorrectAtHash","newIdToken","disableRefreshIdTokenAuthTimeValidation","auth_time","autoCleanStateAfterAuthentication","StateValidationCallbackHandlerService","stateValidationService","callbackStateValidation","publishUnauthorizedState","RefreshSessionCallbackHandlerService","refreshSessionWithRefreshTokens","stateData","RefreshTokenCallbackHandlerService","refreshTokensRequestTokens","FlowsService","codeFlowCallbackHandlerService","implicitFlowCallbackHandlerService","historyJwtKeysCallbackHandlerService","userHandlerService","stateValidationCallbackHandlerService","refreshSessionCallbackHandlerService","refreshTokenCallbackHandlerService","processCodeFlowCallback","processSilentRenewCodeFlowCallback","firstContext","processImplicitFlowCallback","processRefreshToken","IntervalService","zone","runTokenValidationRunning","stopPeriodicTokenCheck","unsubscribe","startPeriodicTokenCheck","repeatAfterSeconds","millisecondsDelayBetweenTokenCheck","subscriber","intervalId","runOutsideAngular","setInterval","run","clearInterval","NgZone","providedIn","ImplicitFlowCallbackService","flowsService","intervalService","authenticatedImplicitFlowCallback","triggerAuthorizationResultEvent","postLoginRoute","unauthorizedRoute","IFrameService","getExistingIFrame","identifier","iFrameOnParent","getIFrameFromParentWindow","isIFrameElement","iFrameOnSelf","getIFrameFromWindow","addIFrameToWindowBody","sessionIframe","createElement","id","style","display","appendChild","iFrameElement","parent","getElementById","element","HTMLIFrameElement","IFRAME_FOR_CHECK_SESSION_IDENTIFIER","CheckSessionService","iFrameService","checkSessionReceived","lastIFrameRefresh","outstandingMessages","heartBeatInterval","iframeRefreshInterval","checkSessionChangedInternal$","checkSessionChanged$","isCheckSessionConfigured","startCheckSession","start","scheduledHeartBeatRunning","pollServerSession","stop","clearScheduledHeartBeat","serverStateChanged","getExistingIframe","init","now","existingIframe","getOrCreateIframe","checkSessionIframe","contentWindow","observer","onload","complete","pollServerSessionRecur","subscribe","iframeOrigin","URL","postMessage","setTimeout","clearTimeout","messageHandler","existingIFrame","startsWith","source","CheckSessionReceived","bindMessageEventToIframe","iframeMessageEvent","bind","addEventListener","frame","CurrentUrlService","getStateParamFromCurrentUrl","getCurrentUrl","parsedUrl","urlParams","URLSearchParams","search","stateFromUrl","currentUrlHasStateParam","IFRAME_FOR_SILENT_RENEW_IDENTIFIER","SilentRenewService","implicitFlowCallbackService","refreshSessionWithIFrameCompletedInternal$","refreshSessionWithIFrameCompleted$","isSilentRenewConfigured","silentRenew","codeFlowCallbackSilentRenewIframe","errorFromFlow","silentRenewEventHandler","detail","callback$","isCodeFlow","CodeFlowCallbackService","authenticatedCallbackWithCode","CallbackService","codeFlowCallbackService","stsCallbackInternal$","stsCallback$","isCallback","handleCallbackAndFireEvents","currentCallbackUrl","WELL_KNOWN_SUFFIX","AuthWellKnownDataService","getWellKnownEndPointsFromUrl","authWellknownEndpoint","getWellKnownDocument","wellKnownEndpoints","jwks_uri","authorization_endpoint","token_endpoint","userinfo_endpoint","end_session_endpoint","check_session_iframe","revocation_endpoint","introspectionEndpoint","introspection_endpoint","parEndpoint","pushed_authorization_request_endpoint","wellKnownEndpoint","AuthWellKnownService","getAuthWellKnownEndPoints","authWellknownEndpointUrl","alreadySavedWellKnownEndpoints","mappedWellKnownEndpoints","storeWellKnownEndpoints","ConfigLoadingFailed","RefreshSessionIframeService","silentRenewService","rendererFactory","renderer","createRenderer","refreshSessionWithIframe","sendAuthorizeRequestUsingSilentRenew","initSilentRenewRequest","onLoadHandler","removeEventListener","instanceId","random","initDestroyHandler","listen","renewDestroyHandler","dispatchEvent","CustomEvent","RendererFactory2","RefreshSessionRefreshTokenService","MAX_RETRY_ATTEMPTS","RefreshSessionService","authWellKnownService","refreshSessionIframeService","refreshSessionRefreshTokenService","userForceRefreshSession","extraCustomParams","persistCustomParams","forceRefreshSession","customParamsRefreshTokenRequest","startRefreshSession","timeOutTime","timeoutRetryStrategy","_","_b","shouldBeExecuted","errorAttempts","scalingDuration","currentAttempt","PeriodicallyTokenCheckService","startTokenValidationPeriodically","configsWithSilentRenewEnabled","getConfigsWithSilentRenewEnabled","refreshTimeInSeconds","getSmallestRefreshTimeFromConfigs","periodicallyCheck$","objectWithConfigIdsAndRefreshEvent","forEach","getRefreshEvent","objectWithConfigIds","shouldStartRefreshEvent","shouldStartPeriodicallyCheckForConfig","refreshEvent$","createRefreshEventForConfig","SilentRenewStarted","refreshEventWithErrorHandler$","prev","curr","tokenRefreshInSeconds","userDataFromStore","idTokenStillValid","accessTokenHasExpired","PopUpService","STORAGE_IDENTIFIER","resultInternal$","result$","isCurrentlyInPopup","canAccessSessionStorage","popup","sessionStorage","getItem","opener","openPopUp","popupOptions","optionsToPass","getOptions","popUp","open","setItem","listener","event","userClosed","receivedUrl","cleanUp","handle","closed","sendMessageToMainWindow","sendMessage","href","removeItem","close","popupDefaultOptions","width","height","left","top","options","screenLeft","outerWidth","screenTop","outerHeight","cookieEnabled","CheckAuthService","checkSessionService","currentUrlService","callbackService","refreshSessionService","periodicallyTokenCheckService","popupService","autoLoginService","checkAuth","passedConfigId","stateParamFromUrl","getConfigurationWithUrlState","checkAuthWithConfig","onlyExistingConfig","checkAuthMultiple","composeMultipleLoginResults","allConfigs","allChecks$","checkAuthIncludingServer","loginResponse","loginResponseAfterRefreshSession","startCheckSessionAndValidation","storedState","activeConfig","allOtherConfigs","currentConfigResult","allOtherConfigResults","DEFAULT_CONFIG","usePushedAuthorisationRequests","forbiddenRoute","customParamsEndSessionRequest","eagerLoadAuthWellKnownEndpoints","POSITIVE_VALIDATION_RESULT","messages","level","ensureAuthority","passedConfig","ensureClientId","createIdentifierToCheck","arrayHasDuplicates","array","Set","size","ensureNoDuplicatedConfigsRule","passedConfigs","allIdentifiers","someAreNull","hasDuplicates","ensureRedirectRule","ensureSilentRenewUrlWhenNoRefreshTokenUsed","usesSilentRenew","usesRefreshToken","hasSilentRenewUrl","useOfflineScopeWithSilentRenew","hasRefreshToken","hasSilentRenew","hasOfflineScope","allRules","allMultipleConfigRules","ConfigValidationService","validateConfigs","validateConfigsInternal","validateConfig","validateConfigInternal","allRulesToUse","allValidationResults","rule","overallErrorCount","errorCount","processValidationResultsAndGetErrorCount","allMessages","allErrorMessages","getAllMessagesOfType","allWarnings","acc","concat","PlatformProvider","platformId","isBrowser","DefaultSessionStorageService","OidcConfigService","configValidationService","platformProvider","defaultSessionStorageService","withConfigs","createUniqueIds","allHandleConfigs$","handleConfig","usedConfig","prepareConfig","alreadyExistingAuthWellKnownEndpoints","ConfigLoaded","passedAuthWellKnownEndpoints","wellknownEndPoints","configuration","openIdConfigurationInternal","setSpecialCases","setStorage","currentConfig","hasBrowserStorage","OpenIdConfigLoader","StsConfigLoader","StsConfigStaticLoader","loadConfigs","singleStaticConfig$","StsConfigHttpLoader","configs$","ClosestMatchingRouteService","getConfigIdForClosestMatchingRoute","route","allConfiguredRoutes","getAllConfiguredRoutes","routesWithConfig","allRoutesForConfig","routes","configuredRoute","matchingRoute","matchingConfigId","allConfigurations","secureRoutes","ResponseTypeValidationService","hasConfigValidResponseType","RedirectService","redirectTo","ParService","postParRequest","authWellKnownEndpoints","expiresIn","request_uri","ParLoginService","responseTypeValidationService","redirectService","checkAuthService","parService","loginPar","authOptions","urlHandler","loginWithPopUpPar","PopUpLoginService","loginWithPopUpStandard","authUrl","StandardLoginService","loginStandard","LoginService","parLoginService","popUpLoginService","standardLoginService","login","loginWithPopUp","LogoffRevocationService","logoff","endSessionUrl","getEndSessionUrl","logoffLocal","logoffLocalMultiple","logoffAndRevokeTokens","revokeRefreshToken","revokeAccessToken","accessTok","sendRevokeRequest","refreshTok","OidcSecurityService","logoffRevocationService","loginService","isAuthenticated$","getConfigurations","getConfiguration","getUserData","getPayloadFromIdToken","setState","getState","authorize","authorizeWithPopUp","createStaticLoader","configurationProviderFactory","oidcConfigService","loader","allConfigs$","fn","PASSED_CONFIG","AuthModule","forRoot","ngModule","providers","provide","useValue","useFactory","deps","multi","ɵmod","ɵinj","imports","declarations","exports","AutoLoginAllRoutesGuard","canLoad","segments","routeToRedirect","canActivate","canActivateChild","getId","AutoLoginPartialRoutesGuard","AuthInterceptor","closestMatchingRouteService","intercept","req","allRoutesConfigured","allRoutesConfiguredFlat","apply","clone","AbstractSecurityStorage"],"mappings":"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","sourcesContent":["import { DOCUMENT, isPlatformBrowser, CommonModule } from '@angular/common';\nimport * as i1 from '@angular/common/http';\nimport { HttpHeaders, HttpParams, HttpErrorResponse, HttpResponse, HttpClientModule } from '@angular/common/http';\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject, PLATFORM_ID, InjectionToken, APP_INITIALIZER, NgModule } from '@angular/core';\nimport { ReplaySubject, from, of, BehaviorSubject, throwError, timer, Observable, Subject, forkJoin, TimeoutError } from 'rxjs';\nimport { map, mergeMap, tap, distinctUntilChanged, switchMap, retryWhen, catchError, retry, concatMap, take, timeout } from 'rxjs/operators';\nimport { base64url } from 'rfc4648';\nimport * as i2 from '@angular/router';\n\nclass HttpBaseService {\r\n    constructor(http) {\r\n        this.http = http;\r\n    }\r\n    get(url, params) {\r\n        return this.http.get(url, params);\r\n    }\r\n    post(url, body, params) {\r\n        return this.http.post(url, body, params);\r\n    }\r\n}\r\nHttpBaseService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: HttpBaseService, deps: [{ token: i1.HttpClient }], target: i0.ɵɵFactoryTarget.Injectable });\r\nHttpBaseService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: HttpBaseService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: HttpBaseService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: i1.HttpClient }]; } });\n\nclass ConfigurationProvider {\r\n    constructor() {\r\n        this.configsInternal = {};\r\n    }\r\n    hasAtLeastOneConfig() {\r\n        return Object.keys(this.configsInternal).length > 0;\r\n    }\r\n    hasManyConfigs() {\r\n        return Object.keys(this.configsInternal).length > 1;\r\n    }\r\n    setConfig(readyConfig) {\r\n        const { configId } = readyConfig;\r\n        this.configsInternal[configId] = readyConfig;\r\n    }\r\n    getOpenIDConfiguration(configId) {\r\n        if (!!configId) {\r\n            return this.configsInternal[configId] || null;\r\n        }\r\n        const [, value] = Object.entries(this.configsInternal)[0] || [[null, null]];\r\n        return value || null;\r\n    }\r\n    getAllConfigurations() {\r\n        return Object.values(this.configsInternal);\r\n    }\r\n}\r\nConfigurationProvider.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: ConfigurationProvider, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nConfigurationProvider.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: ConfigurationProvider });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: ConfigurationProvider, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nconst NGSW_CUSTOM_PARAM = 'ngsw-bypass';\r\nclass DataService {\r\n    constructor(httpClient, configurationProvider) {\r\n        this.httpClient = httpClient;\r\n        this.configurationProvider = configurationProvider;\r\n    }\r\n    get(url, configId, token) {\r\n        const headers = this.prepareHeaders(token);\r\n        const params = this.prepareParams(configId);\r\n        return this.httpClient.get(url, {\r\n            headers,\r\n            params,\r\n        });\r\n    }\r\n    post(url, body, configId, headersParams) {\r\n        const headers = headersParams || this.prepareHeaders();\r\n        const params = this.prepareParams(configId);\r\n        return this.httpClient.post(url, body, { headers, params });\r\n    }\r\n    prepareHeaders(token) {\r\n        let headers = new HttpHeaders();\r\n        headers = headers.set('Accept', 'application/json');\r\n        if (!!token) {\r\n            headers = headers.set('Authorization', 'Bearer ' + decodeURIComponent(token));\r\n        }\r\n        return headers;\r\n    }\r\n    prepareParams(configId) {\r\n        let params = new HttpParams();\r\n        const { ngswBypass } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (ngswBypass) {\r\n            params = params.set(NGSW_CUSTOM_PARAM, '');\r\n        }\r\n        return params;\r\n    }\r\n}\r\nDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: DataService, deps: [{ token: HttpBaseService }, { token: ConfigurationProvider }], target: i0.ɵɵFactoryTarget.Injectable });\r\nDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: DataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: DataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: HttpBaseService }, { type: ConfigurationProvider }]; } });\n\n// eslint-disable-next-line no-shadow\r\nvar EventTypes;\r\n(function (EventTypes) {\r\n    /**\r\n     *  This only works in the AppModule Constructor\r\n     */\r\n    EventTypes[EventTypes[\"ConfigLoaded\"] = 0] = \"ConfigLoaded\";\r\n    EventTypes[EventTypes[\"ConfigLoadingFailed\"] = 1] = \"ConfigLoadingFailed\";\r\n    EventTypes[EventTypes[\"CheckSessionReceived\"] = 2] = \"CheckSessionReceived\";\r\n    EventTypes[EventTypes[\"UserDataChanged\"] = 3] = \"UserDataChanged\";\r\n    EventTypes[EventTypes[\"NewAuthenticationResult\"] = 4] = \"NewAuthenticationResult\";\r\n    EventTypes[EventTypes[\"TokenExpired\"] = 5] = \"TokenExpired\";\r\n    EventTypes[EventTypes[\"IdTokenExpired\"] = 6] = \"IdTokenExpired\";\r\n    EventTypes[EventTypes[\"SilentRenewStarted\"] = 7] = \"SilentRenewStarted\";\r\n})(EventTypes || (EventTypes = {}));\n\n// eslint-disable-next-line no-shadow\r\nvar LogLevel;\r\n(function (LogLevel) {\r\n    LogLevel[LogLevel[\"None\"] = 0] = \"None\";\r\n    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\r\n    LogLevel[LogLevel[\"Warn\"] = 2] = \"Warn\";\r\n    LogLevel[LogLevel[\"Error\"] = 3] = \"Error\";\r\n})(LogLevel || (LogLevel = {}));\n\nclass LoggerService {\r\n    constructor(configurationProvider) {\r\n        this.configurationProvider = configurationProvider;\r\n    }\r\n    logError(configId, message, ...args) {\r\n        if (!!configId) {\r\n            this.logErrorWithConfig(configId, message, ...args);\r\n        }\r\n        else {\r\n            this.logErrorWithoutConfig(message, ...args);\r\n        }\r\n    }\r\n    logWarning(configId, message, ...args) {\r\n        if (!!configId) {\r\n            this.logWarningWithConfig(configId, message, ...args);\r\n        }\r\n        else {\r\n            this.logWarningWithoutConfig(message, ...args);\r\n        }\r\n    }\r\n    logDebug(configId, message, ...args) {\r\n        if (!this.logLevelIsSet(configId)) {\r\n            return;\r\n        }\r\n        if (this.loggingIsTurnedOff(configId)) {\r\n            return;\r\n        }\r\n        if (!this.currentLogLevelIsEqualOrSmallerThan(configId, LogLevel.Debug)) {\r\n            return;\r\n        }\r\n        if (!!args && !!args.length) {\r\n            console.log(`[DEBUG] ${configId} - ${message}`, ...args);\r\n        }\r\n        else {\r\n            console.log(`[DEBUG] ${configId} - ${message}`);\r\n        }\r\n    }\r\n    logWarningWithoutConfig(message, ...args) {\r\n        if (!!args && !!args.length) {\r\n            console.warn(`[WARN] - ${message}`, ...args);\r\n        }\r\n        else {\r\n            console.warn(`[WARN] - ${message}`);\r\n        }\r\n    }\r\n    logWarningWithConfig(configId, message, ...args) {\r\n        if (!this.logLevelIsSet(configId)) {\r\n            return;\r\n        }\r\n        if (this.loggingIsTurnedOff(configId)) {\r\n            return;\r\n        }\r\n        if (!this.currentLogLevelIsEqualOrSmallerThan(configId, LogLevel.Warn)) {\r\n            return;\r\n        }\r\n        if (!!args && !!args.length) {\r\n            console.warn(`[WARN] ${configId} - ${message}`, ...args);\r\n        }\r\n        else {\r\n            console.warn(`[WARN] ${configId} - ${message}`);\r\n        }\r\n    }\r\n    logErrorWithConfig(configId, message, ...args) {\r\n        if (this.loggingIsTurnedOff(configId)) {\r\n            return;\r\n        }\r\n        if (!!args && !!args.length) {\r\n            console.error(`[ERROR] ${configId} - ${message}`, ...args);\r\n        }\r\n        else {\r\n            console.error(`[ERROR] ${configId} - ${message}`);\r\n        }\r\n    }\r\n    logErrorWithoutConfig(message, ...args) {\r\n        if (!!args && !!args.length) {\r\n            console.error(`[ERROR] - ${message}`, ...args);\r\n        }\r\n        else {\r\n            console.error(`[ERROR] - ${message}`);\r\n        }\r\n    }\r\n    currentLogLevelIsEqualOrSmallerThan(configId, logLevelToCompare) {\r\n        const { logLevel } = this.configurationProvider.getOpenIDConfiguration(configId) || {};\r\n        return logLevel <= logLevelToCompare;\r\n    }\r\n    logLevelIsSet(configId) {\r\n        const { logLevel } = this.configurationProvider.getOpenIDConfiguration(configId) || {};\r\n        if (logLevel === null) {\r\n            return false;\r\n        }\r\n        if (logLevel === undefined) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    loggingIsTurnedOff(configId) {\r\n        const { logLevel } = this.configurationProvider.getOpenIDConfiguration(configId) || {};\r\n        return logLevel === LogLevel.None;\r\n    }\r\n}\r\nLoggerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: LoggerService, deps: [{ token: ConfigurationProvider }], target: i0.ɵɵFactoryTarget.Injectable });\r\nLoggerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: LoggerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: LoggerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: ConfigurationProvider }]; } });\n\nclass BrowserStorageService {\r\n    constructor(configProvider, loggerService) {\r\n        this.configProvider = configProvider;\r\n        this.loggerService = loggerService;\r\n    }\r\n    read(key, configId) {\r\n        if (!this.hasStorage()) {\r\n            this.loggerService.logDebug(configId, `Wanted to read '${key}' but Storage was undefined`);\r\n            return null;\r\n        }\r\n        const storage = this.getStorage(configId);\r\n        if (!storage) {\r\n            this.loggerService.logDebug(configId, `Wanted to read config for '${configId}' but Storage was falsy`);\r\n            return null;\r\n        }\r\n        const storedConfig = storage.read(configId);\r\n        if (!storedConfig) {\r\n            return null;\r\n        }\r\n        return JSON.parse(storedConfig);\r\n    }\r\n    write(value, configId) {\r\n        if (!this.hasStorage()) {\r\n            this.loggerService.logDebug(configId, `Wanted to write '${value}' but Storage was falsy`);\r\n            return false;\r\n        }\r\n        const storage = this.getStorage(configId);\r\n        if (!storage) {\r\n            this.loggerService.logDebug(configId, `Wanted to write '${value}' but Storage was falsy`);\r\n            return false;\r\n        }\r\n        value = value || null;\r\n        storage.write(configId, JSON.stringify(value));\r\n        return true;\r\n    }\r\n    remove(key, configId) {\r\n        if (!this.hasStorage()) {\r\n            this.loggerService.logDebug(configId, `Wanted to remove '${key}' but Storage was falsy`);\r\n            return false;\r\n        }\r\n        const storage = this.getStorage(configId);\r\n        if (!storage) {\r\n            this.loggerService.logDebug(configId, `Wanted to write '${key}' but Storage was falsy`);\r\n            return false;\r\n        }\r\n        storage.remove(key);\r\n        return true;\r\n    }\r\n    // TODO THIS STORAGE WANTS AN ID BUT CLEARS EVERYTHING\r\n    clear(configId) {\r\n        if (!this.hasStorage()) {\r\n            this.loggerService.logDebug(configId, `Wanted to clear storage but Storage was falsy`);\r\n            return false;\r\n        }\r\n        const storage = this.getStorage(configId);\r\n        if (!storage) {\r\n            this.loggerService.logDebug(configId, `Wanted to clear storage but Storage was falsy`);\r\n            return false;\r\n        }\r\n        storage.clear();\r\n        return true;\r\n    }\r\n    getStorage(configId) {\r\n        const { storage } = this.configProvider.getOpenIDConfiguration(configId) || {};\r\n        return storage;\r\n    }\r\n    hasStorage() {\r\n        return typeof Storage !== 'undefined';\r\n    }\r\n}\r\nBrowserStorageService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: BrowserStorageService, deps: [{ token: ConfigurationProvider }, { token: LoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nBrowserStorageService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: BrowserStorageService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: BrowserStorageService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: ConfigurationProvider }, { type: LoggerService }]; } });\n\nclass StoragePersistenceService {\r\n    constructor(browserStorageService) {\r\n        this.browserStorageService = browserStorageService;\r\n    }\r\n    read(key, configId) {\r\n        const storedConfig = this.browserStorageService.read(key, configId) || {};\r\n        return storedConfig[key];\r\n    }\r\n    write(key, value, configId) {\r\n        const storedConfig = this.browserStorageService.read(key, configId) || {};\r\n        storedConfig[key] = value;\r\n        this.browserStorageService.write(storedConfig, configId);\r\n    }\r\n    remove(key, configId) {\r\n        const storedConfig = this.browserStorageService.read(key, configId) || {};\r\n        delete storedConfig[key];\r\n        this.browserStorageService.write(storedConfig, configId);\r\n    }\r\n    clear(configId) {\r\n        this.browserStorageService.clear(configId);\r\n    }\r\n    resetStorageFlowData(configId) {\r\n        this.remove('session_state', configId);\r\n        this.remove('storageSilentRenewRunning', configId);\r\n        this.remove('codeVerifier', configId);\r\n        this.remove('userData', configId);\r\n        this.remove('storageCustomParamsAuthRequest', configId);\r\n        this.remove('access_token_expires_at', configId);\r\n        this.remove('storageCustomParamsRefresh', configId);\r\n        this.remove('storageCustomParamsEndSession', configId);\r\n    }\r\n    resetAuthStateInStorage(configId) {\r\n        this.remove('authzData', configId);\r\n        this.remove('authnResult', configId);\r\n    }\r\n    getAccessToken(configId) {\r\n        return this.read('authzData', configId);\r\n    }\r\n    getIdToken(configId) {\r\n        var _a;\r\n        return (_a = this.read('authnResult', configId)) === null || _a === void 0 ? void 0 : _a.id_token;\r\n    }\r\n    getRefreshToken(configId) {\r\n        var _a;\r\n        return (_a = this.read('authnResult', configId)) === null || _a === void 0 ? void 0 : _a.refresh_token;\r\n    }\r\n    getAuthenticationResult(configId) {\r\n        return this.read('authnResult', configId);\r\n    }\r\n}\r\nStoragePersistenceService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: StoragePersistenceService, deps: [{ token: BrowserStorageService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nStoragePersistenceService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: StoragePersistenceService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: StoragePersistenceService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: BrowserStorageService }]; } });\n\nclass PublicEventsService {\r\n    constructor() {\r\n        this.notify = new ReplaySubject(1);\r\n    }\r\n    /**\r\n     * Fires a new event.\r\n     *\r\n     * @param type The event type.\r\n     * @param value The event value.\r\n     */\r\n    fireEvent(type, value) {\r\n        this.notify.next({ type, value });\r\n    }\r\n    /**\r\n     * Wires up the event notification observable.\r\n     */\r\n    registerForEvents() {\r\n        return this.notify.asObservable();\r\n    }\r\n}\r\nPublicEventsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: PublicEventsService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nPublicEventsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: PublicEventsService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: PublicEventsService, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nconst PARTS_OF_TOKEN = 3;\r\nclass TokenHelperService {\r\n    constructor(loggerService) {\r\n        this.loggerService = loggerService;\r\n    }\r\n    getTokenExpirationDate(dataIdToken) {\r\n        if (!dataIdToken.hasOwnProperty('exp')) {\r\n            return new Date(new Date().toUTCString());\r\n        }\r\n        const date = new Date(0); // The 0 here is the key, which sets the date to the epoch\r\n        date.setUTCSeconds(dataIdToken.exp);\r\n        return date;\r\n    }\r\n    getSigningInputFromToken(token, encoded, configId) {\r\n        if (!this.tokenIsValid(token, configId)) {\r\n            return '';\r\n        }\r\n        const header = this.getHeaderFromToken(token, encoded, configId);\r\n        const payload = this.getPayloadFromToken(token, encoded, configId);\r\n        return [header, payload].join('.');\r\n    }\r\n    getHeaderFromToken(token, encoded, configId) {\r\n        if (!this.tokenIsValid(token, configId)) {\r\n            return {};\r\n        }\r\n        return this.getPartOfToken(token, 0, encoded);\r\n    }\r\n    getPayloadFromToken(token, encoded, configId) {\r\n        if (!this.tokenIsValid(token, configId)) {\r\n            return {};\r\n        }\r\n        return this.getPartOfToken(token, 1, encoded);\r\n    }\r\n    getSignatureFromToken(token, encoded, configId) {\r\n        if (!this.tokenIsValid(token, configId)) {\r\n            return {};\r\n        }\r\n        return this.getPartOfToken(token, 2, encoded);\r\n    }\r\n    getPartOfToken(token, index, encoded) {\r\n        const partOfToken = this.extractPartOfToken(token, index);\r\n        if (encoded) {\r\n            return partOfToken;\r\n        }\r\n        const result = this.urlBase64Decode(partOfToken);\r\n        return JSON.parse(result);\r\n    }\r\n    urlBase64Decode(str) {\r\n        let output = str.replace(/-/g, '+').replace(/_/g, '/');\r\n        switch (output.length % 4) {\r\n            case 0:\r\n                break;\r\n            case 2:\r\n                output += '==';\r\n                break;\r\n            case 3:\r\n                output += '=';\r\n                break;\r\n            default:\r\n                throw Error('Illegal base64url string!');\r\n        }\r\n        const decoded = typeof window !== 'undefined' ? window.atob(output) : Buffer.from(output, 'base64').toString('binary');\r\n        try {\r\n            // Going backwards: from byte stream, to percent-encoding, to original string.\r\n            return decodeURIComponent(decoded\r\n                .split('')\r\n                .map((c) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))\r\n                .join(''));\r\n        }\r\n        catch (err) {\r\n            return decoded;\r\n        }\r\n    }\r\n    tokenIsValid(token, configId) {\r\n        if (!token) {\r\n            this.loggerService.logError(configId, `token '${token}' is not valid --> token falsy`);\r\n            return false;\r\n        }\r\n        if (!token.includes('.')) {\r\n            this.loggerService.logError(configId, `token '${token}' is not valid --> no dots included`);\r\n            return false;\r\n        }\r\n        const parts = token.split('.');\r\n        if (parts.length !== PARTS_OF_TOKEN) {\r\n            this.loggerService.logError(configId, `token '${token}' is not valid --> token has to have exactly ${PARTS_OF_TOKEN - 1} dots`);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    extractPartOfToken(token, index) {\r\n        return token.split('.')[index];\r\n    }\r\n}\r\nTokenHelperService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: TokenHelperService, deps: [{ token: LoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nTokenHelperService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: TokenHelperService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: TokenHelperService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }]; } });\n\nclass JwtWindowCryptoService {\r\n    constructor() {\r\n        this.crypto = window.crypto || window.msCrypto; // for IE11\r\n    }\r\n    generateCodeChallenge(codeVerifier) {\r\n        return this.calcHash(codeVerifier).pipe(map((challengeRaw) => base64UrlEncode(challengeRaw)));\r\n    }\r\n    generateAtHash(accessToken, algorithm) {\r\n        return this.calcHash(accessToken, algorithm).pipe(map((tokenHash) => {\r\n            let substr = tokenHash.substr(0, tokenHash.length / 2);\r\n            const tokenHashBase64 = btoa(substr);\r\n            return tokenHashBase64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\r\n        }));\r\n    }\r\n    calcHash(valueToHash, algorithm = 'SHA-256') {\r\n        const msgBuffer = new TextEncoder().encode(valueToHash);\r\n        return from(this.crypto.subtle.digest(algorithm, msgBuffer)).pipe(map((hashBuffer) => {\r\n            const hashArray = Array.from(new Uint8Array(hashBuffer));\r\n            return this.toHashString(hashArray);\r\n        }));\r\n    }\r\n    toHashString(byteArray) {\r\n        let result = '';\r\n        for (let e of byteArray) {\r\n            result += String.fromCharCode(e);\r\n        }\r\n        return result;\r\n    }\r\n}\r\nJwtWindowCryptoService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: JwtWindowCryptoService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nJwtWindowCryptoService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: JwtWindowCryptoService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: JwtWindowCryptoService, decorators: [{\r\n            type: Injectable\r\n        }] });\r\nfunction base64UrlEncode(str) {\r\n    const base64 = btoa(str);\r\n    return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\r\n}\n\n// http://openid.net/specs/openid-connect-implicit-1_0.html\r\n// id_token\r\n// id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)\r\n// MUST exactly match the value of the iss (issuer) Claim.\r\n//\r\n// id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified\r\n// by the iss (issuer) Claim as an audience.The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience,\r\n// or if it contains additional audiences not trusted by the Client.\r\n//\r\n// id_token C3: If the ID Token contains multiple audiences, the Client SHOULD verify that an azp Claim is present.\r\n//\r\n// id_token C4: If an azp (authorized party) Claim is present, the Client SHOULD verify that its client_id is the Claim Value.\r\n//\r\n// id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the\r\n// alg Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.\r\n//\r\n// id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the OpenID Connect\r\n// Core 1.0\r\n// [OpenID.Core] specification.\r\n//\r\n// id_token C7: The current time MUST be before the time represented by the exp Claim (possibly allowing for some small leeway to account\r\n// for clock skew).\r\n//\r\n// id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,\r\n// limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.\r\n//\r\n// id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one that was sent\r\n// in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.The precise method for detecting replay attacks\r\n// is Client specific.\r\n//\r\n// id_token C10: If the acr Claim was requested, the Client SHOULD check that the asserted Claim Value is appropriate.\r\n// The meaning and processing of acr Claim Values is out of scope for this document.\r\n//\r\n// id_token C11: When a max_age request is made, the Client SHOULD check the auth_time Claim value and request re- authentication\r\n// if it determines too much time has elapsed since the last End- User authentication.\r\n// Access Token Validation\r\n// access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]\r\n// for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.\r\n// access_token C2: Take the left- most half of the hash and base64url- encode it.\r\n// access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash is present\r\n// in the ID Token.\r\nclass TokenValidationService {\r\n    constructor(tokenHelperService, loggerService, jwtWindowCryptoService) {\r\n        this.tokenHelperService = tokenHelperService;\r\n        this.loggerService = loggerService;\r\n        this.jwtWindowCryptoService = jwtWindowCryptoService;\r\n        this.keyAlgorithms = ['HS256', 'HS384', 'HS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'PS256', 'PS384', 'PS512'];\r\n        this.cyptoObj = window.crypto || window.msCrypto; // for IE11\r\n    }\r\n    // id_token C7: The current time MUST be before the time represented by the exp Claim\r\n    // (possibly allowing for some small leeway to account for clock skew).\r\n    hasIdTokenExpired(token, configId, offsetSeconds) {\r\n        const decoded = this.tokenHelperService.getPayloadFromToken(token, false, configId);\r\n        return !this.validateIdTokenExpNotExpired(decoded, configId, offsetSeconds);\r\n    }\r\n    // id_token C7: The current time MUST be before the time represented by the exp Claim\r\n    // (possibly allowing for some small leeway to account for clock skew).\r\n    validateIdTokenExpNotExpired(decodedIdToken, configId, offsetSeconds) {\r\n        const tokenExpirationDate = this.tokenHelperService.getTokenExpirationDate(decodedIdToken);\r\n        offsetSeconds = offsetSeconds || 0;\r\n        if (!tokenExpirationDate) {\r\n            return false;\r\n        }\r\n        const tokenExpirationValue = tokenExpirationDate.valueOf();\r\n        const nowWithOffset = new Date(new Date().toUTCString()).valueOf() + offsetSeconds * 1000;\r\n        const tokenNotExpired = tokenExpirationValue > nowWithOffset;\r\n        this.loggerService.logDebug(configId, `Has idToken expired: ${!tokenNotExpired} --> expires in ${this.millisToMinutesAndSeconds(tokenExpirationValue - nowWithOffset)} , ${new Date(tokenExpirationValue).toLocaleTimeString()} > ${new Date(nowWithOffset).toLocaleTimeString()}`);\r\n        // Token not expired?\r\n        return tokenNotExpired;\r\n    }\r\n    validateAccessTokenNotExpired(accessTokenExpiresAt, configId, offsetSeconds) {\r\n        // value is optional, so if it does not exist, then it has not expired\r\n        if (!accessTokenExpiresAt) {\r\n            return true;\r\n        }\r\n        offsetSeconds = offsetSeconds || 0;\r\n        const accessTokenExpirationValue = accessTokenExpiresAt.valueOf();\r\n        const nowWithOffset = new Date(new Date().toUTCString()).valueOf() + offsetSeconds * 1000;\r\n        const tokenNotExpired = accessTokenExpirationValue > nowWithOffset;\r\n        this.loggerService.logDebug(configId, `Has accessToken expired: ${!tokenNotExpired} --> expires in ${this.millisToMinutesAndSeconds(accessTokenExpirationValue - nowWithOffset)} , ${new Date(accessTokenExpirationValue).toLocaleTimeString()} > ${new Date(nowWithOffset).toLocaleTimeString()}`);\r\n        // access token not expired?\r\n        return tokenNotExpired;\r\n    }\r\n    // iss\r\n    // REQUIRED. Issuer Identifier for the Issuer of the response.The iss value is a case-sensitive URL using the\r\n    // https scheme that contains scheme, host,\r\n    // and optionally, port number and path components and no query or fragment components.\r\n    //\r\n    // sub\r\n    // REQUIRED. Subject Identifier.Locally unique and never reassigned identifier within the Issuer for the End- User,\r\n    // which is intended to be consumed by the Client, e.g., 24400320 or AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4.\r\n    // It MUST NOT exceed 255 ASCII characters in length.The sub value is a case-sensitive string.\r\n    //\r\n    // aud\r\n    // REQUIRED. Audience(s) that this ID Token is intended for. It MUST contain the OAuth 2.0 client_id of the Relying Party as an\r\n    // audience value.\r\n    // It MAY also contain identifiers for other audiences.In the general case, the aud value is an array of case-sensitive strings.\r\n    // In the common special case when there is one audience, the aud value MAY be a single case-sensitive string.\r\n    //\r\n    // exp\r\n    // REQUIRED. Expiration time on or after which the ID Token MUST NOT be accepted for processing.\r\n    // The processing of this parameter requires that the current date/ time MUST be before the expiration date/ time listed in the value.\r\n    // Implementers MAY provide for some small leeway, usually no more than a few minutes, to account for clock skew.\r\n    // Its value is a JSON [RFC7159] number representing the number of seconds from 1970- 01 - 01T00: 00:00Z as measured in UTC until\r\n    // the date/ time.\r\n    // See RFC 3339 [RFC3339] for details regarding date/ times in general and UTC in particular.\r\n    //\r\n    // iat\r\n    // REQUIRED. Time at which the JWT was issued. Its value is a JSON number representing the number of seconds from\r\n    // 1970- 01 - 01T00: 00: 00Z as measured\r\n    // in UTC until the date/ time.\r\n    validateRequiredIdToken(dataIdToken, configId) {\r\n        let validated = true;\r\n        if (!dataIdToken.hasOwnProperty('iss')) {\r\n            validated = false;\r\n            this.loggerService.logWarning(configId, 'iss is missing, this is required in the id_token');\r\n        }\r\n        if (!dataIdToken.hasOwnProperty('sub')) {\r\n            validated = false;\r\n            this.loggerService.logWarning(configId, 'sub is missing, this is required in the id_token');\r\n        }\r\n        if (!dataIdToken.hasOwnProperty('aud')) {\r\n            validated = false;\r\n            this.loggerService.logWarning(configId, 'aud is missing, this is required in the id_token');\r\n        }\r\n        if (!dataIdToken.hasOwnProperty('exp')) {\r\n            validated = false;\r\n            this.loggerService.logWarning(configId, 'exp is missing, this is required in the id_token');\r\n        }\r\n        if (!dataIdToken.hasOwnProperty('iat')) {\r\n            validated = false;\r\n            this.loggerService.logWarning(configId, 'iat is missing, this is required in the id_token');\r\n        }\r\n        return validated;\r\n    }\r\n    // id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,\r\n    // limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.\r\n    validateIdTokenIatMaxOffset(dataIdToken, maxOffsetAllowedInSeconds, disableIatOffsetValidation, configId) {\r\n        if (disableIatOffsetValidation) {\r\n            return true;\r\n        }\r\n        if (!dataIdToken.hasOwnProperty('iat')) {\r\n            return false;\r\n        }\r\n        const dateTimeIatIdToken = new Date(0); // The 0 here is the key, which sets the date to the epoch\r\n        dateTimeIatIdToken.setUTCSeconds(dataIdToken.iat);\r\n        maxOffsetAllowedInSeconds = maxOffsetAllowedInSeconds || 0;\r\n        const nowInUtc = new Date(new Date().toUTCString());\r\n        const diff = nowInUtc.valueOf() - dateTimeIatIdToken.valueOf();\r\n        const maxOffsetAllowedInMilliseconds = maxOffsetAllowedInSeconds * 1000;\r\n        this.loggerService.logDebug(configId, `validate id token iat max offset ${diff} < ${maxOffsetAllowedInMilliseconds}`);\r\n        if (diff > 0) {\r\n            return diff < maxOffsetAllowedInMilliseconds;\r\n        }\r\n        return -diff < maxOffsetAllowedInMilliseconds;\r\n    }\r\n    // id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one\r\n    // that was sent in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.\r\n    // The precise method for detecting replay attacks is Client specific.\r\n    // However the nonce claim SHOULD not be present for the refresh_token grant type\r\n    // https://bitbucket.org/openid/connect/issues/1025/ambiguity-with-how-nonce-is-handled-on\r\n    // The current spec is ambiguous and KeyCloak does send it.\r\n    validateIdTokenNonce(dataIdToken, localNonce, ignoreNonceAfterRefresh, configId) {\r\n        const isFromRefreshToken = (dataIdToken.nonce === undefined || ignoreNonceAfterRefresh) && localNonce === TokenValidationService.refreshTokenNoncePlaceholder;\r\n        if (!isFromRefreshToken && dataIdToken.nonce !== localNonce) {\r\n            this.loggerService.logDebug(configId, 'Validate_id_token_nonce failed, dataIdToken.nonce: ' + dataIdToken.nonce + ' local_nonce:' + localNonce);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    // id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)\r\n    // MUST exactly match the value of the iss (issuer) Claim.\r\n    validateIdTokenIss(dataIdToken, authWellKnownEndpointsIssuer, configId) {\r\n        if (dataIdToken.iss !== authWellKnownEndpointsIssuer) {\r\n            this.loggerService.logDebug(configId, 'Validate_id_token_iss failed, dataIdToken.iss: ' +\r\n                dataIdToken.iss +\r\n                ' authWellKnownEndpoints issuer:' +\r\n                authWellKnownEndpointsIssuer);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    // id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified\r\n    // by the iss (issuer) Claim as an audience.\r\n    // The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience, or if it contains additional audiences\r\n    // not trusted by the Client.\r\n    validateIdTokenAud(dataIdToken, aud, configId) {\r\n        if (Array.isArray(dataIdToken.aud)) {\r\n            const result = dataIdToken.aud.includes(aud);\r\n            if (!result) {\r\n                this.loggerService.logDebug(configId, 'Validate_id_token_aud array failed, dataIdToken.aud: ' + dataIdToken.aud + ' client_id:' + aud);\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n        else if (dataIdToken.aud !== aud) {\r\n            this.loggerService.logDebug(configId, 'Validate_id_token_aud failed, dataIdToken.aud: ' + dataIdToken.aud + ' client_id:' + aud);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    validateIdTokenAzpExistsIfMoreThanOneAud(dataIdToken) {\r\n        if (!dataIdToken) {\r\n            return false;\r\n        }\r\n        if (Array.isArray(dataIdToken.aud) && dataIdToken.aud.length > 1 && !dataIdToken.azp) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    // If an azp (authorized party) Claim is present, the Client SHOULD verify that its client_id is the Claim Value.\r\n    validateIdTokenAzpValid(dataIdToken, clientId) {\r\n        if (!(dataIdToken === null || dataIdToken === void 0 ? void 0 : dataIdToken.azp)) {\r\n            return true;\r\n        }\r\n        if (dataIdToken.azp === clientId) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    validateStateFromHashCallback(state, localState, configId) {\r\n        if (state !== localState) {\r\n            this.loggerService.logDebug(configId, 'ValidateStateFromHashCallback failed, state: ' + state + ' local_state:' + localState);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    // id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the alg\r\n    // Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.\r\n    // id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the\r\n    // OpenID Connect Core 1.0 [OpenID.Core] specification.\r\n    validateSignatureIdToken(idToken, jwtkeys, configId) {\r\n        if (!jwtkeys || !jwtkeys.keys) {\r\n            return of(false);\r\n        }\r\n        const headerData = this.tokenHelperService.getHeaderFromToken(idToken, false, configId);\r\n        if (Object.keys(headerData).length === 0 && headerData.constructor === Object) {\r\n            this.loggerService.logWarning(configId, 'id token has no header data');\r\n            return of(false);\r\n        }\r\n        const kid = headerData.kid;\r\n        let alg = headerData.alg;\r\n        let keys = jwtkeys.keys;\r\n        let key;\r\n        if (!this.keyAlgorithms.includes(alg)) {\r\n            this.loggerService.logWarning(configId, 'alg not supported', alg);\r\n            return of(false);\r\n        }\r\n        if (kid) {\r\n            key = keys.find((k) => k['kid'] === kid);\r\n        }\r\n        else {\r\n            let kty = this.alg2kty(alg);\r\n            let matchingKeys = keys.filter((k) => k.kty === kty && k.use === 'sig');\r\n            if (matchingKeys.length > 1) {\r\n                let error = 'More than one matching key found. Please specify a kid in the id_token header.';\r\n                console.error(error);\r\n                return of(false);\r\n            }\r\n            else if (matchingKeys.length === 1) {\r\n                key = matchingKeys[0];\r\n            }\r\n        }\r\n        const algorithm = this.getImportAlg(alg);\r\n        const signingInput = this.tokenHelperService.getSigningInputFromToken(idToken, true, configId);\r\n        const rawSignature = this.tokenHelperService.getSignatureFromToken(idToken, true, configId);\r\n        const agent = window.navigator.userAgent.toLowerCase();\r\n        if (agent.indexOf('firefox') > -1 && key.kty === 'EC') {\r\n            key.alg = '';\r\n        }\r\n        return from(this.cyptoObj.subtle.importKey('jwk', key, algorithm, false, ['verify'])).pipe(mergeMap((cryptoKey) => {\r\n            const signature = base64url.parse(rawSignature, { loose: true });\r\n            const algorithm = this.getVerifyAlg(alg);\r\n            return from(this.cyptoObj.subtle.verify(algorithm, cryptoKey, signature, new TextEncoder().encode(signingInput)));\r\n        }), tap((isValid) => {\r\n            if (!isValid) {\r\n                this.loggerService.logWarning(configId, 'incorrect Signature, validation failed for id_token');\r\n            }\r\n        }));\r\n    }\r\n    getImportAlg(alg) {\r\n        switch (alg.charAt(0)) {\r\n            case 'R':\r\n                if (alg.includes('256')) {\r\n                    return {\r\n                        name: 'RSASSA-PKCS1-v1_5',\r\n                        hash: 'SHA-256',\r\n                    };\r\n                }\r\n                else if (alg.includes('384')) {\r\n                    return {\r\n                        name: 'RSASSA-PKCS1-v1_5',\r\n                        hash: 'SHA-384',\r\n                    };\r\n                }\r\n                else if (alg.includes('512')) {\r\n                    return {\r\n                        name: 'RSASSA-PKCS1-v1_5',\r\n                        hash: 'SHA-512',\r\n                    };\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            case 'E':\r\n                if (alg.includes('256')) {\r\n                    return {\r\n                        name: 'ECDSA',\r\n                        namedCurve: 'P-256',\r\n                    };\r\n                }\r\n                else if (alg.includes('384')) {\r\n                    return {\r\n                        name: 'ECDSA',\r\n                        namedCurve: 'P-384',\r\n                    };\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n    getVerifyAlg(alg) {\r\n        switch (alg.charAt(0)) {\r\n            case 'R':\r\n                return {\r\n                    name: 'RSASSA-PKCS1-v1_5',\r\n                    hash: 'SHA-256',\r\n                };\r\n            case 'E':\r\n                if (alg.includes('256')) {\r\n                    return {\r\n                        name: 'ECDSA',\r\n                        hash: 'SHA-256',\r\n                    };\r\n                }\r\n                else if (alg.includes('384')) {\r\n                    return {\r\n                        name: 'ECDSA',\r\n                        hash: 'SHA-384',\r\n                    };\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n    alg2kty(alg) {\r\n        switch (alg.charAt(0)) {\r\n            case 'R':\r\n                return 'RSA';\r\n            case 'E':\r\n                return 'EC';\r\n            default:\r\n                throw new Error('Cannot infer kty from alg: ' + alg);\r\n        }\r\n    }\r\n    // Accepts ID Token without 'kid' claim in JOSE header if only one JWK supplied in 'jwks_url'\r\n    //// private validate_no_kid_in_header_only_one_allowed_in_jwtkeys(header_data: any, jwtkeys: any): boolean {\r\n    ////    this.oidcSecurityCommon.logDebug('amount of jwtkeys.keys: ' + jwtkeys.keys.length);\r\n    ////    if (!header_data.hasOwnProperty('kid')) {\r\n    ////        // no kid defined in Jose header\r\n    ////        if (jwtkeys.keys.length != 1) {\r\n    ////            this.oidcSecurityCommon.logDebug('jwtkeys.keys.length != 1 and no kid in header');\r\n    ////            return false;\r\n    ////        }\r\n    ////    }\r\n    ////    return true;\r\n    //// }\r\n    // Access Token Validation\r\n    // access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]\r\n    // for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.\r\n    // access_token C2: Take the left- most half of the hash and base64url- encode it.\r\n    // access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash\r\n    // is present in the ID Token.\r\n    validateIdTokenAtHash(accessToken, atHash, idTokenAlg, configId) {\r\n        this.loggerService.logDebug(configId, 'at_hash from the server:' + atHash);\r\n        // 'sha256' 'sha384' 'sha512'\r\n        let sha = 'SHA-256';\r\n        if (idTokenAlg.includes('384')) {\r\n            sha = 'SHA-384';\r\n        }\r\n        else if (idTokenAlg.includes('512')) {\r\n            sha = 'SHA-512';\r\n        }\r\n        return this.jwtWindowCryptoService.generateAtHash('' + accessToken, sha).pipe(mergeMap((hash) => {\r\n            this.loggerService.logDebug(configId, 'at_hash client validation not decoded:' + hash);\r\n            if (hash === atHash) {\r\n                return of(true); // isValid;\r\n            }\r\n            else {\r\n                return this.jwtWindowCryptoService.generateAtHash('' + decodeURIComponent(accessToken), sha).pipe(map((newHash) => {\r\n                    this.loggerService.logDebug(configId, '-gen access--' + hash);\r\n                    return newHash === atHash;\r\n                }));\r\n            }\r\n        }));\r\n    }\r\n    millisToMinutesAndSeconds(millis) {\r\n        const minutes = Math.floor(millis / 60000);\r\n        const seconds = ((millis % 60000) / 1000).toFixed(0);\r\n        return minutes + ':' + (+seconds < 10 ? '0' : '') + seconds;\r\n    }\r\n}\r\nTokenValidationService.refreshTokenNoncePlaceholder = '--RefreshToken--';\r\nTokenValidationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: TokenValidationService, deps: [{ token: TokenHelperService }, { token: LoggerService }, { token: JwtWindowCryptoService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nTokenValidationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: TokenValidationService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: TokenValidationService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: TokenHelperService }, { type: LoggerService }, { type: JwtWindowCryptoService }]; } });\n\nconst DEFAULT_AUTHRESULT = { isAuthenticated: false, allConfigsAuthenticated: [] };\r\nclass AuthStateService {\r\n    constructor(storagePersistenceService, loggerService, publicEventsService, configurationProvider, tokenValidationService) {\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.loggerService = loggerService;\r\n        this.publicEventsService = publicEventsService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.tokenValidationService = tokenValidationService;\r\n        this.authenticatedInternal$ = new BehaviorSubject(DEFAULT_AUTHRESULT);\r\n    }\r\n    get authenticated$() {\r\n        return this.authenticatedInternal$.asObservable().pipe(distinctUntilChanged());\r\n    }\r\n    setAuthenticatedAndFireEvent() {\r\n        const result = this.composeAuthenticatedResult();\r\n        this.authenticatedInternal$.next(result);\r\n    }\r\n    setUnauthenticatedAndFireEvent(configIdToReset) {\r\n        this.storagePersistenceService.resetAuthStateInStorage(configIdToReset);\r\n        const result = this.composeUnAuthenticatedResult();\r\n        this.authenticatedInternal$.next(result);\r\n    }\r\n    updateAndPublishAuthState(authenticationResult) {\r\n        this.publicEventsService.fireEvent(EventTypes.NewAuthenticationResult, authenticationResult);\r\n    }\r\n    setAuthorizationData(accessToken, authResult, configId) {\r\n        this.loggerService.logDebug(configId, `storing the accessToken '${accessToken}'`);\r\n        this.storagePersistenceService.write('authzData', accessToken, configId);\r\n        this.persistAccessTokenExpirationTime(authResult, configId);\r\n        this.setAuthenticatedAndFireEvent();\r\n    }\r\n    getAccessToken(configId) {\r\n        if (!this.isAuthenticated(configId)) {\r\n            return null;\r\n        }\r\n        const token = this.storagePersistenceService.getAccessToken(configId);\r\n        return this.decodeURIComponentSafely(token);\r\n    }\r\n    getIdToken(configId) {\r\n        if (!this.isAuthenticated(configId)) {\r\n            return null;\r\n        }\r\n        const token = this.storagePersistenceService.getIdToken(configId);\r\n        return this.decodeURIComponentSafely(token);\r\n    }\r\n    getRefreshToken(configId) {\r\n        if (!this.isAuthenticated(configId)) {\r\n            return null;\r\n        }\r\n        const token = this.storagePersistenceService.getRefreshToken(configId);\r\n        return this.decodeURIComponentSafely(token);\r\n    }\r\n    getAuthenticationResult(configId) {\r\n        if (!this.isAuthenticated(configId)) {\r\n            return null;\r\n        }\r\n        return this.storagePersistenceService.getAuthenticationResult(configId);\r\n    }\r\n    areAuthStorageTokensValid(configId) {\r\n        if (!this.isAuthenticated(configId)) {\r\n            return false;\r\n        }\r\n        if (this.hasIdTokenExpiredAndRenewCheckIsEnabled(configId)) {\r\n            this.loggerService.logDebug(configId, 'persisted idToken is expired');\r\n            return false;\r\n        }\r\n        if (this.hasAccessTokenExpiredIfExpiryExists(configId)) {\r\n            this.loggerService.logDebug(configId, 'persisted accessToken is expired');\r\n            return false;\r\n        }\r\n        this.loggerService.logDebug(configId, 'persisted idToken and accessToken are valid');\r\n        return true;\r\n    }\r\n    hasIdTokenExpiredAndRenewCheckIsEnabled(configId) {\r\n        const { renewTimeBeforeTokenExpiresInSeconds, enableIdTokenExpiredValidationInRenew } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!enableIdTokenExpiredValidationInRenew) {\r\n            return false;\r\n        }\r\n        const tokenToCheck = this.storagePersistenceService.getIdToken(configId);\r\n        const idTokenExpired = this.tokenValidationService.hasIdTokenExpired(tokenToCheck, configId, renewTimeBeforeTokenExpiresInSeconds);\r\n        if (idTokenExpired) {\r\n            this.publicEventsService.fireEvent(EventTypes.IdTokenExpired, idTokenExpired);\r\n        }\r\n        return idTokenExpired;\r\n    }\r\n    hasAccessTokenExpiredIfExpiryExists(configId) {\r\n        const { renewTimeBeforeTokenExpiresInSeconds } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        const accessTokenExpiresIn = this.storagePersistenceService.read('access_token_expires_at', configId);\r\n        const accessTokenHasNotExpired = this.tokenValidationService.validateAccessTokenNotExpired(accessTokenExpiresIn, configId, renewTimeBeforeTokenExpiresInSeconds);\r\n        const hasExpired = !accessTokenHasNotExpired;\r\n        if (hasExpired) {\r\n            this.publicEventsService.fireEvent(EventTypes.TokenExpired, hasExpired);\r\n        }\r\n        return hasExpired;\r\n    }\r\n    isAuthenticated(configId) {\r\n        return !!this.storagePersistenceService.getAccessToken(configId) && !!this.storagePersistenceService.getIdToken(configId);\r\n    }\r\n    decodeURIComponentSafely(token) {\r\n        if (token) {\r\n            return decodeURIComponent(token);\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    }\r\n    persistAccessTokenExpirationTime(authResult, configId) {\r\n        if (authResult === null || authResult === void 0 ? void 0 : authResult.expires_in) {\r\n            const accessTokenExpiryTime = new Date(new Date().toUTCString()).valueOf() + authResult.expires_in * 1000;\r\n            this.storagePersistenceService.write('access_token_expires_at', accessTokenExpiryTime, configId);\r\n        }\r\n    }\r\n    composeAuthenticatedResult() {\r\n        if (!this.configurationProvider.hasManyConfigs()) {\r\n            const { configId } = this.configurationProvider.getOpenIDConfiguration();\r\n            return { isAuthenticated: true, allConfigsAuthenticated: [{ configId, isAuthenticated: true }] };\r\n        }\r\n        return this.checkAllConfigsIfTheyAreAuthenticated();\r\n    }\r\n    composeUnAuthenticatedResult() {\r\n        if (!this.configurationProvider.hasManyConfigs()) {\r\n            const { configId } = this.configurationProvider.getOpenIDConfiguration();\r\n            return { isAuthenticated: false, allConfigsAuthenticated: [{ configId, isAuthenticated: false }] };\r\n        }\r\n        return this.checkAllConfigsIfTheyAreAuthenticated();\r\n    }\r\n    checkAllConfigsIfTheyAreAuthenticated() {\r\n        const configs = this.configurationProvider.getAllConfigurations();\r\n        const allConfigsAuthenticated = configs.map(({ configId }) => ({\r\n            configId,\r\n            isAuthenticated: this.isAuthenticated(configId),\r\n        }));\r\n        const isAuthenticated = allConfigsAuthenticated.every((x) => !!x.isAuthenticated);\r\n        return { allConfigsAuthenticated, isAuthenticated };\r\n    }\r\n}\r\nAuthStateService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: AuthStateService, deps: [{ token: StoragePersistenceService }, { token: LoggerService }, { token: PublicEventsService }, { token: ConfigurationProvider }, { token: TokenValidationService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAuthStateService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: AuthStateService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: AuthStateService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: LoggerService }, { type: PublicEventsService }, { type: ConfigurationProvider }, { type: TokenValidationService }]; } });\n\nconst STORAGE_KEY = 'redirect';\r\nclass AutoLoginService {\r\n    constructor(storageService, router) {\r\n        this.storageService = storageService;\r\n        this.router = router;\r\n    }\r\n    checkSavedRedirectRouteAndNavigate(configId) {\r\n        const savedRouteForRedirect = this.getStoredRedirectRoute(configId);\r\n        if (savedRouteForRedirect) {\r\n            this.deleteStoredRedirectRoute(configId);\r\n            this.router.navigateByUrl(savedRouteForRedirect);\r\n        }\r\n    }\r\n    /**\r\n     * Saves the redirect URL to storage.\r\n     *\r\n     * @param url The redirect URL to save.\r\n     */\r\n    saveRedirectRoute(configId, url) {\r\n        this.storageService.write(STORAGE_KEY, url, configId);\r\n    }\r\n    /**\r\n     * Gets the stored redirect URL from storage.\r\n     */\r\n    getStoredRedirectRoute(configId) {\r\n        return this.storageService.read(STORAGE_KEY, configId);\r\n    }\r\n    /**\r\n     * Removes the redirect URL from storage.\r\n     */\r\n    deleteStoredRedirectRoute(configId) {\r\n        this.storageService.remove(STORAGE_KEY, configId);\r\n    }\r\n}\r\nAutoLoginService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: AutoLoginService, deps: [{ token: StoragePersistenceService }, { token: i2.Router }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAutoLoginService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: AutoLoginService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: AutoLoginService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: i2.Router }]; } });\n\nclass UriEncoder {\r\n    encodeKey(key) {\r\n        return encodeURIComponent(key);\r\n    }\r\n    encodeValue(value) {\r\n        return encodeURIComponent(value);\r\n    }\r\n    decodeKey(key) {\r\n        return decodeURIComponent(key);\r\n    }\r\n    decodeValue(value) {\r\n        return decodeURIComponent(value);\r\n    }\r\n}\n\nclass RandomService {\r\n    constructor(doc, loggerService) {\r\n        this.doc = doc;\r\n        this.loggerService = loggerService;\r\n    }\r\n    createRandom(requiredLength, configId) {\r\n        if (requiredLength <= 0) {\r\n            return '';\r\n        }\r\n        if (requiredLength > 0 && requiredLength < 7) {\r\n            this.loggerService.logWarning(configId, `RandomService called with ${requiredLength} but 7 chars is the minimum, returning 10 chars`);\r\n            requiredLength = 10;\r\n        }\r\n        const length = requiredLength - 6;\r\n        const arr = new Uint8Array(Math.floor((length || length) / 2));\r\n        if (this.getCrypto()) {\r\n            this.getCrypto().getRandomValues(arr);\r\n        }\r\n        return Array.from(arr, this.toHex).join('') + this.randomString(7);\r\n    }\r\n    toHex(dec) {\r\n        return ('0' + dec.toString(16)).substr(-2);\r\n    }\r\n    randomString(length) {\r\n        let result = '';\r\n        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\r\n        const values = new Uint32Array(length);\r\n        if (this.getCrypto()) {\r\n            this.getCrypto().getRandomValues(values);\r\n            for (let i = 0; i < length; i++) {\r\n                result += characters[values[i] % characters.length];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    getCrypto() {\r\n        // support for IE,  (window.crypto || window.msCrypto)\r\n        return this.doc.defaultView.crypto || this.doc.defaultView.msCrypto;\r\n    }\r\n}\r\nRandomService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: RandomService, deps: [{ token: DOCUMENT }, { token: LoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRandomService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: RandomService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: RandomService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () {\r\n        return [{ type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [DOCUMENT]\r\n                    }] }, { type: LoggerService }];\r\n    } });\n\nclass FlowsDataService {\r\n    constructor(storagePersistenceService, randomService, configurationProvider, loggerService) {\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.randomService = randomService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.loggerService = loggerService;\r\n    }\r\n    createNonce(configId) {\r\n        const nonce = this.randomService.createRandom(40, configId);\r\n        this.loggerService.logDebug(configId, 'Nonce created. nonce:' + nonce);\r\n        this.setNonce(nonce, configId);\r\n        return nonce;\r\n    }\r\n    setNonce(nonce, configId) {\r\n        this.storagePersistenceService.write('authNonce', nonce, configId);\r\n    }\r\n    getAuthStateControl(configId) {\r\n        return this.storagePersistenceService.read('authStateControl', configId);\r\n    }\r\n    setAuthStateControl(authStateControl, configId) {\r\n        this.storagePersistenceService.write('authStateControl', authStateControl, configId);\r\n    }\r\n    getExistingOrCreateAuthStateControl(configId) {\r\n        let state = this.storagePersistenceService.read('authStateControl', configId);\r\n        if (!state) {\r\n            state = this.randomService.createRandom(40, configId);\r\n            this.storagePersistenceService.write('authStateControl', state, configId);\r\n        }\r\n        return state;\r\n    }\r\n    setSessionState(sessionState, configId) {\r\n        this.storagePersistenceService.write('session_state', sessionState, configId);\r\n    }\r\n    resetStorageFlowData(configId) {\r\n        this.storagePersistenceService.resetStorageFlowData(configId);\r\n    }\r\n    getCodeVerifier(configId) {\r\n        return this.storagePersistenceService.read('codeVerifier', configId);\r\n    }\r\n    createCodeVerifier(configId) {\r\n        const codeVerifier = this.randomService.createRandom(67, configId);\r\n        this.storagePersistenceService.write('codeVerifier', codeVerifier, configId);\r\n        return codeVerifier;\r\n    }\r\n    isSilentRenewRunning(configId) {\r\n        const storageObject = this.getSilentRenewRunningStorageEntry(configId);\r\n        if (!storageObject) {\r\n            return false;\r\n        }\r\n        const { silentRenewTimeoutInSeconds } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        const timeOutInMilliseconds = silentRenewTimeoutInSeconds * 1000;\r\n        const dateOfLaunchedProcessUtc = Date.parse(storageObject.dateOfLaunchedProcessUtc);\r\n        const currentDateUtc = Date.parse(new Date().toISOString());\r\n        const elapsedTimeInMilliseconds = Math.abs(currentDateUtc - dateOfLaunchedProcessUtc);\r\n        const isProbablyStuck = elapsedTimeInMilliseconds > timeOutInMilliseconds;\r\n        if (isProbablyStuck) {\r\n            this.loggerService.logDebug(configId, 'silent renew process is probably stuck, state will be reset.', configId);\r\n            this.resetSilentRenewRunning(configId);\r\n            return false;\r\n        }\r\n        return storageObject.state === 'running';\r\n    }\r\n    setSilentRenewRunning(configId) {\r\n        const storageObject = {\r\n            state: 'running',\r\n            dateOfLaunchedProcessUtc: new Date().toISOString(),\r\n        };\r\n        this.storagePersistenceService.write('storageSilentRenewRunning', JSON.stringify(storageObject), configId);\r\n    }\r\n    resetSilentRenewRunning(configId) {\r\n        this.storagePersistenceService.write('storageSilentRenewRunning', '', configId);\r\n    }\r\n    getSilentRenewRunningStorageEntry(configId) {\r\n        const storageEntry = this.storagePersistenceService.read('storageSilentRenewRunning', configId);\r\n        if (!storageEntry) {\r\n            return null;\r\n        }\r\n        return JSON.parse(storageEntry);\r\n    }\r\n}\r\nFlowsDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: FlowsDataService, deps: [{ token: StoragePersistenceService }, { token: RandomService }, { token: ConfigurationProvider }, { token: LoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nFlowsDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: FlowsDataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: FlowsDataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: RandomService }, { type: ConfigurationProvider }, { type: LoggerService }]; } });\n\nclass FlowHelper {\r\n    constructor(configurationProvider) {\r\n        this.configurationProvider = configurationProvider;\r\n    }\r\n    isCurrentFlowCodeFlow(configId) {\r\n        return this.currentFlowIs('code', configId);\r\n    }\r\n    isCurrentFlowAnyImplicitFlow(configId) {\r\n        return this.isCurrentFlowImplicitFlowWithAccessToken(configId) || this.isCurrentFlowImplicitFlowWithoutAccessToken(configId);\r\n    }\r\n    isCurrentFlowCodeFlowWithRefreshTokens(configId) {\r\n        const { useRefreshToken } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (this.isCurrentFlowCodeFlow(configId) && useRefreshToken) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    isCurrentFlowImplicitFlowWithAccessToken(configId) {\r\n        return this.currentFlowIs('id_token token', configId);\r\n    }\r\n    currentFlowIs(flowTypes, configId) {\r\n        const { responseType } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (Array.isArray(flowTypes)) {\r\n            return flowTypes.some((x) => responseType === x);\r\n        }\r\n        return responseType === flowTypes;\r\n    }\r\n    isCurrentFlowImplicitFlowWithoutAccessToken(configId) {\r\n        return this.currentFlowIs('id_token', configId);\r\n    }\r\n}\r\nFlowHelper.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: FlowHelper, deps: [{ token: ConfigurationProvider }], target: i0.ɵɵFactoryTarget.Injectable });\r\nFlowHelper.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: FlowHelper });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: FlowHelper, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: ConfigurationProvider }]; } });\n\nconst CALLBACK_PARAMS_TO_CHECK = ['code', 'state', 'token', 'id_token'];\r\nconst AUTH0_ENDPOINT = 'auth0.com';\r\nclass UrlService {\r\n    constructor(configurationProvider, loggerService, flowsDataService, flowHelper, storagePersistenceService, jwtWindowCryptoService) {\r\n        this.configurationProvider = configurationProvider;\r\n        this.loggerService = loggerService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.flowHelper = flowHelper;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.jwtWindowCryptoService = jwtWindowCryptoService;\r\n    }\r\n    getUrlParameter(urlToCheck, name) {\r\n        if (!urlToCheck) {\r\n            return '';\r\n        }\r\n        if (!name) {\r\n            return '';\r\n        }\r\n        name = name.replace(/[\\[]/, '\\\\[').replace(/[\\]]/, '\\\\]');\r\n        const regex = new RegExp('[\\\\?&]' + name + '=([^&#]*)');\r\n        const results = regex.exec(urlToCheck);\r\n        return results === null ? '' : decodeURIComponent(results[1]);\r\n    }\r\n    isCallbackFromSts(currentUrl) {\r\n        return CALLBACK_PARAMS_TO_CHECK.some((x) => !!this.getUrlParameter(currentUrl, x));\r\n    }\r\n    getRefreshSessionSilentRenewUrl(configId, customParams) {\r\n        if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\r\n            return this.createUrlCodeFlowWithSilentRenew(configId, customParams);\r\n        }\r\n        return of(this.createUrlImplicitFlowWithSilentRenew(configId, customParams) || '');\r\n    }\r\n    getAuthorizeParUrl(requestUri, configId) {\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        if (!authWellKnownEndPoints) {\r\n            this.loggerService.logError(configId, 'authWellKnownEndpoints is undefined');\r\n            return null;\r\n        }\r\n        const authorizationEndpoint = authWellKnownEndPoints.authorizationEndpoint;\r\n        if (!authorizationEndpoint) {\r\n            this.loggerService.logError(configId, `Can not create an authorize URL when authorizationEndpoint is '${authorizationEndpoint}'`);\r\n            return null;\r\n        }\r\n        const { clientId } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!clientId) {\r\n            this.loggerService.logError(configId, `getAuthorizeParUrl could not add clientId because it was: `, clientId);\r\n            return null;\r\n        }\r\n        const urlParts = authorizationEndpoint.split('?');\r\n        const authorizationUrl = urlParts[0];\r\n        const existingParams = urlParts[1];\r\n        let params = this.createHttpParams(existingParams);\r\n        params = params.set('request_uri', requestUri);\r\n        params = params.append('client_id', clientId);\r\n        return `${authorizationUrl}?${params}`;\r\n    }\r\n    getAuthorizeUrl(configId, customParams) {\r\n        if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\r\n            return this.createUrlCodeFlowAuthorize(configId, customParams);\r\n        }\r\n        return of(this.createUrlImplicitFlowAuthorize(configId, customParams) || '');\r\n    }\r\n    createEndSessionUrl(idTokenHint, configId, customParamsEndSession) {\r\n        // Auth0 needs a special logout url\r\n        // See https://auth0.com/docs/api/authentication#logout\r\n        if (this.isAuth0Endpoint(configId)) {\r\n            return this.composeAuth0Endpoint(configId);\r\n        }\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        const endSessionEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.endSessionEndpoint;\r\n        if (!endSessionEndpoint) {\r\n            return null;\r\n        }\r\n        const urlParts = endSessionEndpoint.split('?');\r\n        const authorizationEndSessionUrl = urlParts[0];\r\n        const existingParams = urlParts[1];\r\n        let params = this.createHttpParams(existingParams);\r\n        params = params.set('id_token_hint', idTokenHint);\r\n        const postLogoutRedirectUri = this.getPostLogoutRedirectUrl(configId);\r\n        if (postLogoutRedirectUri) {\r\n            params = params.append('post_logout_redirect_uri', postLogoutRedirectUri);\r\n        }\r\n        if (customParamsEndSession) {\r\n            params = this.appendCustomParams(Object.assign({}, customParamsEndSession), params);\r\n        }\r\n        return `${authorizationEndSessionUrl}?${params}`;\r\n    }\r\n    createRevocationEndpointBodyAccessToken(token, configId) {\r\n        const clientId = this.getClientId(configId);\r\n        if (!clientId) {\r\n            return null;\r\n        }\r\n        let params = this.createHttpParams();\r\n        params = params.set('client_id', clientId);\r\n        params = params.set('token', token);\r\n        params = params.set('token_type_hint', 'access_token');\r\n        return params.toString();\r\n    }\r\n    createRevocationEndpointBodyRefreshToken(token, configId) {\r\n        const clientId = this.getClientId(configId);\r\n        if (!clientId) {\r\n            return null;\r\n        }\r\n        let params = this.createHttpParams();\r\n        params = params.set('client_id', clientId);\r\n        params = params.set('token', token);\r\n        params = params.set('token_type_hint', 'refresh_token');\r\n        return params.toString();\r\n    }\r\n    getRevocationEndpointUrl(configId) {\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        const revocationEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.revocationEndpoint;\r\n        if (!revocationEndpoint) {\r\n            return null;\r\n        }\r\n        const urlParts = revocationEndpoint.split('?');\r\n        const revocationEndpointUrl = urlParts[0];\r\n        return revocationEndpointUrl;\r\n    }\r\n    createBodyForCodeFlowCodeRequest(code, configId, customTokenParams) {\r\n        const codeVerifier = this.flowsDataService.getCodeVerifier(configId);\r\n        if (!codeVerifier) {\r\n            this.loggerService.logError(configId, `CodeVerifier is not set `, codeVerifier);\r\n            return null;\r\n        }\r\n        const clientId = this.getClientId(configId);\r\n        if (!clientId) {\r\n            return null;\r\n        }\r\n        let params = this.createHttpParams();\r\n        params = params.set('grant_type', 'authorization_code');\r\n        params = params.set('client_id', clientId);\r\n        params = params.set('code_verifier', codeVerifier);\r\n        params = params.set('code', code);\r\n        if (customTokenParams) {\r\n            params = this.appendCustomParams(Object.assign({}, customTokenParams), params);\r\n        }\r\n        const silentRenewUrl = this.getSilentRenewUrl(configId);\r\n        if (this.flowsDataService.isSilentRenewRunning(configId) && silentRenewUrl) {\r\n            params = params.set('redirect_uri', silentRenewUrl);\r\n            return params.toString();\r\n        }\r\n        const redirectUrl = this.getRedirectUrl(configId);\r\n        if (!redirectUrl) {\r\n            return null;\r\n        }\r\n        params = params.set('redirect_uri', redirectUrl);\r\n        return params.toString();\r\n    }\r\n    createBodyForCodeFlowRefreshTokensRequest(refreshToken, configId, customParamsRefresh) {\r\n        const clientId = this.getClientId(configId);\r\n        if (!clientId) {\r\n            return null;\r\n        }\r\n        let params = this.createHttpParams();\r\n        params = params.set('grant_type', 'refresh_token');\r\n        params = params.set('client_id', clientId);\r\n        params = params.set('refresh_token', refreshToken);\r\n        if (customParamsRefresh) {\r\n            params = this.appendCustomParams(Object.assign({}, customParamsRefresh), params);\r\n        }\r\n        return params.toString();\r\n    }\r\n    createBodyForParCodeFlowRequest(configId, customParamsRequest) {\r\n        const redirectUrl = this.getRedirectUrl(configId);\r\n        if (!redirectUrl) {\r\n            return of(null);\r\n        }\r\n        const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\r\n        const nonce = this.flowsDataService.createNonce(configId);\r\n        this.loggerService.logDebug(configId, 'Authorize created. adding myautostate: ' + state);\r\n        // code_challenge with \"S256\"\r\n        const codeVerifier = this.flowsDataService.createCodeVerifier(configId);\r\n        return this.jwtWindowCryptoService.generateCodeChallenge(codeVerifier).pipe(map((codeChallenge) => {\r\n            const { clientId, responseType, scope, hdParam, customParamsAuthRequest } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n            let params = this.createHttpParams('');\r\n            params = params.set('client_id', clientId);\r\n            params = params.append('redirect_uri', redirectUrl);\r\n            params = params.append('response_type', responseType);\r\n            params = params.append('scope', scope);\r\n            params = params.append('nonce', nonce);\r\n            params = params.append('state', state);\r\n            params = params.append('code_challenge', codeChallenge);\r\n            params = params.append('code_challenge_method', 'S256');\r\n            if (hdParam) {\r\n                params = params.append('hd', hdParam);\r\n            }\r\n            if (customParamsAuthRequest) {\r\n                params = this.appendCustomParams(Object.assign({}, customParamsAuthRequest), params);\r\n            }\r\n            if (customParamsRequest) {\r\n                params = this.appendCustomParams(Object.assign({}, customParamsRequest), params);\r\n            }\r\n            return params.toString();\r\n        }));\r\n    }\r\n    createAuthorizeUrl(codeChallenge, redirectUrl, nonce, state, configId, prompt, customRequestParams) {\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        const authorizationEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.authorizationEndpoint;\r\n        if (!authorizationEndpoint) {\r\n            this.loggerService.logError(configId, `Can not create an authorize URL when authorizationEndpoint is '${authorizationEndpoint}'`);\r\n            return null;\r\n        }\r\n        const { clientId, responseType, scope, hdParam, customParamsAuthRequest } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!clientId) {\r\n            this.loggerService.logError(configId, `createAuthorizeUrl could not add clientId because it was: `, clientId);\r\n            return null;\r\n        }\r\n        if (!responseType) {\r\n            this.loggerService.logError(configId, `createAuthorizeUrl could not add responseType because it was: `, responseType);\r\n            return null;\r\n        }\r\n        if (!scope) {\r\n            this.loggerService.logError(configId, `createAuthorizeUrl could not add scope because it was: `, scope);\r\n            return null;\r\n        }\r\n        const urlParts = authorizationEndpoint.split('?');\r\n        const authorizationUrl = urlParts[0];\r\n        const existingParams = urlParts[1];\r\n        let params = this.createHttpParams(existingParams);\r\n        params = params.set('client_id', clientId);\r\n        params = params.append('redirect_uri', redirectUrl);\r\n        params = params.append('response_type', responseType);\r\n        params = params.append('scope', scope);\r\n        params = params.append('nonce', nonce);\r\n        params = params.append('state', state);\r\n        if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\r\n            params = params.append('code_challenge', codeChallenge);\r\n            params = params.append('code_challenge_method', 'S256');\r\n        }\r\n        const mergedParams = Object.assign(Object.assign({}, customParamsAuthRequest), customRequestParams);\r\n        if (Object.keys(mergedParams).length > 0) {\r\n            params = this.appendCustomParams(Object.assign({}, mergedParams), params);\r\n        }\r\n        if (prompt) {\r\n            params = this.overWriteParam(params, 'prompt', prompt);\r\n        }\r\n        if (hdParam) {\r\n            params = params.append('hd', hdParam);\r\n        }\r\n        return `${authorizationUrl}?${params}`;\r\n    }\r\n    createUrlImplicitFlowWithSilentRenew(configId, customParams) {\r\n        const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\r\n        const nonce = this.flowsDataService.createNonce(configId);\r\n        const silentRenewUrl = this.getSilentRenewUrl(configId);\r\n        if (!silentRenewUrl) {\r\n            return null;\r\n        }\r\n        this.loggerService.logDebug(configId, 'RefreshSession created. adding myautostate: ', state);\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        if (authWellKnownEndPoints) {\r\n            return this.createAuthorizeUrl('', silentRenewUrl, nonce, state, configId, 'none', customParams);\r\n        }\r\n        this.loggerService.logError(configId, 'authWellKnownEndpoints is undefined');\r\n        return null;\r\n    }\r\n    createUrlCodeFlowWithSilentRenew(configId, customParams) {\r\n        const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\r\n        const nonce = this.flowsDataService.createNonce(configId);\r\n        this.loggerService.logDebug(configId, 'RefreshSession created. adding myautostate: ' + state);\r\n        // code_challenge with \"S256\"\r\n        const codeVerifier = this.flowsDataService.createCodeVerifier(configId);\r\n        return this.jwtWindowCryptoService.generateCodeChallenge(codeVerifier).pipe(map((codeChallenge) => {\r\n            const silentRenewUrl = this.getSilentRenewUrl(configId);\r\n            if (!silentRenewUrl) {\r\n                return '';\r\n            }\r\n            const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n            if (authWellKnownEndPoints) {\r\n                return this.createAuthorizeUrl(codeChallenge, silentRenewUrl, nonce, state, configId, 'none', customParams);\r\n            }\r\n            this.loggerService.logWarning(configId, 'authWellKnownEndpoints is undefined');\r\n            return null;\r\n        }));\r\n    }\r\n    createUrlImplicitFlowAuthorize(configId, customParams) {\r\n        const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\r\n        const nonce = this.flowsDataService.createNonce(configId);\r\n        this.loggerService.logDebug(configId, 'Authorize created. adding myautostate: ' + state);\r\n        const redirectUrl = this.getRedirectUrl(configId);\r\n        if (!redirectUrl) {\r\n            return null;\r\n        }\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        if (authWellKnownEndPoints) {\r\n            return this.createAuthorizeUrl('', redirectUrl, nonce, state, configId, null, customParams);\r\n        }\r\n        this.loggerService.logError(configId, 'authWellKnownEndpoints is undefined');\r\n        return null;\r\n    }\r\n    createUrlCodeFlowAuthorize(configId, customParams) {\r\n        const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\r\n        const nonce = this.flowsDataService.createNonce(configId);\r\n        this.loggerService.logDebug(configId, 'Authorize created. adding myautostate: ' + state);\r\n        const redirectUrl = this.getRedirectUrl(configId);\r\n        if (!redirectUrl) {\r\n            return of(null);\r\n        }\r\n        // code_challenge with \"S256\"\r\n        const codeVerifier = this.flowsDataService.createCodeVerifier(configId);\r\n        return this.jwtWindowCryptoService.generateCodeChallenge(codeVerifier).pipe(map((codeChallenge) => {\r\n            const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n            if (authWellKnownEndPoints) {\r\n                return this.createAuthorizeUrl(codeChallenge, redirectUrl, nonce, state, configId, null, customParams);\r\n            }\r\n            this.loggerService.logError(configId, 'authWellKnownEndpoints is undefined');\r\n            return '';\r\n        }));\r\n    }\r\n    getRedirectUrl(configId) {\r\n        const { redirectUrl } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!redirectUrl) {\r\n            this.loggerService.logError(configId, `could not get redirectUrl, was: `, redirectUrl);\r\n            return null;\r\n        }\r\n        return redirectUrl;\r\n    }\r\n    getSilentRenewUrl(configId) {\r\n        const { silentRenewUrl } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!silentRenewUrl) {\r\n            this.loggerService.logError(configId, `could not get silentRenewUrl, was: `, silentRenewUrl);\r\n            return null;\r\n        }\r\n        return silentRenewUrl;\r\n    }\r\n    getPostLogoutRedirectUrl(configId) {\r\n        const { postLogoutRedirectUri } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!postLogoutRedirectUri) {\r\n            this.loggerService.logError(configId, `could not get postLogoutRedirectUri, was: `, postLogoutRedirectUri);\r\n            return null;\r\n        }\r\n        return postLogoutRedirectUri;\r\n    }\r\n    getClientId(configId) {\r\n        const { clientId } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!clientId) {\r\n            this.loggerService.logError(configId, `could not get clientId, was: `, clientId);\r\n            return null;\r\n        }\r\n        return clientId;\r\n    }\r\n    appendCustomParams(customParams, params) {\r\n        for (const [key, value] of Object.entries(Object.assign({}, customParams))) {\r\n            params = params.append(key, value.toString());\r\n        }\r\n        return params;\r\n    }\r\n    overWriteParam(params, key, value) {\r\n        return params.set(key, value);\r\n    }\r\n    createHttpParams(existingParams) {\r\n        existingParams = existingParams !== null && existingParams !== void 0 ? existingParams : '';\r\n        const params = new HttpParams({\r\n            fromString: existingParams,\r\n            encoder: new UriEncoder(),\r\n        });\r\n        return params;\r\n    }\r\n    isAuth0Endpoint(configId) {\r\n        const { authority } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!authority) {\r\n            return false;\r\n        }\r\n        return authority.endsWith(AUTH0_ENDPOINT);\r\n    }\r\n    composeAuth0Endpoint(configId) {\r\n        // format: https://YOUR_DOMAIN/v2/logout?client_id=YOUR_CLIENT_ID&returnTo=LOGOUT_URL\r\n        const { authority, clientId } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        const postLogoutRedirectUrl = this.getPostLogoutRedirectUrl(configId);\r\n        return `${authority}/v2/logout?client_id=${clientId}&returnTo=${postLogoutRedirectUrl}`;\r\n    }\r\n}\r\nUrlService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: UrlService, deps: [{ token: ConfigurationProvider }, { token: LoggerService }, { token: FlowsDataService }, { token: FlowHelper }, { token: StoragePersistenceService }, { token: JwtWindowCryptoService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nUrlService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: UrlService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: UrlService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: ConfigurationProvider }, { type: LoggerService }, { type: FlowsDataService }, { type: FlowHelper }, { type: StoragePersistenceService }, { type: JwtWindowCryptoService }]; } });\n\nclass CodeFlowCallbackHandlerService {\r\n    constructor(urlService, loggerService, tokenValidationService, flowsDataService, configurationProvider, storagePersistenceService, dataService) {\r\n        this.urlService = urlService;\r\n        this.loggerService = loggerService;\r\n        this.tokenValidationService = tokenValidationService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.dataService = dataService;\r\n    }\r\n    // STEP 1 Code Flow\r\n    codeFlowCallback(urlToCheck, configId) {\r\n        const code = this.urlService.getUrlParameter(urlToCheck, 'code');\r\n        const state = this.urlService.getUrlParameter(urlToCheck, 'state');\r\n        const sessionState = this.urlService.getUrlParameter(urlToCheck, 'session_state');\r\n        if (!state) {\r\n            this.loggerService.logDebug(configId, 'no state in url');\r\n            return throwError(() => new Error('no state in url'));\r\n        }\r\n        if (!code) {\r\n            this.loggerService.logDebug(configId, 'no code in url');\r\n            return throwError(() => new Error('no code in url'));\r\n        }\r\n        this.loggerService.logDebug(configId, 'running validation for callback', urlToCheck);\r\n        const initialCallbackContext = {\r\n            code,\r\n            refreshToken: null,\r\n            state,\r\n            sessionState,\r\n            authResult: null,\r\n            isRenewProcess: false,\r\n            jwtKeys: null,\r\n            validationResult: null,\r\n            existingIdToken: null,\r\n        };\r\n        return of(initialCallbackContext);\r\n    }\r\n    // STEP 2 Code Flow //  Code Flow Silent Renew starts here\r\n    codeFlowCodeRequest(callbackContext, configId) {\r\n        const authStateControl = this.flowsDataService.getAuthStateControl(configId);\r\n        const isStateCorrect = this.tokenValidationService.validateStateFromHashCallback(callbackContext.state, authStateControl, configId);\r\n        if (!isStateCorrect) {\r\n            return throwError(() => new Error('codeFlowCodeRequest incorrect state'));\r\n        }\r\n        const authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        const tokenEndpoint = authWellknownEndpoints === null || authWellknownEndpoints === void 0 ? void 0 : authWellknownEndpoints.tokenEndpoint;\r\n        if (!tokenEndpoint) {\r\n            return throwError(() => new Error('Token Endpoint not defined'));\r\n        }\r\n        let headers = new HttpHeaders();\r\n        headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\r\n        const config = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        const bodyForCodeFlow = this.urlService.createBodyForCodeFlowCodeRequest(callbackContext.code, configId, config === null || config === void 0 ? void 0 : config.customParamsCodeRequest);\r\n        return this.dataService.post(tokenEndpoint, bodyForCodeFlow, configId, headers).pipe(switchMap((response) => {\r\n            let authResult = new Object();\r\n            authResult = response;\r\n            authResult.state = callbackContext.state;\r\n            authResult.session_state = callbackContext.sessionState;\r\n            callbackContext.authResult = authResult;\r\n            return of(callbackContext);\r\n        }), retryWhen((error) => this.handleRefreshRetry(error, configId)), catchError((error) => {\r\n            const { authority } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n            const errorMessage = `OidcService code request ${authority}`;\r\n            this.loggerService.logError(configId, errorMessage, error);\r\n            return throwError(() => new Error(errorMessage));\r\n        }));\r\n    }\r\n    handleRefreshRetry(errors, configId) {\r\n        return errors.pipe(mergeMap((error) => {\r\n            // retry token refresh if there is no internet connection\r\n            if (error && error instanceof HttpErrorResponse && error.error instanceof ProgressEvent && error.error.type === 'error') {\r\n                const { authority, refreshTokenRetryInSeconds } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n                const errorMessage = `OidcService code request ${authority} - no internet connection`;\r\n                this.loggerService.logWarning(configId, errorMessage, error);\r\n                return timer(refreshTokenRetryInSeconds * 1000);\r\n            }\r\n            return throwError(() => new Error(error));\r\n        }));\r\n    }\r\n}\r\nCodeFlowCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CodeFlowCallbackHandlerService, deps: [{ token: UrlService }, { token: LoggerService }, { token: TokenValidationService }, { token: FlowsDataService }, { token: ConfigurationProvider }, { token: StoragePersistenceService }, { token: DataService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCodeFlowCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CodeFlowCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CodeFlowCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: UrlService }, { type: LoggerService }, { type: TokenValidationService }, { type: FlowsDataService }, { type: ConfigurationProvider }, { type: StoragePersistenceService }, { type: DataService }]; } });\n\nconst DEFAULT_USERRESULT = { userData: null, allUserData: [] };\r\nclass UserService {\r\n    constructor(oidcDataService, storagePersistenceService, eventService, loggerService, tokenHelperService, flowHelper, configurationProvider) {\r\n        this.oidcDataService = oidcDataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.eventService = eventService;\r\n        this.loggerService = loggerService;\r\n        this.tokenHelperService = tokenHelperService;\r\n        this.flowHelper = flowHelper;\r\n        this.configurationProvider = configurationProvider;\r\n        this.userDataInternal$ = new BehaviorSubject(DEFAULT_USERRESULT);\r\n    }\r\n    get userData$() {\r\n        return this.userDataInternal$.asObservable();\r\n    }\r\n    getAndPersistUserDataInStore(configId, isRenewProcess = false, idToken, decodedIdToken) {\r\n        idToken = idToken || this.storagePersistenceService.getIdToken(configId);\r\n        decodedIdToken = decodedIdToken || this.tokenHelperService.getPayloadFromToken(idToken, false, configId);\r\n        const existingUserDataFromStorage = this.getUserDataFromStore(configId);\r\n        const haveUserData = !!existingUserDataFromStorage;\r\n        const isCurrentFlowImplicitFlowWithAccessToken = this.flowHelper.isCurrentFlowImplicitFlowWithAccessToken(configId);\r\n        const isCurrentFlowCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(configId);\r\n        const accessToken = this.storagePersistenceService.getAccessToken(configId);\r\n        if (!(isCurrentFlowImplicitFlowWithAccessToken || isCurrentFlowCodeFlow)) {\r\n            this.loggerService.logDebug(configId, `authCallback idToken flow with accessToken ${accessToken}`);\r\n            this.setUserDataToStore(decodedIdToken, configId);\r\n            return of(decodedIdToken);\r\n        }\r\n        const { renewUserInfoAfterTokenRenew } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!isRenewProcess || renewUserInfoAfterTokenRenew || !haveUserData) {\r\n            return this.getUserDataOidcFlowAndSave(decodedIdToken.sub, configId).pipe(switchMap((userData) => {\r\n                this.loggerService.logDebug(configId, 'Received user data: ', userData);\r\n                if (!!userData) {\r\n                    this.loggerService.logDebug(configId, 'accessToken: ', accessToken);\r\n                    return of(userData);\r\n                }\r\n                else {\r\n                    return throwError(() => new Error('Received no user data, request failed'));\r\n                }\r\n            }));\r\n        }\r\n        return of(existingUserDataFromStorage);\r\n    }\r\n    getUserDataFromStore(configId) {\r\n        return this.storagePersistenceService.read('userData', configId) || null;\r\n    }\r\n    publishUserDataIfExists(configId) {\r\n        const userData = this.getUserDataFromStore(configId);\r\n        if (userData) {\r\n            this.fireUserDataEvent(configId, userData);\r\n        }\r\n    }\r\n    setUserDataToStore(userData, configId) {\r\n        this.storagePersistenceService.write('userData', userData, configId);\r\n        this.fireUserDataEvent(configId, userData);\r\n    }\r\n    resetUserDataInStore(configId) {\r\n        this.storagePersistenceService.remove('userData', configId);\r\n        this.fireUserDataEvent(configId, null);\r\n    }\r\n    getUserDataOidcFlowAndSave(idTokenSub, configId) {\r\n        return this.getIdentityUserData(configId).pipe(map((data) => {\r\n            if (this.validateUserDataSubIdToken(idTokenSub, data === null || data === void 0 ? void 0 : data.sub)) {\r\n                this.setUserDataToStore(data, configId);\r\n                return data;\r\n            }\r\n            else {\r\n                // something went wrong, user data sub does not match that from id_token\r\n                this.loggerService.logWarning(configId, `User data sub does not match sub in id_token, resetting`);\r\n                this.resetUserDataInStore(configId);\r\n                return null;\r\n            }\r\n        }));\r\n    }\r\n    getIdentityUserData(configId) {\r\n        const token = this.storagePersistenceService.getAccessToken(configId);\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        if (!authWellKnownEndPoints) {\r\n            this.loggerService.logWarning(configId, 'init check session: authWellKnownEndpoints is undefined');\r\n            return throwError(() => new Error('authWellKnownEndpoints is undefined'));\r\n        }\r\n        const userInfoEndpoint = authWellKnownEndPoints.userInfoEndpoint;\r\n        if (!userInfoEndpoint) {\r\n            this.loggerService.logError(configId, 'init check session: authWellKnownEndpoints.userinfo_endpoint is undefined; set auto_userinfo = false in config');\r\n            return throwError(() => new Error('authWellKnownEndpoints.userinfo_endpoint is undefined'));\r\n        }\r\n        return this.oidcDataService.get(userInfoEndpoint, configId, token).pipe(retry(2));\r\n    }\r\n    validateUserDataSubIdToken(idTokenSub, userDataSub) {\r\n        if (!idTokenSub) {\r\n            return false;\r\n        }\r\n        if (!userDataSub) {\r\n            return false;\r\n        }\r\n        if (idTokenSub !== userDataSub) {\r\n            this.loggerService.logDebug('validateUserDataSubIdToken failed', idTokenSub, userDataSub);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    fireUserDataEvent(configId, passedUserData) {\r\n        const userData = this.composeSingleOrMultipleUserDataObject(configId, passedUserData);\r\n        this.userDataInternal$.next(userData);\r\n        this.eventService.fireEvent(EventTypes.UserDataChanged, { configId, userData: passedUserData });\r\n    }\r\n    composeSingleOrMultipleUserDataObject(configId, passedUserData) {\r\n        const hasManyConfigs = this.configurationProvider.hasManyConfigs();\r\n        if (!hasManyConfigs) {\r\n            return this.composeSingleUserDataResult(configId, passedUserData);\r\n        }\r\n        const configs = this.configurationProvider.getAllConfigurations();\r\n        const allUserData = configs.map((config) => {\r\n            if (this.currentConfigIsToUpdate(configId, config)) {\r\n                return { configId: config.configId, userData: passedUserData };\r\n            }\r\n            const alreadySavedUserData = this.storagePersistenceService.read('userData', config.configId) || null;\r\n            return { configId: config.configId, userData: alreadySavedUserData };\r\n        });\r\n        return {\r\n            userData: null,\r\n            allUserData,\r\n        };\r\n    }\r\n    composeSingleUserDataResult(configId, userData) {\r\n        return {\r\n            userData,\r\n            allUserData: [{ configId, userData }],\r\n        };\r\n    }\r\n    currentConfigIsToUpdate(configId, config) {\r\n        return config.configId === configId;\r\n    }\r\n}\r\nUserService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: UserService, deps: [{ token: DataService }, { token: StoragePersistenceService }, { token: PublicEventsService }, { token: LoggerService }, { token: TokenHelperService }, { token: FlowHelper }, { token: ConfigurationProvider }], target: i0.ɵɵFactoryTarget.Injectable });\r\nUserService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: UserService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: UserService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: DataService }, { type: StoragePersistenceService }, { type: PublicEventsService }, { type: LoggerService }, { type: TokenHelperService }, { type: FlowHelper }, { type: ConfigurationProvider }]; } });\n\nclass ResetAuthDataService {\r\n    constructor(authStateService, flowsDataService, userService) {\r\n        this.authStateService = authStateService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.userService = userService;\r\n    }\r\n    resetAuthorizationData(configId) {\r\n        this.userService.resetUserDataInStore(configId);\r\n        this.flowsDataService.resetStorageFlowData(configId);\r\n        this.authStateService.setUnauthenticatedAndFireEvent(configId);\r\n    }\r\n}\r\nResetAuthDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: ResetAuthDataService, deps: [{ token: AuthStateService }, { token: FlowsDataService }, { token: UserService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nResetAuthDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: ResetAuthDataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: ResetAuthDataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: AuthStateService }, { type: FlowsDataService }, { type: UserService }]; } });\n\nclass ImplicitFlowCallbackHandlerService {\r\n    constructor(resetAuthDataService, loggerService, flowsDataService, doc) {\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.loggerService = loggerService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.doc = doc;\r\n    }\r\n    // STEP 1 Code Flow\r\n    // STEP 1 Implicit Flow\r\n    implicitFlowCallback(configId, hash) {\r\n        const isRenewProcessData = this.flowsDataService.isSilentRenewRunning(configId);\r\n        this.loggerService.logDebug(configId, 'BEGIN callback, no auth data');\r\n        if (!isRenewProcessData) {\r\n            this.resetAuthDataService.resetAuthorizationData(configId);\r\n        }\r\n        hash = hash || this.doc.location.hash.substr(1);\r\n        const authResult = hash.split('&').reduce((resultData, item) => {\r\n            const parts = item.split('=');\r\n            resultData[parts.shift()] = parts.join('=');\r\n            return resultData;\r\n        }, {});\r\n        const callbackContext = {\r\n            code: null,\r\n            refreshToken: null,\r\n            state: null,\r\n            sessionState: null,\r\n            authResult,\r\n            isRenewProcess: isRenewProcessData,\r\n            jwtKeys: null,\r\n            validationResult: null,\r\n            existingIdToken: null,\r\n        };\r\n        return of(callbackContext);\r\n    }\r\n}\r\nImplicitFlowCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: ImplicitFlowCallbackHandlerService, deps: [{ token: ResetAuthDataService }, { token: LoggerService }, { token: FlowsDataService }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nImplicitFlowCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: ImplicitFlowCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: ImplicitFlowCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () {\r\n        return [{ type: ResetAuthDataService }, { type: LoggerService }, { type: FlowsDataService }, { type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [DOCUMENT]\r\n                    }] }];\r\n    } });\n\n/* eslint-disable no-shadow */\r\nvar ValidationResult;\r\n(function (ValidationResult) {\r\n    ValidationResult[\"NotSet\"] = \"NotSet\";\r\n    ValidationResult[\"StatesDoNotMatch\"] = \"StatesDoNotMatch\";\r\n    ValidationResult[\"SignatureFailed\"] = \"SignatureFailed\";\r\n    ValidationResult[\"IncorrectNonce\"] = \"IncorrectNonce\";\r\n    ValidationResult[\"RequiredPropertyMissing\"] = \"RequiredPropertyMissing\";\r\n    ValidationResult[\"MaxOffsetExpired\"] = \"MaxOffsetExpired\";\r\n    ValidationResult[\"IssDoesNotMatchIssuer\"] = \"IssDoesNotMatchIssuer\";\r\n    ValidationResult[\"NoAuthWellKnownEndPoints\"] = \"NoAuthWellKnownEndPoints\";\r\n    ValidationResult[\"IncorrectAud\"] = \"IncorrectAud\";\r\n    ValidationResult[\"IncorrectIdTokenClaimsAfterRefresh\"] = \"IncorrectIdTokenClaimsAfterRefresh\";\r\n    ValidationResult[\"IncorrectAzp\"] = \"IncorrectAzp\";\r\n    ValidationResult[\"TokenExpired\"] = \"TokenExpired\";\r\n    ValidationResult[\"IncorrectAtHash\"] = \"IncorrectAtHash\";\r\n    ValidationResult[\"Ok\"] = \"Ok\";\r\n    ValidationResult[\"LoginRequired\"] = \"LoginRequired\";\r\n    ValidationResult[\"SecureTokenServerError\"] = \"SecureTokenServerError\";\r\n})(ValidationResult || (ValidationResult = {}));\n\nclass SigninKeyDataService {\r\n    constructor(storagePersistenceService, loggerService, dataService) {\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.loggerService = loggerService;\r\n        this.dataService = dataService;\r\n    }\r\n    getSigningKeys(configId) {\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        const jwksUri = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.jwksUri;\r\n        if (!jwksUri) {\r\n            const error = `getSigningKeys: authWellKnownEndpoints.jwksUri is: '${jwksUri}'`;\r\n            this.loggerService.logWarning(configId, error);\r\n            return throwError(() => new Error(error));\r\n        }\r\n        this.loggerService.logDebug(configId, 'Getting signinkeys from ', jwksUri);\r\n        return this.dataService.get(jwksUri, configId).pipe(retry(2), catchError((e) => this.handleErrorGetSigningKeys(e, configId)));\r\n    }\r\n    handleErrorGetSigningKeys(errorResponse, configId) {\r\n        let errMsg = '';\r\n        if (errorResponse instanceof HttpResponse) {\r\n            const body = errorResponse.body || {};\r\n            const err = JSON.stringify(body);\r\n            const { status, statusText } = errorResponse;\r\n            errMsg = `${status || ''} - ${statusText || ''} ${err || ''}`;\r\n        }\r\n        else {\r\n            const { message } = errorResponse;\r\n            errMsg = !!message ? message : `${errorResponse}`;\r\n        }\r\n        this.loggerService.logError(configId, errMsg);\r\n        return throwError(() => new Error(errMsg));\r\n    }\r\n}\r\nSigninKeyDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: SigninKeyDataService, deps: [{ token: StoragePersistenceService }, { token: LoggerService }, { token: DataService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nSigninKeyDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: SigninKeyDataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: SigninKeyDataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: LoggerService }, { type: DataService }]; } });\n\nconst JWT_KEYS = 'jwtKeys';\r\nclass HistoryJwtKeysCallbackHandlerService {\r\n    constructor(loggerService, configurationProvider, authStateService, flowsDataService, signInKeyDataService, storagePersistenceService, resetAuthDataService) {\r\n        this.loggerService = loggerService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.authStateService = authStateService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.signInKeyDataService = signInKeyDataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n    }\r\n    // STEP 3 Code Flow, STEP 2 Implicit Flow, STEP 3 Refresh Token\r\n    callbackHistoryAndResetJwtKeys(callbackContext, configId) {\r\n        this.storagePersistenceService.write('authnResult', callbackContext.authResult, configId);\r\n        if (this.historyCleanUpTurnedOn(configId) && !callbackContext.isRenewProcess) {\r\n            this.resetBrowserHistory();\r\n        }\r\n        else {\r\n            this.loggerService.logDebug(configId, 'history clean up inactive');\r\n        }\r\n        if (callbackContext.authResult.error) {\r\n            const errorMessage = `AuthCallback AuthResult came with error: ${callbackContext.authResult.error}`;\r\n            this.loggerService.logDebug(configId, errorMessage);\r\n            this.resetAuthDataService.resetAuthorizationData(configId);\r\n            this.flowsDataService.setNonce('', configId);\r\n            this.handleResultErrorFromCallback(callbackContext.authResult, callbackContext.isRenewProcess);\r\n            return throwError(() => new Error(errorMessage));\r\n        }\r\n        this.loggerService.logDebug(configId, `AuthResult '${JSON.stringify(callbackContext.authResult, null, 2)}'.\n      AuthCallback created, begin token validation`);\r\n        return this.signInKeyDataService.getSigningKeys(configId).pipe(tap((jwtKeys) => this.storeSigningKeys(jwtKeys, configId)), catchError((err) => {\r\n            // fallback: try to load jwtKeys from storage\r\n            const storedJwtKeys = this.readSigningKeys(configId);\r\n            if (!!storedJwtKeys) {\r\n                this.loggerService.logWarning(configId, `Failed to retrieve signing keys, fallback to stored keys`);\r\n                return of(storedJwtKeys);\r\n            }\r\n            return throwError(() => new Error(err));\r\n        }), switchMap((jwtKeys) => {\r\n            if (jwtKeys) {\r\n                callbackContext.jwtKeys = jwtKeys;\r\n                return of(callbackContext);\r\n            }\r\n            const errorMessage = `Failed to retrieve signing key`;\r\n            this.loggerService.logWarning(configId, errorMessage);\r\n            return throwError(() => new Error(errorMessage));\r\n        }), catchError((err) => {\r\n            const errorMessage = `Failed to retrieve signing key with error: ${err}`;\r\n            this.loggerService.logWarning(configId, errorMessage);\r\n            return throwError(() => new Error(errorMessage));\r\n        }));\r\n    }\r\n    handleResultErrorFromCallback(result, isRenewProcess) {\r\n        let validationResult = ValidationResult.SecureTokenServerError;\r\n        if (result.error === 'login_required') {\r\n            validationResult = ValidationResult.LoginRequired;\r\n        }\r\n        this.authStateService.updateAndPublishAuthState({\r\n            isAuthenticated: false,\r\n            validationResult,\r\n            isRenewProcess,\r\n        });\r\n    }\r\n    historyCleanUpTurnedOn(configId) {\r\n        const { historyCleanupOff } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        return !historyCleanupOff;\r\n    }\r\n    resetBrowserHistory() {\r\n        window.history.replaceState({}, window.document.title, window.location.origin + window.location.pathname);\r\n    }\r\n    storeSigningKeys(jwtKeys, configId) {\r\n        this.storagePersistenceService.write(JWT_KEYS, jwtKeys, configId);\r\n    }\r\n    readSigningKeys(configId) {\r\n        return this.storagePersistenceService.read(JWT_KEYS, configId);\r\n    }\r\n}\r\nHistoryJwtKeysCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: HistoryJwtKeysCallbackHandlerService, deps: [{ token: LoggerService }, { token: ConfigurationProvider }, { token: AuthStateService }, { token: FlowsDataService }, { token: SigninKeyDataService }, { token: StoragePersistenceService }, { token: ResetAuthDataService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nHistoryJwtKeysCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: HistoryJwtKeysCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: HistoryJwtKeysCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: ConfigurationProvider }, { type: AuthStateService }, { type: FlowsDataService }, { type: SigninKeyDataService }, { type: StoragePersistenceService }, { type: ResetAuthDataService }]; } });\n\nclass UserCallbackHandlerService {\r\n    constructor(loggerService, configurationProvider, authStateService, flowsDataService, userService, resetAuthDataService) {\r\n        this.loggerService = loggerService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.authStateService = authStateService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.userService = userService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n    }\r\n    // STEP 5 userData\r\n    callbackUser(callbackContext, configId) {\r\n        const { isRenewProcess, validationResult, authResult, refreshToken } = callbackContext;\r\n        const { autoUserInfo, renewUserInfoAfterTokenRenew } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!autoUserInfo) {\r\n            if (!isRenewProcess || renewUserInfoAfterTokenRenew) {\r\n                // userData is set to the id_token decoded, auto get user data set to false\r\n                if (validationResult.decodedIdToken) {\r\n                    this.userService.setUserDataToStore(validationResult.decodedIdToken, configId);\r\n                }\r\n            }\r\n            if (!isRenewProcess && !refreshToken) {\r\n                this.flowsDataService.setSessionState(authResult.session_state, configId);\r\n            }\r\n            this.publishAuthState(validationResult, isRenewProcess);\r\n            return of(callbackContext);\r\n        }\r\n        return this.userService\r\n            .getAndPersistUserDataInStore(configId, isRenewProcess, validationResult.idToken, validationResult.decodedIdToken)\r\n            .pipe(switchMap((userData) => {\r\n            if (!!userData) {\r\n                if (!refreshToken) {\r\n                    this.flowsDataService.setSessionState(authResult.session_state, configId);\r\n                }\r\n                this.publishAuthState(validationResult, isRenewProcess);\r\n                return of(callbackContext);\r\n            }\r\n            else {\r\n                this.resetAuthDataService.resetAuthorizationData(configId);\r\n                this.publishUnauthenticatedState(validationResult, isRenewProcess);\r\n                const errorMessage = `Called for userData but they were ${userData}`;\r\n                this.loggerService.logWarning(configId, errorMessage);\r\n                return throwError(() => new Error(errorMessage));\r\n            }\r\n        }), catchError((err) => {\r\n            const errorMessage = `Failed to retrieve user info with error:  ${err}`;\r\n            this.loggerService.logWarning(configId, errorMessage);\r\n            return throwError(() => new Error(errorMessage));\r\n        }));\r\n    }\r\n    publishAuthState(stateValidationResult, isRenewProcess) {\r\n        this.authStateService.updateAndPublishAuthState({\r\n            isAuthenticated: true,\r\n            validationResult: stateValidationResult.state,\r\n            isRenewProcess,\r\n        });\r\n    }\r\n    publishUnauthenticatedState(stateValidationResult, isRenewProcess) {\r\n        this.authStateService.updateAndPublishAuthState({\r\n            isAuthenticated: false,\r\n            validationResult: stateValidationResult.state,\r\n            isRenewProcess,\r\n        });\r\n    }\r\n}\r\nUserCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: UserCallbackHandlerService, deps: [{ token: LoggerService }, { token: ConfigurationProvider }, { token: AuthStateService }, { token: FlowsDataService }, { token: UserService }, { token: ResetAuthDataService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nUserCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: UserCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: UserCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: ConfigurationProvider }, { type: AuthStateService }, { type: FlowsDataService }, { type: UserService }, { type: ResetAuthDataService }]; } });\n\nclass StateValidationResult {\r\n    constructor(accessToken = '', idToken = '', authResponseIsValid = false, decodedIdToken = {\r\n        at_hash: '',\r\n    }, state = ValidationResult.NotSet) {\r\n        this.accessToken = accessToken;\r\n        this.idToken = idToken;\r\n        this.authResponseIsValid = authResponseIsValid;\r\n        this.decodedIdToken = decodedIdToken;\r\n        this.state = state;\r\n    }\r\n}\n\nclass EqualityService {\r\n    isStringEqualOrNonOrderedArrayEqual(value1, value2) {\r\n        if (this.isNullOrUndefined(value1)) {\r\n            return false;\r\n        }\r\n        if (this.isNullOrUndefined(value2)) {\r\n            return false;\r\n        }\r\n        if (this.oneValueIsStringAndTheOtherIsArray(value1, value2)) {\r\n            return false;\r\n        }\r\n        if (this.bothValuesAreStrings(value1, value2)) {\r\n            return value1 === value2;\r\n        }\r\n        if (this.bothValuesAreArrays(value1, value2)) {\r\n            return this.arraysHaveEqualContent(value1, value2);\r\n        }\r\n        return false;\r\n    }\r\n    areEqual(value1, value2) {\r\n        if (!value1 || !value2) {\r\n            return false;\r\n        }\r\n        if (this.bothValuesAreArrays(value1, value2)) {\r\n            return this.arraysStrictEqual(value1, value2);\r\n        }\r\n        if (this.bothValuesAreStrings(value1, value2)) {\r\n            return value1 === value2;\r\n        }\r\n        if (this.bothValuesAreObjects(value1, value2)) {\r\n            return JSON.stringify(value1).toLowerCase() === JSON.stringify(value2).toLowerCase();\r\n        }\r\n        if (this.oneValueIsStringAndTheOtherIsArray(value1, value2)) {\r\n            if (Array.isArray(value1) && this.valueIsString(value2)) {\r\n                return value1[0] === value2;\r\n            }\r\n            if (Array.isArray(value2) && this.valueIsString(value1)) {\r\n                return value2[0] === value1;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    oneValueIsStringAndTheOtherIsArray(value1, value2) {\r\n        return (Array.isArray(value1) && this.valueIsString(value2)) || (Array.isArray(value2) && this.valueIsString(value1));\r\n    }\r\n    bothValuesAreObjects(value1, value2) {\r\n        return this.valueIsObject(value1) && this.valueIsObject(value2);\r\n    }\r\n    bothValuesAreStrings(value1, value2) {\r\n        return this.valueIsString(value1) && this.valueIsString(value2);\r\n    }\r\n    bothValuesAreArrays(value1, value2) {\r\n        return Array.isArray(value1) && Array.isArray(value2);\r\n    }\r\n    valueIsString(value) {\r\n        return typeof value === 'string' || value instanceof String;\r\n    }\r\n    valueIsObject(value) {\r\n        return typeof value === 'object';\r\n    }\r\n    arraysStrictEqual(arr1, arr2) {\r\n        if (arr1.length !== arr2.length) {\r\n            return false;\r\n        }\r\n        for (let i = arr1.length; i--;) {\r\n            if (arr1[i] !== arr2[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    arraysHaveEqualContent(arr1, arr2) {\r\n        if (arr1.length !== arr2.length) {\r\n            return false;\r\n        }\r\n        return arr1.some((v) => arr2.includes(v));\r\n    }\r\n    isNullOrUndefined(val) {\r\n        return val === null || val === undefined;\r\n    }\r\n}\r\nEqualityService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: EqualityService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nEqualityService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: EqualityService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: EqualityService, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nclass StateValidationService {\r\n    constructor(storagePersistenceService, tokenValidationService, tokenHelperService, loggerService, configurationProvider, equalityService, flowHelper) {\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.tokenValidationService = tokenValidationService;\r\n        this.tokenHelperService = tokenHelperService;\r\n        this.loggerService = loggerService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.equalityService = equalityService;\r\n        this.flowHelper = flowHelper;\r\n    }\r\n    getValidatedStateResult(callbackContext, configId) {\r\n        if (!callbackContext || callbackContext.authResult.error) {\r\n            return of(new StateValidationResult('', '', false, {}));\r\n        }\r\n        return this.validateState(callbackContext, configId);\r\n    }\r\n    validateState(callbackContext, configId) {\r\n        const toReturn = new StateValidationResult();\r\n        const authStateControl = this.storagePersistenceService.read('authStateControl', configId);\r\n        if (!this.tokenValidationService.validateStateFromHashCallback(callbackContext.authResult.state, authStateControl, configId)) {\r\n            this.loggerService.logWarning(configId, 'authCallback incorrect state');\r\n            toReturn.state = ValidationResult.StatesDoNotMatch;\r\n            this.handleUnsuccessfulValidation(configId);\r\n            return of(toReturn);\r\n        }\r\n        const isCurrentFlowImplicitFlowWithAccessToken = this.flowHelper.isCurrentFlowImplicitFlowWithAccessToken(configId);\r\n        const isCurrentFlowCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(configId);\r\n        if (isCurrentFlowImplicitFlowWithAccessToken || isCurrentFlowCodeFlow) {\r\n            toReturn.accessToken = callbackContext.authResult.access_token;\r\n        }\r\n        if (callbackContext.authResult.id_token) {\r\n            const { clientId, issValidationOff, maxIdTokenIatOffsetAllowedInSeconds, disableIatOffsetValidation, ignoreNonceAfterRefresh } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n            toReturn.idToken = callbackContext.authResult.id_token;\r\n            toReturn.decodedIdToken = this.tokenHelperService.getPayloadFromToken(toReturn.idToken, false, configId);\r\n            return this.tokenValidationService.validateSignatureIdToken(toReturn.idToken, callbackContext.jwtKeys, configId).pipe(mergeMap((isSignatureIdTokenValid) => {\r\n                if (!isSignatureIdTokenValid) {\r\n                    this.loggerService.logDebug(configId, 'authCallback Signature validation failed id_token');\r\n                    toReturn.state = ValidationResult.SignatureFailed;\r\n                    this.handleUnsuccessfulValidation(configId);\r\n                    return of(toReturn);\r\n                }\r\n                const authNonce = this.storagePersistenceService.read('authNonce', configId);\r\n                if (!this.tokenValidationService.validateIdTokenNonce(toReturn.decodedIdToken, authNonce, ignoreNonceAfterRefresh, configId)) {\r\n                    this.loggerService.logWarning(configId, 'authCallback incorrect nonce, did you call the checkAuth() method multiple times?');\r\n                    toReturn.state = ValidationResult.IncorrectNonce;\r\n                    this.handleUnsuccessfulValidation(configId);\r\n                    return of(toReturn);\r\n                }\r\n                if (!this.tokenValidationService.validateRequiredIdToken(toReturn.decodedIdToken, configId)) {\r\n                    this.loggerService.logDebug(configId, 'authCallback Validation, one of the REQUIRED properties missing from id_token');\r\n                    toReturn.state = ValidationResult.RequiredPropertyMissing;\r\n                    this.handleUnsuccessfulValidation(configId);\r\n                    return of(toReturn);\r\n                }\r\n                if (!this.tokenValidationService.validateIdTokenIatMaxOffset(toReturn.decodedIdToken, maxIdTokenIatOffsetAllowedInSeconds, disableIatOffsetValidation, configId)) {\r\n                    this.loggerService.logWarning(configId, 'authCallback Validation, iat rejected id_token was issued too far away from the current time');\r\n                    toReturn.state = ValidationResult.MaxOffsetExpired;\r\n                    this.handleUnsuccessfulValidation(configId);\r\n                    return of(toReturn);\r\n                }\r\n                const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n                if (authWellKnownEndPoints) {\r\n                    if (issValidationOff) {\r\n                        this.loggerService.logDebug(configId, 'iss validation is turned off, this is not recommended!');\r\n                    }\r\n                    else if (!issValidationOff &&\r\n                        !this.tokenValidationService.validateIdTokenIss(toReturn.decodedIdToken, authWellKnownEndPoints.issuer, configId)) {\r\n                        this.loggerService.logWarning(configId, 'authCallback incorrect iss does not match authWellKnownEndpoints issuer');\r\n                        toReturn.state = ValidationResult.IssDoesNotMatchIssuer;\r\n                        this.handleUnsuccessfulValidation(configId);\r\n                        return of(toReturn);\r\n                    }\r\n                }\r\n                else {\r\n                    this.loggerService.logWarning(configId, 'authWellKnownEndpoints is undefined');\r\n                    toReturn.state = ValidationResult.NoAuthWellKnownEndPoints;\r\n                    this.handleUnsuccessfulValidation(configId);\r\n                    return of(toReturn);\r\n                }\r\n                if (!this.tokenValidationService.validateIdTokenAud(toReturn.decodedIdToken, clientId, configId)) {\r\n                    this.loggerService.logWarning(configId, 'authCallback incorrect aud');\r\n                    toReturn.state = ValidationResult.IncorrectAud;\r\n                    this.handleUnsuccessfulValidation(configId);\r\n                    return of(toReturn);\r\n                }\r\n                if (!this.tokenValidationService.validateIdTokenAzpExistsIfMoreThanOneAud(toReturn.decodedIdToken)) {\r\n                    this.loggerService.logWarning(configId, 'authCallback missing azp');\r\n                    toReturn.state = ValidationResult.IncorrectAzp;\r\n                    this.handleUnsuccessfulValidation(configId);\r\n                    return of(toReturn);\r\n                }\r\n                if (!this.tokenValidationService.validateIdTokenAzpValid(toReturn.decodedIdToken, clientId)) {\r\n                    this.loggerService.logWarning(configId, 'authCallback incorrect azp');\r\n                    toReturn.state = ValidationResult.IncorrectAzp;\r\n                    this.handleUnsuccessfulValidation(configId);\r\n                    return of(toReturn);\r\n                }\r\n                if (!this.isIdTokenAfterRefreshTokenRequestValid(callbackContext, toReturn.decodedIdToken, configId)) {\r\n                    this.loggerService.logWarning(configId, 'authCallback pre, post id_token claims do not match in refresh');\r\n                    toReturn.state = ValidationResult.IncorrectIdTokenClaimsAfterRefresh;\r\n                    this.handleUnsuccessfulValidation(configId);\r\n                    return of(toReturn);\r\n                }\r\n                if (!this.tokenValidationService.validateIdTokenExpNotExpired(toReturn.decodedIdToken, configId)) {\r\n                    this.loggerService.logWarning(configId, 'authCallback id token expired');\r\n                    toReturn.state = ValidationResult.TokenExpired;\r\n                    this.handleUnsuccessfulValidation(configId);\r\n                    return of(toReturn);\r\n                }\r\n                return this.validateDefault(isCurrentFlowImplicitFlowWithAccessToken, isCurrentFlowCodeFlow, toReturn, configId, callbackContext);\r\n            }));\r\n        }\r\n        else {\r\n            this.loggerService.logDebug(configId, 'No id_token found, skipping id_token validation');\r\n        }\r\n        return this.validateDefault(isCurrentFlowImplicitFlowWithAccessToken, isCurrentFlowCodeFlow, toReturn, configId, callbackContext);\r\n    }\r\n    validateDefault(isCurrentFlowImplicitFlowWithAccessToken, isCurrentFlowCodeFlow, toReturn, configId, callbackContext) {\r\n        // flow id_token\r\n        if (!isCurrentFlowImplicitFlowWithAccessToken && !isCurrentFlowCodeFlow) {\r\n            toReturn.authResponseIsValid = true;\r\n            toReturn.state = ValidationResult.Ok;\r\n            this.handleSuccessfulValidation(configId);\r\n            this.handleUnsuccessfulValidation(configId);\r\n            return of(toReturn);\r\n        }\r\n        // only do check if id_token returned, no always the case when using refresh tokens\r\n        if (callbackContext.authResult.id_token) {\r\n            const idTokenHeader = this.tokenHelperService.getHeaderFromToken(toReturn.idToken, false, configId);\r\n            if (isCurrentFlowCodeFlow && !toReturn.decodedIdToken.at_hash) {\r\n                this.loggerService.logDebug(configId, 'Code Flow active, and no at_hash in the id_token, skipping check!');\r\n            }\r\n            else {\r\n                return this.tokenValidationService\r\n                    .validateIdTokenAtHash(toReturn.accessToken, toReturn.decodedIdToken.at_hash, idTokenHeader.alg, // 'RS256'\r\n                configId)\r\n                    .pipe(map((valid) => {\r\n                    if (!valid || !toReturn.accessToken) {\r\n                        this.loggerService.logWarning(configId, 'authCallback incorrect at_hash');\r\n                        toReturn.state = ValidationResult.IncorrectAtHash;\r\n                        this.handleUnsuccessfulValidation(configId);\r\n                        return toReturn;\r\n                    }\r\n                    else {\r\n                        toReturn.authResponseIsValid = true;\r\n                        toReturn.state = ValidationResult.Ok;\r\n                        this.handleSuccessfulValidation(configId);\r\n                        return toReturn;\r\n                    }\r\n                }));\r\n            }\r\n        }\r\n        toReturn.authResponseIsValid = true;\r\n        toReturn.state = ValidationResult.Ok;\r\n        this.handleSuccessfulValidation(configId);\r\n        return of(toReturn);\r\n    }\r\n    isIdTokenAfterRefreshTokenRequestValid(callbackContext, newIdToken, configId) {\r\n        const { useRefreshToken, disableRefreshIdTokenAuthTimeValidation } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!useRefreshToken) {\r\n            return true;\r\n        }\r\n        if (!callbackContext.existingIdToken) {\r\n            return true;\r\n        }\r\n        const decodedIdToken = this.tokenHelperService.getPayloadFromToken(callbackContext.existingIdToken, false, configId);\r\n        // Upon successful validation of the Refresh Token, the response body is the Token Response of Section 3.1.3.3\r\n        // except that it might not contain an id_token.\r\n        // If an ID Token is returned as a result of a token refresh request, the following requirements apply:\r\n        // its iss Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\r\n        if (decodedIdToken.iss !== newIdToken.iss) {\r\n            this.loggerService.logDebug(configId, `iss do not match: ${decodedIdToken.iss} ${newIdToken.iss}`);\r\n            return false;\r\n        }\r\n        // its azp Claim Value MUST be the same as in the ID Token issued when the original authentication occurred;\r\n        //   if no azp Claim was present in the original ID Token, one MUST NOT be present in the new ID Token, and\r\n        // otherwise, the same rules apply as apply when issuing an ID Token at the time of the original authentication.\r\n        if (decodedIdToken.azp !== newIdToken.azp) {\r\n            this.loggerService.logDebug(configId, `azp do not match: ${decodedIdToken.azp} ${newIdToken.azp}`);\r\n            return false;\r\n        }\r\n        // its sub Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\r\n        if (decodedIdToken.sub !== newIdToken.sub) {\r\n            this.loggerService.logDebug(configId, `sub do not match: ${decodedIdToken.sub} ${newIdToken.sub}`);\r\n            return false;\r\n        }\r\n        // its aud Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\r\n        if (!this.equalityService.isStringEqualOrNonOrderedArrayEqual(decodedIdToken === null || decodedIdToken === void 0 ? void 0 : decodedIdToken.aud, newIdToken === null || newIdToken === void 0 ? void 0 : newIdToken.aud)) {\r\n            this.loggerService.logDebug(configId, `aud in new id_token is not valid: '${decodedIdToken === null || decodedIdToken === void 0 ? void 0 : decodedIdToken.aud}' '${newIdToken.aud}'`);\r\n            return false;\r\n        }\r\n        if (disableRefreshIdTokenAuthTimeValidation) {\r\n            return true;\r\n        }\r\n        // its iat Claim MUST represent the time that the new ID Token is issued,\r\n        // if the ID Token contains an auth_time Claim, its value MUST represent the time of the original authentication\r\n        // - not the time that the new ID token is issued,\r\n        if (decodedIdToken.auth_time !== newIdToken.auth_time) {\r\n            this.loggerService.logDebug(configId, `auth_time do not match: ${decodedIdToken.auth_time} ${newIdToken.auth_time}`);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    handleSuccessfulValidation(configId) {\r\n        const { autoCleanStateAfterAuthentication } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        this.storagePersistenceService.write('authNonce', null, configId);\r\n        if (autoCleanStateAfterAuthentication) {\r\n            this.storagePersistenceService.write('authStateControl', '', configId);\r\n        }\r\n        this.loggerService.logDebug(configId, 'authCallback token(s) validated, continue');\r\n    }\r\n    handleUnsuccessfulValidation(configId) {\r\n        const { autoCleanStateAfterAuthentication } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        this.storagePersistenceService.write('authNonce', null, configId);\r\n        if (autoCleanStateAfterAuthentication) {\r\n            this.storagePersistenceService.write('authStateControl', '', configId);\r\n        }\r\n        this.loggerService.logDebug(configId, 'authCallback token(s) invalid');\r\n    }\r\n}\r\nStateValidationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: StateValidationService, deps: [{ token: StoragePersistenceService }, { token: TokenValidationService }, { token: TokenHelperService }, { token: LoggerService }, { token: ConfigurationProvider }, { token: EqualityService }, { token: FlowHelper }], target: i0.ɵɵFactoryTarget.Injectable });\r\nStateValidationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: StateValidationService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: StateValidationService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: TokenValidationService }, { type: TokenHelperService }, { type: LoggerService }, { type: ConfigurationProvider }, { type: EqualityService }, { type: FlowHelper }]; } });\n\nclass StateValidationCallbackHandlerService {\r\n    constructor(loggerService, stateValidationService, authStateService, resetAuthDataService, doc) {\r\n        this.loggerService = loggerService;\r\n        this.stateValidationService = stateValidationService;\r\n        this.authStateService = authStateService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.doc = doc;\r\n    }\r\n    // STEP 4 All flows\r\n    callbackStateValidation(callbackContext, configId) {\r\n        return this.stateValidationService.getValidatedStateResult(callbackContext, configId).pipe(map((validationResult) => {\r\n            callbackContext.validationResult = validationResult;\r\n            if (validationResult.authResponseIsValid) {\r\n                this.authStateService.setAuthorizationData(validationResult.accessToken, callbackContext.authResult, configId);\r\n                return callbackContext;\r\n            }\r\n            else {\r\n                const errorMessage = `authorizedCallback, token(s) validation failed, resetting. Hash: ${this.doc.location.hash}`;\r\n                this.loggerService.logWarning(configId, errorMessage);\r\n                this.resetAuthDataService.resetAuthorizationData(configId);\r\n                this.publishUnauthorizedState(callbackContext.validationResult, callbackContext.isRenewProcess);\r\n                throw new Error(errorMessage);\r\n            }\r\n        }));\r\n    }\r\n    publishUnauthorizedState(stateValidationResult, isRenewProcess) {\r\n        this.authStateService.updateAndPublishAuthState({\r\n            isAuthenticated: false,\r\n            validationResult: stateValidationResult.state,\r\n            isRenewProcess,\r\n        });\r\n    }\r\n}\r\nStateValidationCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: StateValidationCallbackHandlerService, deps: [{ token: LoggerService }, { token: StateValidationService }, { token: AuthStateService }, { token: ResetAuthDataService }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nStateValidationCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: StateValidationCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: StateValidationCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () {\r\n        return [{ type: LoggerService }, { type: StateValidationService }, { type: AuthStateService }, { type: ResetAuthDataService }, { type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [DOCUMENT]\r\n                    }] }];\r\n    } });\n\nclass RefreshSessionCallbackHandlerService {\r\n    constructor(loggerService, authStateService, flowsDataService) {\r\n        this.loggerService = loggerService;\r\n        this.authStateService = authStateService;\r\n        this.flowsDataService = flowsDataService;\r\n    }\r\n    // STEP 1 Refresh session\r\n    refreshSessionWithRefreshTokens(configId) {\r\n        const stateData = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\r\n        this.loggerService.logDebug(configId, 'RefreshSession created. Adding myautostate: ' + stateData);\r\n        const refreshToken = this.authStateService.getRefreshToken(configId);\r\n        const idToken = this.authStateService.getIdToken(configId);\r\n        if (refreshToken) {\r\n            const callbackContext = {\r\n                code: null,\r\n                refreshToken,\r\n                state: stateData,\r\n                sessionState: null,\r\n                authResult: null,\r\n                isRenewProcess: true,\r\n                jwtKeys: null,\r\n                validationResult: null,\r\n                existingIdToken: idToken,\r\n            };\r\n            this.loggerService.logDebug(configId, 'found refresh code, obtaining new credentials with refresh code');\r\n            // Nonce is not used with refresh tokens; but Key cloak may send it anyway\r\n            this.flowsDataService.setNonce(TokenValidationService.refreshTokenNoncePlaceholder, configId);\r\n            return of(callbackContext);\r\n        }\r\n        else {\r\n            const errorMessage = 'no refresh token found, please login';\r\n            this.loggerService.logError(configId, errorMessage);\r\n            return throwError(() => new Error(errorMessage));\r\n        }\r\n    }\r\n}\r\nRefreshSessionCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: RefreshSessionCallbackHandlerService, deps: [{ token: LoggerService }, { token: AuthStateService }, { token: FlowsDataService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRefreshSessionCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: RefreshSessionCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: RefreshSessionCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: AuthStateService }, { type: FlowsDataService }]; } });\n\nclass RefreshTokenCallbackHandlerService {\r\n    constructor(urlService, loggerService, configurationProvider, dataService, storagePersistenceService) {\r\n        this.urlService = urlService;\r\n        this.loggerService = loggerService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.dataService = dataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n    }\r\n    // STEP 2 Refresh Token\r\n    refreshTokensRequestTokens(callbackContext, configId, customParamsRefresh) {\r\n        let headers = new HttpHeaders();\r\n        headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\r\n        const authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        const tokenEndpoint = authWellknownEndpoints === null || authWellknownEndpoints === void 0 ? void 0 : authWellknownEndpoints.tokenEndpoint;\r\n        if (!tokenEndpoint) {\r\n            return throwError(() => new Error('Token Endpoint not defined'));\r\n        }\r\n        const data = this.urlService.createBodyForCodeFlowRefreshTokensRequest(callbackContext.refreshToken, configId, customParamsRefresh);\r\n        return this.dataService.post(tokenEndpoint, data, configId, headers).pipe(switchMap((response) => {\r\n            this.loggerService.logDebug(configId, 'token refresh response: ', response);\r\n            let authResult = new Object();\r\n            authResult = response;\r\n            authResult.state = callbackContext.state;\r\n            callbackContext.authResult = authResult;\r\n            return of(callbackContext);\r\n        }), retryWhen((error) => this.handleRefreshRetry(error, configId)), catchError((error) => {\r\n            const { authority } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n            const errorMessage = `OidcService code request ${authority}`;\r\n            this.loggerService.logError(configId, errorMessage, error);\r\n            return throwError(() => new Error(errorMessage));\r\n        }));\r\n    }\r\n    handleRefreshRetry(errors, configId) {\r\n        return errors.pipe(mergeMap((error) => {\r\n            // retry token refresh if there is no internet connection\r\n            if (error && error instanceof HttpErrorResponse && error.error instanceof ProgressEvent && error.error.type === 'error') {\r\n                const { authority, refreshTokenRetryInSeconds } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n                const errorMessage = `OidcService code request ${authority} - no internet connection`;\r\n                this.loggerService.logWarning(configId, errorMessage, error);\r\n                return timer(refreshTokenRetryInSeconds * 1000);\r\n            }\r\n            return throwError(() => new Error(error));\r\n        }));\r\n    }\r\n}\r\nRefreshTokenCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: RefreshTokenCallbackHandlerService, deps: [{ token: UrlService }, { token: LoggerService }, { token: ConfigurationProvider }, { token: DataService }, { token: StoragePersistenceService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRefreshTokenCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: RefreshTokenCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: RefreshTokenCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: UrlService }, { type: LoggerService }, { type: ConfigurationProvider }, { type: DataService }, { type: StoragePersistenceService }]; } });\n\nclass FlowsService {\r\n    constructor(codeFlowCallbackHandlerService, implicitFlowCallbackHandlerService, historyJwtKeysCallbackHandlerService, userHandlerService, stateValidationCallbackHandlerService, refreshSessionCallbackHandlerService, refreshTokenCallbackHandlerService) {\r\n        this.codeFlowCallbackHandlerService = codeFlowCallbackHandlerService;\r\n        this.implicitFlowCallbackHandlerService = implicitFlowCallbackHandlerService;\r\n        this.historyJwtKeysCallbackHandlerService = historyJwtKeysCallbackHandlerService;\r\n        this.userHandlerService = userHandlerService;\r\n        this.stateValidationCallbackHandlerService = stateValidationCallbackHandlerService;\r\n        this.refreshSessionCallbackHandlerService = refreshSessionCallbackHandlerService;\r\n        this.refreshTokenCallbackHandlerService = refreshTokenCallbackHandlerService;\r\n    }\r\n    processCodeFlowCallback(urlToCheck, configId) {\r\n        return this.codeFlowCallbackHandlerService.codeFlowCallback(urlToCheck, configId).pipe(concatMap((callbackContext) => this.codeFlowCallbackHandlerService.codeFlowCodeRequest(callbackContext, configId)), concatMap((callbackContext) => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, configId)), concatMap((callbackContext) => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, configId)), concatMap((callbackContext) => this.userHandlerService.callbackUser(callbackContext, configId)));\r\n    }\r\n    processSilentRenewCodeFlowCallback(firstContext, configId) {\r\n        return this.codeFlowCallbackHandlerService.codeFlowCodeRequest(firstContext, configId).pipe(concatMap((callbackContext) => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, configId)), concatMap((callbackContext) => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, configId)), concatMap((callbackContext) => this.userHandlerService.callbackUser(callbackContext, configId)));\r\n    }\r\n    processImplicitFlowCallback(configId, hash) {\r\n        return this.implicitFlowCallbackHandlerService.implicitFlowCallback(configId, hash).pipe(concatMap((callbackContext) => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, configId)), concatMap((callbackContext) => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, configId)), concatMap((callbackContext) => this.userHandlerService.callbackUser(callbackContext, configId)));\r\n    }\r\n    processRefreshToken(configId, customParamsRefresh) {\r\n        return this.refreshSessionCallbackHandlerService.refreshSessionWithRefreshTokens(configId).pipe(concatMap((callbackContext) => this.refreshTokenCallbackHandlerService.refreshTokensRequestTokens(callbackContext, configId, customParamsRefresh)), concatMap((callbackContext) => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, configId)), concatMap((callbackContext) => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, configId)), concatMap((callbackContext) => this.userHandlerService.callbackUser(callbackContext, configId)));\r\n    }\r\n}\r\nFlowsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: FlowsService, deps: [{ token: CodeFlowCallbackHandlerService }, { token: ImplicitFlowCallbackHandlerService }, { token: HistoryJwtKeysCallbackHandlerService }, { token: UserCallbackHandlerService }, { token: StateValidationCallbackHandlerService }, { token: RefreshSessionCallbackHandlerService }, { token: RefreshTokenCallbackHandlerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nFlowsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: FlowsService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: FlowsService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: CodeFlowCallbackHandlerService }, { type: ImplicitFlowCallbackHandlerService }, { type: HistoryJwtKeysCallbackHandlerService }, { type: UserCallbackHandlerService }, { type: StateValidationCallbackHandlerService }, { type: RefreshSessionCallbackHandlerService }, { type: RefreshTokenCallbackHandlerService }]; } });\n\nclass IntervalService {\r\n    constructor(zone) {\r\n        this.zone = zone;\r\n        this.runTokenValidationRunning = null;\r\n    }\r\n    stopPeriodicTokenCheck() {\r\n        if (this.runTokenValidationRunning) {\r\n            this.runTokenValidationRunning.unsubscribe();\r\n            this.runTokenValidationRunning = null;\r\n        }\r\n    }\r\n    startPeriodicTokenCheck(repeatAfterSeconds) {\r\n        const millisecondsDelayBetweenTokenCheck = repeatAfterSeconds * 1000;\r\n        return new Observable((subscriber) => {\r\n            let intervalId;\r\n            this.zone.runOutsideAngular(() => {\r\n                intervalId = setInterval(() => this.zone.run(() => subscriber.next()), millisecondsDelayBetweenTokenCheck);\r\n            });\r\n            return () => {\r\n                clearInterval(intervalId);\r\n            };\r\n        });\r\n    }\r\n}\r\nIntervalService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: IntervalService, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });\r\nIntervalService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: IntervalService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: IntervalService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: i0.NgZone }]; } });\n\nclass ImplicitFlowCallbackService {\r\n    constructor(flowsService, configurationProvider, router, flowsDataService, intervalService) {\r\n        this.flowsService = flowsService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.router = router;\r\n        this.flowsDataService = flowsDataService;\r\n        this.intervalService = intervalService;\r\n    }\r\n    authenticatedImplicitFlowCallback(configId, hash) {\r\n        const isRenewProcess = this.flowsDataService.isSilentRenewRunning(configId);\r\n        const { triggerAuthorizationResultEvent, postLoginRoute, unauthorizedRoute } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        return this.flowsService.processImplicitFlowCallback(configId, hash).pipe(tap((callbackContext) => {\r\n            if (!triggerAuthorizationResultEvent && !callbackContext.isRenewProcess) {\r\n                this.router.navigateByUrl(postLoginRoute);\r\n            }\r\n        }), catchError((error) => {\r\n            this.flowsDataService.resetSilentRenewRunning(configId);\r\n            this.intervalService.stopPeriodicTokenCheck();\r\n            if (!triggerAuthorizationResultEvent && !isRenewProcess) {\r\n                this.router.navigateByUrl(unauthorizedRoute);\r\n            }\r\n            return throwError(() => new Error(error));\r\n        }));\r\n    }\r\n}\r\nImplicitFlowCallbackService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: ImplicitFlowCallbackService, deps: [{ token: FlowsService }, { token: ConfigurationProvider }, { token: i2.Router }, { token: FlowsDataService }, { token: IntervalService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nImplicitFlowCallbackService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: ImplicitFlowCallbackService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: ImplicitFlowCallbackService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: FlowsService }, { type: ConfigurationProvider }, { type: i2.Router }, { type: FlowsDataService }, { type: IntervalService }]; } });\n\nclass IFrameService {\r\n    constructor(doc, loggerService) {\r\n        this.doc = doc;\r\n        this.loggerService = loggerService;\r\n    }\r\n    getExistingIFrame(identifier) {\r\n        const iFrameOnParent = this.getIFrameFromParentWindow(identifier);\r\n        if (this.isIFrameElement(iFrameOnParent)) {\r\n            return iFrameOnParent;\r\n        }\r\n        const iFrameOnSelf = this.getIFrameFromWindow(identifier);\r\n        if (this.isIFrameElement(iFrameOnSelf)) {\r\n            return iFrameOnSelf;\r\n        }\r\n        return null;\r\n    }\r\n    addIFrameToWindowBody(identifier, configId) {\r\n        const sessionIframe = this.doc.createElement('iframe');\r\n        sessionIframe.id = identifier;\r\n        sessionIframe.title = identifier;\r\n        this.loggerService.logDebug(configId, sessionIframe);\r\n        sessionIframe.style.display = 'none';\r\n        this.doc.body.appendChild(sessionIframe);\r\n        return sessionIframe;\r\n    }\r\n    getIFrameFromParentWindow(identifier) {\r\n        try {\r\n            const iFrameElement = this.doc.defaultView.parent.document.getElementById(identifier);\r\n            if (this.isIFrameElement(iFrameElement)) {\r\n                return iFrameElement;\r\n            }\r\n            return null;\r\n        }\r\n        catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n    getIFrameFromWindow(identifier) {\r\n        const iFrameElement = this.doc.getElementById(identifier);\r\n        if (this.isIFrameElement(iFrameElement)) {\r\n            return iFrameElement;\r\n        }\r\n        return null;\r\n    }\r\n    isIFrameElement(element) {\r\n        return !!element && element instanceof HTMLIFrameElement;\r\n    }\r\n}\r\nIFrameService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: IFrameService, deps: [{ token: DOCUMENT }, { token: LoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nIFrameService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: IFrameService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: IFrameService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () {\r\n        return [{ type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [DOCUMENT]\r\n                    }] }, { type: LoggerService }];\r\n    } });\n\nconst IFRAME_FOR_CHECK_SESSION_IDENTIFIER = 'myiFrameForCheckSession';\r\n// http://openid.net/specs/openid-connect-session-1_0-ID4.html\r\nclass CheckSessionService {\r\n    constructor(storagePersistenceService, loggerService, iFrameService, eventService, configurationProvider, zone) {\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.loggerService = loggerService;\r\n        this.iFrameService = iFrameService;\r\n        this.eventService = eventService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.zone = zone;\r\n        this.checkSessionReceived = false;\r\n        this.lastIFrameRefresh = 0;\r\n        this.outstandingMessages = 0;\r\n        this.heartBeatInterval = 3000;\r\n        this.iframeRefreshInterval = 60000;\r\n        this.checkSessionChangedInternal$ = new BehaviorSubject(false);\r\n    }\r\n    get checkSessionChanged$() {\r\n        return this.checkSessionChangedInternal$.asObservable();\r\n    }\r\n    isCheckSessionConfigured(configId) {\r\n        const { startCheckSession } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        return startCheckSession;\r\n    }\r\n    start(configId) {\r\n        if (!!this.scheduledHeartBeatRunning) {\r\n            return;\r\n        }\r\n        const { clientId } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        this.pollServerSession(clientId, configId);\r\n    }\r\n    stop() {\r\n        if (!this.scheduledHeartBeatRunning) {\r\n            return;\r\n        }\r\n        this.clearScheduledHeartBeat();\r\n        this.checkSessionReceived = false;\r\n    }\r\n    serverStateChanged(configId) {\r\n        const { startCheckSession } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        return startCheckSession && this.checkSessionReceived;\r\n    }\r\n    getExistingIframe() {\r\n        return this.iFrameService.getExistingIFrame(IFRAME_FOR_CHECK_SESSION_IDENTIFIER);\r\n    }\r\n    init(configId) {\r\n        if (this.lastIFrameRefresh + this.iframeRefreshInterval > Date.now()) {\r\n            return of(undefined);\r\n        }\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        if (!authWellKnownEndPoints) {\r\n            this.loggerService.logWarning(configId, 'CheckSession - init check session: authWellKnownEndpoints is undefined. Returning.');\r\n            return of();\r\n        }\r\n        const existingIframe = this.getOrCreateIframe(configId);\r\n        const checkSessionIframe = authWellKnownEndPoints.checkSessionIframe;\r\n        if (checkSessionIframe) {\r\n            existingIframe.contentWindow.location.replace(checkSessionIframe);\r\n        }\r\n        else {\r\n            this.loggerService.logWarning(configId, 'CheckSession - init check session: checkSessionIframe is not configured to run');\r\n        }\r\n        return new Observable((observer) => {\r\n            existingIframe.onload = () => {\r\n                this.lastIFrameRefresh = Date.now();\r\n                observer.next();\r\n                observer.complete();\r\n            };\r\n        });\r\n    }\r\n    pollServerSession(clientId, configId) {\r\n        this.outstandingMessages = 0;\r\n        const pollServerSessionRecur = () => {\r\n            this.init(configId)\r\n                .pipe(take(1))\r\n                .subscribe(() => {\r\n                var _a;\r\n                const existingIframe = this.getExistingIframe();\r\n                if (existingIframe && clientId) {\r\n                    this.loggerService.logDebug(configId, `CheckSession - clientId : '${clientId}' - existingIframe: '${existingIframe}'`);\r\n                    const sessionState = this.storagePersistenceService.read('session_state', configId);\r\n                    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n                    if (sessionState && (authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.checkSessionIframe)) {\r\n                        const iframeOrigin = (_a = new URL(authWellKnownEndPoints.checkSessionIframe)) === null || _a === void 0 ? void 0 : _a.origin;\r\n                        this.outstandingMessages++;\r\n                        existingIframe.contentWindow.postMessage(clientId + ' ' + sessionState, iframeOrigin);\r\n                    }\r\n                    else {\r\n                        this.loggerService.logDebug(configId, `CheckSession - session_state is '${sessionState}' - AuthWellKnownEndPoints is '${JSON.stringify(authWellKnownEndPoints, null, 2)}'`);\r\n                        this.checkSessionChangedInternal$.next(true);\r\n                    }\r\n                }\r\n                else {\r\n                    this.loggerService.logWarning(configId, `CheckSession - OidcSecurityCheckSession pollServerSession checkSession IFrame does not exist:\n               clientId : '${clientId}' - existingIframe: '${existingIframe}'`);\r\n                }\r\n                // after sending three messages with no response, fail.\r\n                if (this.outstandingMessages > 3) {\r\n                    this.loggerService.logError(configId, `CheckSession - OidcSecurityCheckSession not receiving check session response messages.\n                            Outstanding messages: '${this.outstandingMessages}'. Server unreachable?`);\r\n                }\r\n                this.zone.runOutsideAngular(() => {\r\n                    this.scheduledHeartBeatRunning = setTimeout(() => this.zone.run(pollServerSessionRecur), this.heartBeatInterval);\r\n                });\r\n            });\r\n        };\r\n        pollServerSessionRecur();\r\n    }\r\n    clearScheduledHeartBeat() {\r\n        clearTimeout(this.scheduledHeartBeatRunning);\r\n        this.scheduledHeartBeatRunning = null;\r\n    }\r\n    messageHandler(configId, e) {\r\n        var _a;\r\n        const existingIFrame = this.getExistingIframe();\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        const startsWith = !!((_a = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.checkSessionIframe) === null || _a === void 0 ? void 0 : _a.startsWith(e.origin));\r\n        this.outstandingMessages = 0;\r\n        if (existingIFrame && startsWith && e.source === existingIFrame.contentWindow) {\r\n            if (e.data === 'error') {\r\n                this.loggerService.logWarning(configId, 'CheckSession - error from check session messageHandler');\r\n            }\r\n            else if (e.data === 'changed') {\r\n                this.loggerService.logDebug(configId, `CheckSession - ${e} from check session messageHandler`);\r\n                this.checkSessionReceived = true;\r\n                this.eventService.fireEvent(EventTypes.CheckSessionReceived, e.data);\r\n                this.checkSessionChangedInternal$.next(true);\r\n            }\r\n            else {\r\n                this.eventService.fireEvent(EventTypes.CheckSessionReceived, e.data);\r\n                this.loggerService.logDebug(configId, `CheckSession - ${e.data} from check session messageHandler`);\r\n            }\r\n        }\r\n    }\r\n    bindMessageEventToIframe(configId) {\r\n        const iframeMessageEvent = this.messageHandler.bind(this, configId);\r\n        window.addEventListener('message', iframeMessageEvent, false);\r\n    }\r\n    getOrCreateIframe(configId) {\r\n        const existingIframe = this.getExistingIframe();\r\n        if (!existingIframe) {\r\n            const frame = this.iFrameService.addIFrameToWindowBody(IFRAME_FOR_CHECK_SESSION_IDENTIFIER, configId);\r\n            this.bindMessageEventToIframe(configId);\r\n            return frame;\r\n        }\r\n        return existingIframe;\r\n    }\r\n}\r\nCheckSessionService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CheckSessionService, deps: [{ token: StoragePersistenceService }, { token: LoggerService }, { token: IFrameService }, { token: PublicEventsService }, { token: ConfigurationProvider }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCheckSessionService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CheckSessionService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CheckSessionService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: LoggerService }, { type: IFrameService }, { type: PublicEventsService }, { type: ConfigurationProvider }, { type: i0.NgZone }]; } });\n\nclass CurrentUrlService {\r\n    constructor(doc) {\r\n        this.doc = doc;\r\n    }\r\n    getStateParamFromCurrentUrl() {\r\n        const currentUrl = this.getCurrentUrl();\r\n        const parsedUrl = new URL(currentUrl);\r\n        const urlParams = new URLSearchParams(parsedUrl.search);\r\n        const stateFromUrl = urlParams.get('state');\r\n        return stateFromUrl;\r\n    }\r\n    currentUrlHasStateParam() {\r\n        return !!this.getStateParamFromCurrentUrl();\r\n    }\r\n    getCurrentUrl() {\r\n        return this.doc.defaultView.location.toString();\r\n    }\r\n}\r\nCurrentUrlService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CurrentUrlService, deps: [{ token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCurrentUrlService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CurrentUrlService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CurrentUrlService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () {\r\n        return [{ type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [DOCUMENT]\r\n                    }] }];\r\n    } });\n\nconst IFRAME_FOR_SILENT_RENEW_IDENTIFIER = 'myiFrameForSilentRenew';\r\nclass SilentRenewService {\r\n    constructor(configurationProvider, iFrameService, flowsService, resetAuthDataService, flowsDataService, authStateService, loggerService, flowHelper, implicitFlowCallbackService, intervalService) {\r\n        this.configurationProvider = configurationProvider;\r\n        this.iFrameService = iFrameService;\r\n        this.flowsService = flowsService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.authStateService = authStateService;\r\n        this.loggerService = loggerService;\r\n        this.flowHelper = flowHelper;\r\n        this.implicitFlowCallbackService = implicitFlowCallbackService;\r\n        this.intervalService = intervalService;\r\n        this.refreshSessionWithIFrameCompletedInternal$ = new Subject();\r\n    }\r\n    get refreshSessionWithIFrameCompleted$() {\r\n        return this.refreshSessionWithIFrameCompletedInternal$.asObservable();\r\n    }\r\n    getOrCreateIframe(configId) {\r\n        const existingIframe = this.getExistingIframe();\r\n        if (!existingIframe) {\r\n            return this.iFrameService.addIFrameToWindowBody(IFRAME_FOR_SILENT_RENEW_IDENTIFIER, configId);\r\n        }\r\n        return existingIframe;\r\n    }\r\n    isSilentRenewConfigured(configId) {\r\n        const { useRefreshToken, silentRenew } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        return !useRefreshToken && silentRenew;\r\n    }\r\n    codeFlowCallbackSilentRenewIframe(urlParts, configId) {\r\n        const params = new HttpParams({\r\n            fromString: urlParts[1],\r\n        });\r\n        const error = params.get('error');\r\n        if (error) {\r\n            this.authStateService.updateAndPublishAuthState({\r\n                isAuthenticated: false,\r\n                validationResult: ValidationResult.LoginRequired,\r\n                isRenewProcess: true,\r\n            });\r\n            this.resetAuthDataService.resetAuthorizationData(configId);\r\n            this.flowsDataService.setNonce('', configId);\r\n            this.intervalService.stopPeriodicTokenCheck();\r\n            return throwError(() => new Error(error));\r\n        }\r\n        const code = params.get('code');\r\n        const state = params.get('state');\r\n        const sessionState = params.get('session_state');\r\n        const callbackContext = {\r\n            code,\r\n            refreshToken: null,\r\n            state,\r\n            sessionState,\r\n            authResult: null,\r\n            isRenewProcess: true,\r\n            jwtKeys: null,\r\n            validationResult: null,\r\n            existingIdToken: null,\r\n        };\r\n        return this.flowsService.processSilentRenewCodeFlowCallback(callbackContext, configId).pipe(catchError((errorFromFlow) => {\r\n            this.intervalService.stopPeriodicTokenCheck();\r\n            this.resetAuthDataService.resetAuthorizationData(configId);\r\n            return throwError(() => new Error(error));\r\n        }));\r\n    }\r\n    silentRenewEventHandler(e, configId) {\r\n        this.loggerService.logDebug(configId, 'silentRenewEventHandler');\r\n        if (!e.detail) {\r\n            return;\r\n        }\r\n        let callback$ = of(null);\r\n        const isCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(configId);\r\n        if (isCodeFlow) {\r\n            const urlParts = e.detail.toString().split('?');\r\n            callback$ = this.codeFlowCallbackSilentRenewIframe(urlParts, configId);\r\n        }\r\n        else {\r\n            callback$ = this.implicitFlowCallbackService.authenticatedImplicitFlowCallback(configId, e.detail);\r\n        }\r\n        callback$.subscribe({\r\n            next: (callbackContext) => {\r\n                this.refreshSessionWithIFrameCompletedInternal$.next(callbackContext);\r\n                this.flowsDataService.resetSilentRenewRunning(configId);\r\n            },\r\n            error: (err) => {\r\n                this.loggerService.logError(configId, 'Error: ' + err);\r\n                this.refreshSessionWithIFrameCompletedInternal$.next(null);\r\n                this.flowsDataService.resetSilentRenewRunning(configId);\r\n            },\r\n        });\r\n    }\r\n    getExistingIframe() {\r\n        return this.iFrameService.getExistingIFrame(IFRAME_FOR_SILENT_RENEW_IDENTIFIER);\r\n    }\r\n}\r\nSilentRenewService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: SilentRenewService, deps: [{ token: ConfigurationProvider }, { token: IFrameService }, { token: FlowsService }, { token: ResetAuthDataService }, { token: FlowsDataService }, { token: AuthStateService }, { token: LoggerService }, { token: FlowHelper }, { token: ImplicitFlowCallbackService }, { token: IntervalService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nSilentRenewService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: SilentRenewService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: SilentRenewService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: ConfigurationProvider }, { type: IFrameService }, { type: FlowsService }, { type: ResetAuthDataService }, { type: FlowsDataService }, { type: AuthStateService }, { type: LoggerService }, { type: FlowHelper }, { type: ImplicitFlowCallbackService }, { type: IntervalService }]; } });\n\nclass CodeFlowCallbackService {\r\n    constructor(flowsService, flowsDataService, intervalService, configurationProvider, router) {\r\n        this.flowsService = flowsService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.intervalService = intervalService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.router = router;\r\n    }\r\n    authenticatedCallbackWithCode(urlToCheck, configId) {\r\n        const isRenewProcess = this.flowsDataService.isSilentRenewRunning(configId);\r\n        const { triggerAuthorizationResultEvent, postLoginRoute, unauthorizedRoute } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        return this.flowsService.processCodeFlowCallback(urlToCheck, configId).pipe(tap((callbackContext) => {\r\n            if (!triggerAuthorizationResultEvent && !callbackContext.isRenewProcess) {\r\n                this.router.navigateByUrl(postLoginRoute);\r\n            }\r\n        }), catchError((error) => {\r\n            this.flowsDataService.resetSilentRenewRunning(configId);\r\n            this.intervalService.stopPeriodicTokenCheck();\r\n            if (!triggerAuthorizationResultEvent && !isRenewProcess) {\r\n                this.router.navigateByUrl(unauthorizedRoute);\r\n            }\r\n            return throwError(() => new Error(error));\r\n        }));\r\n    }\r\n}\r\nCodeFlowCallbackService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CodeFlowCallbackService, deps: [{ token: FlowsService }, { token: FlowsDataService }, { token: IntervalService }, { token: ConfigurationProvider }, { token: i2.Router }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCodeFlowCallbackService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CodeFlowCallbackService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CodeFlowCallbackService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: FlowsService }, { type: FlowsDataService }, { type: IntervalService }, { type: ConfigurationProvider }, { type: i2.Router }]; } });\n\nclass CallbackService {\r\n    constructor(urlService, flowHelper, implicitFlowCallbackService, codeFlowCallbackService) {\r\n        this.urlService = urlService;\r\n        this.flowHelper = flowHelper;\r\n        this.implicitFlowCallbackService = implicitFlowCallbackService;\r\n        this.codeFlowCallbackService = codeFlowCallbackService;\r\n        this.stsCallbackInternal$ = new Subject();\r\n    }\r\n    get stsCallback$() {\r\n        return this.stsCallbackInternal$.asObservable();\r\n    }\r\n    isCallback(currentUrl) {\r\n        return this.urlService.isCallbackFromSts(currentUrl);\r\n    }\r\n    handleCallbackAndFireEvents(currentCallbackUrl, configId) {\r\n        let callback$;\r\n        if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\r\n            callback$ = this.codeFlowCallbackService.authenticatedCallbackWithCode(currentCallbackUrl, configId);\r\n        }\r\n        else if (this.flowHelper.isCurrentFlowAnyImplicitFlow(configId)) {\r\n            callback$ = this.implicitFlowCallbackService.authenticatedImplicitFlowCallback(configId);\r\n        }\r\n        return callback$.pipe(tap(() => this.stsCallbackInternal$.next()));\r\n    }\r\n}\r\nCallbackService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CallbackService, deps: [{ token: UrlService }, { token: FlowHelper }, { token: ImplicitFlowCallbackService }, { token: CodeFlowCallbackService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCallbackService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CallbackService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CallbackService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: UrlService }, { type: FlowHelper }, { type: ImplicitFlowCallbackService }, { type: CodeFlowCallbackService }]; } });\n\nconst WELL_KNOWN_SUFFIX = `/.well-known/openid-configuration`;\r\nclass AuthWellKnownDataService {\r\n    constructor(http) {\r\n        this.http = http;\r\n    }\r\n    getWellKnownEndPointsFromUrl(authWellknownEndpoint, configId) {\r\n        return this.getWellKnownDocument(authWellknownEndpoint, configId).pipe(map((wellKnownEndpoints) => ({\r\n            issuer: wellKnownEndpoints.issuer,\r\n            jwksUri: wellKnownEndpoints.jwks_uri,\r\n            authorizationEndpoint: wellKnownEndpoints.authorization_endpoint,\r\n            tokenEndpoint: wellKnownEndpoints.token_endpoint,\r\n            userInfoEndpoint: wellKnownEndpoints.userinfo_endpoint,\r\n            endSessionEndpoint: wellKnownEndpoints.end_session_endpoint,\r\n            checkSessionIframe: wellKnownEndpoints.check_session_iframe,\r\n            revocationEndpoint: wellKnownEndpoints.revocation_endpoint,\r\n            introspectionEndpoint: wellKnownEndpoints.introspection_endpoint,\r\n            parEndpoint: wellKnownEndpoints.pushed_authorization_request_endpoint,\r\n        })));\r\n    }\r\n    getWellKnownDocument(wellKnownEndpoint, configId) {\r\n        let url = wellKnownEndpoint;\r\n        if (!wellKnownEndpoint.includes(WELL_KNOWN_SUFFIX)) {\r\n            url = `${wellKnownEndpoint}${WELL_KNOWN_SUFFIX}`;\r\n        }\r\n        return this.http.get(url, configId).pipe(retry(2));\r\n    }\r\n}\r\nAuthWellKnownDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: AuthWellKnownDataService, deps: [{ token: DataService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAuthWellKnownDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: AuthWellKnownDataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: AuthWellKnownDataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: DataService }]; } });\n\nclass AuthWellKnownService {\r\n    constructor(publicEventsService, dataService, storagePersistenceService) {\r\n        this.publicEventsService = publicEventsService;\r\n        this.dataService = dataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n    }\r\n    getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId) {\r\n        const alreadySavedWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        if (!!alreadySavedWellKnownEndpoints) {\r\n            return of(alreadySavedWellKnownEndpoints);\r\n        }\r\n        return this.getWellKnownEndPointsFromUrl(authWellknownEndpointUrl, configId).pipe(tap((mappedWellKnownEndpoints) => this.storeWellKnownEndpoints(configId, mappedWellKnownEndpoints)), catchError((error) => {\r\n            this.publicEventsService.fireEvent(EventTypes.ConfigLoadingFailed, null);\r\n            return throwError(() => new Error(error));\r\n        }));\r\n    }\r\n    storeWellKnownEndpoints(configId, mappedWellKnownEndpoints) {\r\n        this.storagePersistenceService.write('authWellKnownEndPoints', mappedWellKnownEndpoints, configId);\r\n    }\r\n    getWellKnownEndPointsFromUrl(authWellknownEndpointUrl, configId) {\r\n        return this.dataService.getWellKnownEndPointsFromUrl(authWellknownEndpointUrl, configId);\r\n    }\r\n}\r\nAuthWellKnownService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: AuthWellKnownService, deps: [{ token: PublicEventsService }, { token: AuthWellKnownDataService }, { token: StoragePersistenceService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAuthWellKnownService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: AuthWellKnownService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: AuthWellKnownService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: PublicEventsService }, { type: AuthWellKnownDataService }, { type: StoragePersistenceService }]; } });\n\nclass RefreshSessionIframeService {\r\n    constructor(doc, loggerService, urlService, silentRenewService, rendererFactory) {\r\n        this.doc = doc;\r\n        this.loggerService = loggerService;\r\n        this.urlService = urlService;\r\n        this.silentRenewService = silentRenewService;\r\n        this.renderer = rendererFactory.createRenderer(null, null);\r\n    }\r\n    refreshSessionWithIframe(configId, customParams) {\r\n        this.loggerService.logDebug(configId, 'BEGIN refresh session Authorize Iframe renew');\r\n        return this.urlService.getRefreshSessionSilentRenewUrl(configId, customParams).pipe(switchMap((url) => {\r\n            return this.sendAuthorizeRequestUsingSilentRenew(url, configId);\r\n        }));\r\n    }\r\n    sendAuthorizeRequestUsingSilentRenew(url, configId) {\r\n        const sessionIframe = this.silentRenewService.getOrCreateIframe(configId);\r\n        this.initSilentRenewRequest(configId);\r\n        this.loggerService.logDebug(configId, 'sendAuthorizeRequestUsingSilentRenew for URL:' + url);\r\n        return new Observable((observer) => {\r\n            const onLoadHandler = () => {\r\n                sessionIframe.removeEventListener('load', onLoadHandler);\r\n                this.loggerService.logDebug(configId, 'removed event listener from IFrame');\r\n                observer.next(true);\r\n                observer.complete();\r\n            };\r\n            sessionIframe.addEventListener('load', onLoadHandler);\r\n            sessionIframe.contentWindow.location.replace(url);\r\n        });\r\n    }\r\n    initSilentRenewRequest(configId) {\r\n        const instanceId = Math.random();\r\n        const initDestroyHandler = this.renderer.listen('window', 'oidc-silent-renew-init', (e) => {\r\n            if (e.detail !== instanceId) {\r\n                initDestroyHandler();\r\n                renewDestroyHandler();\r\n            }\r\n        });\r\n        const renewDestroyHandler = this.renderer.listen('window', 'oidc-silent-renew-message', (e) => this.silentRenewService.silentRenewEventHandler(e, configId));\r\n        this.doc.defaultView.dispatchEvent(new CustomEvent('oidc-silent-renew-init', {\r\n            detail: instanceId,\r\n        }));\r\n    }\r\n}\r\nRefreshSessionIframeService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: RefreshSessionIframeService, deps: [{ token: DOCUMENT }, { token: LoggerService }, { token: UrlService }, { token: SilentRenewService }, { token: i0.RendererFactory2 }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRefreshSessionIframeService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: RefreshSessionIframeService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: RefreshSessionIframeService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () {\r\n        return [{ type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [DOCUMENT]\r\n                    }] }, { type: LoggerService }, { type: UrlService }, { type: SilentRenewService }, { type: i0.RendererFactory2 }];\r\n    } });\n\nclass RefreshSessionRefreshTokenService {\r\n    constructor(loggerService, resetAuthDataService, flowsService, intervalService) {\r\n        this.loggerService = loggerService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.flowsService = flowsService;\r\n        this.intervalService = intervalService;\r\n    }\r\n    refreshSessionWithRefreshTokens(configId, customParamsRefresh) {\r\n        this.loggerService.logDebug(configId, 'BEGIN refresh session Authorize');\r\n        return this.flowsService.processRefreshToken(configId, customParamsRefresh).pipe(catchError((error) => {\r\n            this.intervalService.stopPeriodicTokenCheck();\r\n            this.resetAuthDataService.resetAuthorizationData(configId);\r\n            return throwError(() => new Error(error));\r\n        }));\r\n    }\r\n}\r\nRefreshSessionRefreshTokenService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: RefreshSessionRefreshTokenService, deps: [{ token: LoggerService }, { token: ResetAuthDataService }, { token: FlowsService }, { token: IntervalService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRefreshSessionRefreshTokenService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: RefreshSessionRefreshTokenService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: RefreshSessionRefreshTokenService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: ResetAuthDataService }, { type: FlowsService }, { type: IntervalService }]; } });\n\nconst MAX_RETRY_ATTEMPTS = 3;\r\nclass RefreshSessionService {\r\n    constructor(flowHelper, configurationProvider, flowsDataService, loggerService, silentRenewService, authStateService, authWellKnownService, refreshSessionIframeService, storagePersistenceService, refreshSessionRefreshTokenService, userService) {\r\n        this.flowHelper = flowHelper;\r\n        this.configurationProvider = configurationProvider;\r\n        this.flowsDataService = flowsDataService;\r\n        this.loggerService = loggerService;\r\n        this.silentRenewService = silentRenewService;\r\n        this.authStateService = authStateService;\r\n        this.authWellKnownService = authWellKnownService;\r\n        this.refreshSessionIframeService = refreshSessionIframeService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.refreshSessionRefreshTokenService = refreshSessionRefreshTokenService;\r\n        this.userService = userService;\r\n    }\r\n    userForceRefreshSession(configId, extraCustomParams) {\r\n        this.persistCustomParams(extraCustomParams, configId);\r\n        return this.forceRefreshSession(configId, extraCustomParams);\r\n    }\r\n    forceRefreshSession(configId, extraCustomParams) {\r\n        const { customParamsRefreshTokenRequest } = this.configurationProvider.getOpenIDConfiguration();\r\n        const mergedParams = Object.assign(Object.assign({}, customParamsRefreshTokenRequest), extraCustomParams);\r\n        if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(configId)) {\r\n            return this.startRefreshSession(configId, mergedParams).pipe(map(() => {\r\n                const isAuthenticated = this.authStateService.areAuthStorageTokensValid(configId);\r\n                if (isAuthenticated) {\r\n                    return {\r\n                        idToken: this.authStateService.getIdToken(configId),\r\n                        accessToken: this.authStateService.getAccessToken(configId),\r\n                        userData: this.userService.getUserDataFromStore(configId),\r\n                        isAuthenticated,\r\n                        configId,\r\n                    };\r\n                }\r\n                return null;\r\n            }));\r\n        }\r\n        const { silentRenewTimeoutInSeconds } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        const timeOutTime = silentRenewTimeoutInSeconds * 1000;\r\n        return forkJoin([\r\n            this.startRefreshSession(configId, extraCustomParams),\r\n            this.silentRenewService.refreshSessionWithIFrameCompleted$.pipe(take(1)),\r\n        ]).pipe(timeout(timeOutTime), retryWhen(this.timeoutRetryStrategy.bind(this)), map(([_, callbackContext]) => {\r\n            var _a, _b;\r\n            const isAuthenticated = this.authStateService.areAuthStorageTokensValid(configId);\r\n            if (isAuthenticated) {\r\n                return {\r\n                    idToken: (_a = callbackContext === null || callbackContext === void 0 ? void 0 : callbackContext.authResult) === null || _a === void 0 ? void 0 : _a.id_token,\r\n                    accessToken: (_b = callbackContext === null || callbackContext === void 0 ? void 0 : callbackContext.authResult) === null || _b === void 0 ? void 0 : _b.access_token,\r\n                    userData: this.userService.getUserDataFromStore(configId),\r\n                    isAuthenticated,\r\n                    configId,\r\n                };\r\n            }\r\n            return null;\r\n        }));\r\n    }\r\n    persistCustomParams(extraCustomParams, configId) {\r\n        const { useRefreshToken } = this.configurationProvider.getOpenIDConfiguration();\r\n        if (extraCustomParams) {\r\n            if (useRefreshToken) {\r\n                this.storagePersistenceService.write('storageCustomParamsRefresh', extraCustomParams, configId);\r\n            }\r\n            else {\r\n                this.storagePersistenceService.write('storageCustomParamsAuthRequest', extraCustomParams, configId);\r\n            }\r\n        }\r\n    }\r\n    startRefreshSession(configId, extraCustomParams) {\r\n        const isSilentRenewRunning = this.flowsDataService.isSilentRenewRunning(configId);\r\n        this.loggerService.logDebug(configId, `Checking: silentRenewRunning: ${isSilentRenewRunning}`);\r\n        const shouldBeExecuted = !isSilentRenewRunning;\r\n        if (!shouldBeExecuted) {\r\n            return of(null);\r\n        }\r\n        const { authWellknownEndpointUrl } = this.configurationProvider.getOpenIDConfiguration(configId) || {};\r\n        if (!authWellknownEndpointUrl) {\r\n            this.loggerService.logError(configId, 'no authWellKnownEndpoint given!');\r\n            return of(null);\r\n        }\r\n        return this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).pipe(switchMap(() => {\r\n            this.flowsDataService.setSilentRenewRunning(configId);\r\n            if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(configId)) {\r\n                // Refresh Session using Refresh tokens\r\n                return this.refreshSessionRefreshTokenService.refreshSessionWithRefreshTokens(configId, extraCustomParams);\r\n            }\r\n            return this.refreshSessionIframeService.refreshSessionWithIframe(configId, extraCustomParams);\r\n        }));\r\n    }\r\n    timeoutRetryStrategy(errorAttempts, configId) {\r\n        return errorAttempts.pipe(mergeMap((error, index) => {\r\n            const scalingDuration = 1000;\r\n            const currentAttempt = index + 1;\r\n            if (!(error instanceof TimeoutError) || currentAttempt > MAX_RETRY_ATTEMPTS) {\r\n                return throwError(() => new Error(error));\r\n            }\r\n            this.loggerService.logDebug(configId, `forceRefreshSession timeout. Attempt #${currentAttempt}`);\r\n            this.flowsDataService.resetSilentRenewRunning(configId);\r\n            return timer(currentAttempt * scalingDuration);\r\n        }));\r\n    }\r\n}\r\nRefreshSessionService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: RefreshSessionService, deps: [{ token: FlowHelper }, { token: ConfigurationProvider }, { token: FlowsDataService }, { token: LoggerService }, { token: SilentRenewService }, { token: AuthStateService }, { token: AuthWellKnownService }, { token: RefreshSessionIframeService }, { token: StoragePersistenceService }, { token: RefreshSessionRefreshTokenService }, { token: UserService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRefreshSessionService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: RefreshSessionService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: RefreshSessionService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: FlowHelper }, { type: ConfigurationProvider }, { type: FlowsDataService }, { type: LoggerService }, { type: SilentRenewService }, { type: AuthStateService }, { type: AuthWellKnownService }, { type: RefreshSessionIframeService }, { type: StoragePersistenceService }, { type: RefreshSessionRefreshTokenService }, { type: UserService }]; } });\n\nclass PeriodicallyTokenCheckService {\r\n    constructor(resetAuthDataService, flowHelper, configurationProvider, flowsDataService, loggerService, userService, authStateService, refreshSessionIframeService, refreshSessionRefreshTokenService, intervalService, storagePersistenceService, publicEventsService) {\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.flowHelper = flowHelper;\r\n        this.configurationProvider = configurationProvider;\r\n        this.flowsDataService = flowsDataService;\r\n        this.loggerService = loggerService;\r\n        this.userService = userService;\r\n        this.authStateService = authStateService;\r\n        this.refreshSessionIframeService = refreshSessionIframeService;\r\n        this.refreshSessionRefreshTokenService = refreshSessionRefreshTokenService;\r\n        this.intervalService = intervalService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.publicEventsService = publicEventsService;\r\n    }\r\n    startTokenValidationPeriodically() {\r\n        const configsWithSilentRenewEnabled = this.getConfigsWithSilentRenewEnabled();\r\n        if (configsWithSilentRenewEnabled.length <= 0) {\r\n            return;\r\n        }\r\n        const refreshTimeInSeconds = this.getSmallestRefreshTimeFromConfigs(configsWithSilentRenewEnabled);\r\n        if (!!this.intervalService.runTokenValidationRunning) {\r\n            return;\r\n        }\r\n        // START PERIODICALLY CHECK ONCE AND CHECK EACH CONFIG WHICH HAS IT ENABLED\r\n        const periodicallyCheck$ = this.intervalService.startPeriodicTokenCheck(refreshTimeInSeconds).pipe(switchMap(() => {\r\n            const objectWithConfigIdsAndRefreshEvent = {};\r\n            configsWithSilentRenewEnabled.forEach(({ configId }) => {\r\n                objectWithConfigIdsAndRefreshEvent[configId] = this.getRefreshEvent(configId);\r\n            });\r\n            return forkJoin(objectWithConfigIdsAndRefreshEvent);\r\n        }));\r\n        this.intervalService.runTokenValidationRunning = periodicallyCheck$.subscribe((objectWithConfigIds) => {\r\n            for (const [key, _] of Object.entries(objectWithConfigIds)) {\r\n                this.loggerService.logDebug(key, 'silent renew, periodic check finished!');\r\n                if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(key)) {\r\n                    this.flowsDataService.resetSilentRenewRunning(key);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    getRefreshEvent(configId) {\r\n        const shouldStartRefreshEvent = this.shouldStartPeriodicallyCheckForConfig(configId);\r\n        if (!shouldStartRefreshEvent) {\r\n            return of(null);\r\n        }\r\n        const refreshEvent$ = this.createRefreshEventForConfig(configId);\r\n        this.publicEventsService.fireEvent(EventTypes.SilentRenewStarted);\r\n        const refreshEventWithErrorHandler$ = refreshEvent$.pipe(catchError((error) => {\r\n            this.loggerService.logError(configId, 'silent renew failed!', error);\r\n            this.flowsDataService.resetSilentRenewRunning(configId);\r\n            return throwError(() => new Error(error));\r\n        }));\r\n        return refreshEventWithErrorHandler$;\r\n    }\r\n    getSmallestRefreshTimeFromConfigs(configsWithSilentRenewEnabled) {\r\n        const result = configsWithSilentRenewEnabled.reduce((prev, curr) => prev.tokenRefreshInSeconds < curr.tokenRefreshInSeconds ? prev : curr);\r\n        return result.tokenRefreshInSeconds;\r\n    }\r\n    getConfigsWithSilentRenewEnabled() {\r\n        return this.configurationProvider.getAllConfigurations().filter((x) => x.silentRenew);\r\n    }\r\n    createRefreshEventForConfig(configId) {\r\n        this.loggerService.logDebug(configId, 'starting silent renew...');\r\n        const config = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!(config === null || config === void 0 ? void 0 : config.silentRenew)) {\r\n            this.resetAuthDataService.resetAuthorizationData(configId);\r\n            return of(null);\r\n        }\r\n        this.flowsDataService.setSilentRenewRunning(configId);\r\n        if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(configId)) {\r\n            // Retrieve Dynamically Set Custom Params for refresh body\r\n            const customParamsRefresh = this.storagePersistenceService.read('storageCustomParamsRefresh', configId) || {};\r\n            const { customParamsRefreshTokenRequest } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n            const mergedParams = Object.assign(Object.assign({}, customParamsRefreshTokenRequest), customParamsRefresh);\r\n            // Refresh Session using Refresh tokens\r\n            return this.refreshSessionRefreshTokenService.refreshSessionWithRefreshTokens(configId, mergedParams);\r\n        }\r\n        // Retrieve Dynamically Set Custom Params\r\n        const customParams = this.storagePersistenceService.read('storageCustomParamsAuthRequest', configId);\r\n        return this.refreshSessionIframeService.refreshSessionWithIframe(configId, customParams);\r\n    }\r\n    shouldStartPeriodicallyCheckForConfig(configId) {\r\n        const idToken = this.authStateService.getIdToken(configId);\r\n        const isSilentRenewRunning = this.flowsDataService.isSilentRenewRunning(configId);\r\n        const userDataFromStore = this.userService.getUserDataFromStore(configId);\r\n        this.loggerService.logDebug(configId, `Checking: silentRenewRunning: ${isSilentRenewRunning} - has idToken: ${!!idToken} - has userData: ${!!userDataFromStore}`);\r\n        const shouldBeExecuted = !!userDataFromStore && !isSilentRenewRunning && !!idToken;\r\n        if (!shouldBeExecuted) {\r\n            return false;\r\n        }\r\n        const idTokenStillValid = this.authStateService.hasIdTokenExpiredAndRenewCheckIsEnabled(configId);\r\n        const accessTokenHasExpired = this.authStateService.hasAccessTokenExpiredIfExpiryExists(configId);\r\n        if (!idTokenStillValid && !accessTokenHasExpired) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\nPeriodicallyTokenCheckService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: PeriodicallyTokenCheckService, deps: [{ token: ResetAuthDataService }, { token: FlowHelper }, { token: ConfigurationProvider }, { token: FlowsDataService }, { token: LoggerService }, { token: UserService }, { token: AuthStateService }, { token: RefreshSessionIframeService }, { token: RefreshSessionRefreshTokenService }, { token: IntervalService }, { token: StoragePersistenceService }, { token: PublicEventsService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nPeriodicallyTokenCheckService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: PeriodicallyTokenCheckService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: PeriodicallyTokenCheckService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: ResetAuthDataService }, { type: FlowHelper }, { type: ConfigurationProvider }, { type: FlowsDataService }, { type: LoggerService }, { type: UserService }, { type: AuthStateService }, { type: RefreshSessionIframeService }, { type: RefreshSessionRefreshTokenService }, { type: IntervalService }, { type: StoragePersistenceService }, { type: PublicEventsService }]; } });\n\nclass PopUpService {\r\n    constructor() {\r\n        this.STORAGE_IDENTIFIER = 'popupauth';\r\n        this.resultInternal$ = new Subject();\r\n    }\r\n    get result$() {\r\n        return this.resultInternal$.asObservable();\r\n    }\r\n    isCurrentlyInPopup() {\r\n        if (this.canAccessSessionStorage()) {\r\n            const popup = sessionStorage.getItem(this.STORAGE_IDENTIFIER);\r\n            return !!window.opener && window.opener !== window && !!popup;\r\n        }\r\n        return false;\r\n    }\r\n    openPopUp(url, popupOptions) {\r\n        const optionsToPass = this.getOptions(popupOptions);\r\n        this.popUp = window.open(url, '_blank', optionsToPass);\r\n        this.popUp.sessionStorage.setItem(this.STORAGE_IDENTIFIER, 'true');\r\n        const listener = (event) => {\r\n            if (!(event === null || event === void 0 ? void 0 : event.data) || typeof event.data !== 'string') {\r\n                return;\r\n            }\r\n            this.resultInternal$.next({ userClosed: false, receivedUrl: event.data });\r\n            this.cleanUp(listener);\r\n        };\r\n        window.addEventListener('message', listener, false);\r\n        this.handle = window.setInterval(() => {\r\n            if (this.popUp.closed) {\r\n                this.resultInternal$.next({ userClosed: true });\r\n                this.cleanUp(listener);\r\n            }\r\n        }, 200);\r\n    }\r\n    sendMessageToMainWindow(url) {\r\n        if (window.opener) {\r\n            this.sendMessage(url, window.location.href);\r\n        }\r\n    }\r\n    cleanUp(listener) {\r\n        var _a;\r\n        window.removeEventListener('message', listener, false);\r\n        window.clearInterval(this.handle);\r\n        if (this.popUp) {\r\n            (_a = this.popUp.sessionStorage) === null || _a === void 0 ? void 0 : _a.removeItem(this.STORAGE_IDENTIFIER);\r\n            this.popUp.close();\r\n            this.popUp = null;\r\n        }\r\n    }\r\n    sendMessage(url, href) {\r\n        window.opener.postMessage(url, href);\r\n    }\r\n    getOptions(popupOptions) {\r\n        const popupDefaultOptions = { width: 500, height: 500, left: 50, top: 50 };\r\n        const options = Object.assign(Object.assign({}, popupDefaultOptions), (popupOptions || {}));\r\n        const left = window.screenLeft + (window.outerWidth - options.width) / 2;\r\n        const top = window.screenTop + (window.outerHeight - options.height) / 2;\r\n        options.left = left;\r\n        options.top = top;\r\n        return Object.entries(options)\r\n            .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`)\r\n            .join(',');\r\n    }\r\n    canAccessSessionStorage() {\r\n        return typeof navigator !== 'undefined' && navigator.cookieEnabled && typeof Storage !== 'undefined';\r\n    }\r\n}\r\nPopUpService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: PopUpService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nPopUpService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: PopUpService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: PopUpService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }] });\n\nclass CheckAuthService {\r\n    constructor(checkSessionService, currentUrlService, silentRenewService, userService, loggerService, configurationProvider, authStateService, callbackService, refreshSessionService, periodicallyTokenCheckService, popupService, autoLoginService, storagePersistenceService) {\r\n        this.checkSessionService = checkSessionService;\r\n        this.currentUrlService = currentUrlService;\r\n        this.silentRenewService = silentRenewService;\r\n        this.userService = userService;\r\n        this.loggerService = loggerService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.authStateService = authStateService;\r\n        this.callbackService = callbackService;\r\n        this.refreshSessionService = refreshSessionService;\r\n        this.periodicallyTokenCheckService = periodicallyTokenCheckService;\r\n        this.popupService = popupService;\r\n        this.autoLoginService = autoLoginService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n    }\r\n    checkAuth(passedConfigId, url) {\r\n        if (this.currentUrlService.currentUrlHasStateParam()) {\r\n            const stateParamFromUrl = this.currentUrlService.getStateParamFromCurrentUrl();\r\n            const config = this.getConfigurationWithUrlState(stateParamFromUrl);\r\n            if (!config) {\r\n                return throwError(() => new Error(`could not find matching config for state ${stateParamFromUrl}`));\r\n            }\r\n            return this.checkAuthWithConfig(config, url);\r\n        }\r\n        if (!!passedConfigId) {\r\n            const config = this.configurationProvider.getOpenIDConfiguration(passedConfigId);\r\n            return this.checkAuthWithConfig(config, url);\r\n        }\r\n        const onlyExistingConfig = this.configurationProvider.getOpenIDConfiguration();\r\n        return this.checkAuthWithConfig(onlyExistingConfig, url);\r\n    }\r\n    checkAuthMultiple(passedConfigId, url) {\r\n        if (this.currentUrlService.currentUrlHasStateParam()) {\r\n            const stateParamFromUrl = this.currentUrlService.getStateParamFromCurrentUrl();\r\n            const config = this.getConfigurationWithUrlState(stateParamFromUrl);\r\n            if (!config) {\r\n                return throwError(() => new Error(`could not find matching config for state ${stateParamFromUrl}`));\r\n            }\r\n            return this.composeMultipleLoginResults(config, url);\r\n        }\r\n        if (!!passedConfigId) {\r\n            const config = this.configurationProvider.getOpenIDConfiguration(passedConfigId);\r\n            if (!config) {\r\n                return throwError(() => new Error(`could not find matching config for id ${passedConfigId}`));\r\n            }\r\n            return this.composeMultipleLoginResults(config, url);\r\n        }\r\n        const allConfigs = this.configurationProvider.getAllConfigurations();\r\n        const allChecks$ = allConfigs.map((x) => this.checkAuthWithConfig(x, url));\r\n        return forkJoin(allChecks$);\r\n    }\r\n    checkAuthIncludingServer(configId) {\r\n        const config = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        return this.checkAuthWithConfig(config).pipe(switchMap((loginResponse) => {\r\n            const { isAuthenticated } = loginResponse;\r\n            if (isAuthenticated) {\r\n                return of(loginResponse);\r\n            }\r\n            return this.refreshSessionService.forceRefreshSession(configId).pipe(tap((loginResponseAfterRefreshSession) => {\r\n                if (loginResponseAfterRefreshSession === null || loginResponseAfterRefreshSession === void 0 ? void 0 : loginResponseAfterRefreshSession.isAuthenticated) {\r\n                    this.startCheckSessionAndValidation(configId);\r\n                }\r\n            }));\r\n        }));\r\n    }\r\n    checkAuthWithConfig(config, url) {\r\n        const { configId, authority } = config;\r\n        if (!this.configurationProvider.hasAtLeastOneConfig()) {\r\n            const errorMessage = 'Please provide at least one configuration before setting up the module';\r\n            this.loggerService.logError(configId, errorMessage);\r\n            return of({ isAuthenticated: false, errorMessage, userData: null, idToken: null, accessToken: null, configId });\r\n        }\r\n        const currentUrl = url || this.currentUrlService.getCurrentUrl();\r\n        this.loggerService.logDebug(configId, `Working with config '${configId}' using ${authority}`);\r\n        if (this.popupService.isCurrentlyInPopup()) {\r\n            this.popupService.sendMessageToMainWindow(currentUrl);\r\n            return of(null);\r\n        }\r\n        const isCallback = this.callbackService.isCallback(currentUrl);\r\n        this.loggerService.logDebug(configId, 'currentUrl to check auth with: ', currentUrl);\r\n        const callback$ = isCallback ? this.callbackService.handleCallbackAndFireEvents(currentUrl, configId) : of(null);\r\n        return callback$.pipe(map(() => {\r\n            const isAuthenticated = this.authStateService.areAuthStorageTokensValid(configId);\r\n            if (isAuthenticated) {\r\n                this.startCheckSessionAndValidation(configId);\r\n                if (!isCallback) {\r\n                    this.authStateService.setAuthenticatedAndFireEvent();\r\n                    this.userService.publishUserDataIfExists(configId);\r\n                }\r\n            }\r\n            this.loggerService.logDebug(configId, 'checkAuth completed - firing events now. isAuthenticated: ' + isAuthenticated);\r\n            return {\r\n                isAuthenticated,\r\n                userData: this.userService.getUserDataFromStore(configId),\r\n                accessToken: this.authStateService.getAccessToken(configId),\r\n                idToken: this.authStateService.getIdToken(configId),\r\n                configId,\r\n            };\r\n        }), tap(({ isAuthenticated }) => {\r\n            if (isAuthenticated) {\r\n                this.autoLoginService.checkSavedRedirectRouteAndNavigate(configId);\r\n            }\r\n        }), catchError(({ message }) => {\r\n            this.loggerService.logError(configId, message);\r\n            return of({ isAuthenticated: false, errorMessage: message, userData: null, idToken: null, accessToken: null, configId });\r\n        }));\r\n    }\r\n    startCheckSessionAndValidation(configId) {\r\n        if (this.checkSessionService.isCheckSessionConfigured(configId)) {\r\n            this.checkSessionService.start(configId);\r\n        }\r\n        this.periodicallyTokenCheckService.startTokenValidationPeriodically();\r\n        if (this.silentRenewService.isSilentRenewConfigured(configId)) {\r\n            this.silentRenewService.getOrCreateIframe(configId);\r\n        }\r\n    }\r\n    getConfigurationWithUrlState(stateFromUrl) {\r\n        const allConfigs = this.configurationProvider.getAllConfigurations();\r\n        for (const config of allConfigs) {\r\n            const storedState = this.storagePersistenceService.read('authStateControl', config.configId);\r\n            if (storedState === stateFromUrl) {\r\n                return config;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    composeMultipleLoginResults(activeConfig, url) {\r\n        const allOtherConfigs = this.configurationProvider.getAllConfigurations().filter((x) => x.configId !== activeConfig.configId);\r\n        const currentConfigResult = this.checkAuthWithConfig(activeConfig, url);\r\n        const allOtherConfigResults = allOtherConfigs.map((config) => {\r\n            const { redirectUrl } = config;\r\n            return this.checkAuthWithConfig(config, redirectUrl);\r\n        });\r\n        return forkJoin([currentConfigResult, ...allOtherConfigResults]);\r\n    }\r\n}\r\nCheckAuthService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CheckAuthService, deps: [{ token: CheckSessionService }, { token: CurrentUrlService }, { token: SilentRenewService }, { token: UserService }, { token: LoggerService }, { token: ConfigurationProvider }, { token: AuthStateService }, { token: CallbackService }, { token: RefreshSessionService }, { token: PeriodicallyTokenCheckService }, { token: PopUpService }, { token: AutoLoginService }, { token: StoragePersistenceService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCheckAuthService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CheckAuthService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CheckAuthService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: CheckSessionService }, { type: CurrentUrlService }, { type: SilentRenewService }, { type: UserService }, { type: LoggerService }, { type: ConfigurationProvider }, { type: AuthStateService }, { type: CallbackService }, { type: RefreshSessionService }, { type: PeriodicallyTokenCheckService }, { type: PopUpService }, { type: AutoLoginService }, { type: StoragePersistenceService }]; } });\n\nconst DEFAULT_CONFIG = {\r\n    authority: 'https://please_set',\r\n    authWellknownEndpointUrl: '',\r\n    authWellknownEndpoints: null,\r\n    redirectUrl: 'https://please_set',\r\n    clientId: 'please_set',\r\n    responseType: 'code',\r\n    scope: 'openid email profile',\r\n    hdParam: '',\r\n    postLogoutRedirectUri: 'https://please_set',\r\n    startCheckSession: false,\r\n    silentRenew: false,\r\n    silentRenewUrl: 'https://please_set',\r\n    silentRenewTimeoutInSeconds: 20,\r\n    renewTimeBeforeTokenExpiresInSeconds: 0,\r\n    useRefreshToken: false,\r\n    usePushedAuthorisationRequests: false,\r\n    ignoreNonceAfterRefresh: false,\r\n    postLoginRoute: '/',\r\n    forbiddenRoute: '/forbidden',\r\n    unauthorizedRoute: '/unauthorized',\r\n    autoUserInfo: true,\r\n    autoCleanStateAfterAuthentication: true,\r\n    triggerAuthorizationResultEvent: false,\r\n    logLevel: LogLevel.Warn,\r\n    issValidationOff: false,\r\n    historyCleanupOff: false,\r\n    maxIdTokenIatOffsetAllowedInSeconds: 120,\r\n    disableIatOffsetValidation: false,\r\n    storage: null,\r\n    customParamsAuthRequest: {},\r\n    customParamsRefreshTokenRequest: {},\r\n    customParamsEndSessionRequest: {},\r\n    customParamsCodeRequest: {},\r\n    eagerLoadAuthWellKnownEndpoints: true,\r\n    disableRefreshIdTokenAuthTimeValidation: false,\r\n    enableIdTokenExpiredValidationInRenew: true,\r\n    tokenRefreshInSeconds: 4,\r\n    refreshTokenRetryInSeconds: 3,\r\n    ngswBypass: false,\r\n};\n\nconst POSITIVE_VALIDATION_RESULT = {\r\n    result: true,\r\n    messages: [],\r\n    level: null,\r\n};\n\nconst ensureAuthority = (passedConfig) => {\r\n    if (!passedConfig.authority) {\r\n        return {\r\n            result: false,\r\n            messages: ['The authority URL MUST be provided in the configuration! '],\r\n            level: 'error',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst ensureClientId = (passedConfig) => {\r\n    if (!passedConfig.clientId) {\r\n        return {\r\n            result: false,\r\n            messages: ['The clientId is required and missing from your config!'],\r\n            level: 'error',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst createIdentifierToCheck = (passedConfig) => {\r\n    if (!passedConfig) {\r\n        return null;\r\n    }\r\n    const { authority, clientId, scope } = passedConfig;\r\n    return `${authority}${clientId}${scope}`;\r\n};\r\nconst arrayHasDuplicates = (array) => new Set(array).size !== array.length;\r\nconst ensureNoDuplicatedConfigsRule = (passedConfigs) => {\r\n    const allIdentifiers = passedConfigs.map((x) => createIdentifierToCheck(x));\r\n    const someAreNull = allIdentifiers.some((x) => x === null);\r\n    if (someAreNull) {\r\n        return {\r\n            result: false,\r\n            messages: [`Please make sure you add an object with a 'config' property: ....({ config }) instead of ...(config)`],\r\n            level: 'error',\r\n        };\r\n    }\r\n    const hasDuplicates = arrayHasDuplicates(allIdentifiers);\r\n    if (hasDuplicates) {\r\n        return {\r\n            result: false,\r\n            messages: ['You added multiple configs with the same authority, clientId and scope'],\r\n            level: 'warning',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst ensureRedirectRule = (passedConfig) => {\r\n    if (!passedConfig.redirectUrl) {\r\n        return {\r\n            result: false,\r\n            messages: ['The redirectUrl is required and missing from your config'],\r\n            level: 'error',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst ensureSilentRenewUrlWhenNoRefreshTokenUsed = (passedConfig) => {\r\n    const usesSilentRenew = passedConfig.silentRenew;\r\n    const usesRefreshToken = passedConfig.useRefreshToken;\r\n    const hasSilentRenewUrl = passedConfig.silentRenewUrl;\r\n    if (usesSilentRenew && !usesRefreshToken && !hasSilentRenewUrl) {\r\n        return {\r\n            result: false,\r\n            messages: ['Please provide a silent renew URL if using renew and not refresh tokens'],\r\n            level: 'error',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst useOfflineScopeWithSilentRenew = (passedConfig) => {\r\n    const hasRefreshToken = passedConfig.useRefreshToken;\r\n    const hasSilentRenew = passedConfig.silentRenew;\r\n    const scope = passedConfig.scope || '';\r\n    const hasOfflineScope = scope.split(' ').includes('offline_access');\r\n    if (hasRefreshToken && hasSilentRenew && !hasOfflineScope) {\r\n        return {\r\n            result: false,\r\n            messages: ['When using silent renew and refresh tokens please set the `offline_access` scope'],\r\n            level: 'warning',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst allRules = [\r\n    ensureAuthority,\r\n    useOfflineScopeWithSilentRenew,\r\n    ensureRedirectRule,\r\n    ensureClientId,\r\n    ensureSilentRenewUrlWhenNoRefreshTokenUsed,\r\n];\r\nconst allMultipleConfigRules = [ensureNoDuplicatedConfigsRule];\n\nclass ConfigValidationService {\r\n    constructor(loggerService) {\r\n        this.loggerService = loggerService;\r\n    }\r\n    validateConfigs(passedConfigs) {\r\n        return this.validateConfigsInternal(passedConfigs, allMultipleConfigRules);\r\n    }\r\n    validateConfig(passedConfig) {\r\n        return this.validateConfigInternal(passedConfig, allRules);\r\n    }\r\n    validateConfigsInternal(passedConfigs, allRulesToUse) {\r\n        const allValidationResults = allRulesToUse.map((rule) => rule(passedConfigs));\r\n        let overallErrorCount = 0;\r\n        passedConfigs.forEach((passedConfig) => {\r\n            const errorCount = this.processValidationResultsAndGetErrorCount(allValidationResults, passedConfig === null || passedConfig === void 0 ? void 0 : passedConfig.configId);\r\n            overallErrorCount += errorCount;\r\n        });\r\n        return overallErrorCount === 0;\r\n    }\r\n    validateConfigInternal(passedConfig, allRulesToUse) {\r\n        const allValidationResults = allRulesToUse.map((rule) => rule(passedConfig));\r\n        const errorCount = this.processValidationResultsAndGetErrorCount(allValidationResults, passedConfig.configId);\r\n        return errorCount === 0;\r\n    }\r\n    processValidationResultsAndGetErrorCount(allValidationResults, configId) {\r\n        const allMessages = allValidationResults.filter((x) => x.messages.length > 0);\r\n        const allErrorMessages = this.getAllMessagesOfType('error', allMessages);\r\n        const allWarnings = this.getAllMessagesOfType('warning', allMessages);\r\n        allErrorMessages.forEach((message) => this.loggerService.logError(configId, message));\r\n        allWarnings.forEach((message) => this.loggerService.logWarning(configId, message));\r\n        return allErrorMessages.length;\r\n    }\r\n    getAllMessagesOfType(type, results) {\r\n        const allMessages = results.filter((x) => x.level === type).map((result) => result.messages);\r\n        return allMessages.reduce((acc, val) => acc.concat(val), []);\r\n    }\r\n}\r\nConfigValidationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: ConfigValidationService, deps: [{ token: LoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nConfigValidationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: ConfigValidationService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: ConfigValidationService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }]; } });\n\nclass PlatformProvider {\r\n    constructor(platformId) {\r\n        this.platformId = platformId;\r\n    }\r\n    get isBrowser() {\r\n        return isPlatformBrowser(this.platformId);\r\n    }\r\n}\r\nPlatformProvider.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: PlatformProvider, deps: [{ token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });\r\nPlatformProvider.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: PlatformProvider });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: PlatformProvider, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () {\r\n        return [{ type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [PLATFORM_ID]\r\n                    }] }];\r\n    } });\n\nclass DefaultSessionStorageService {\r\n    read(key) {\r\n        return sessionStorage.getItem(key);\r\n    }\r\n    write(key, value) {\r\n        sessionStorage.setItem(key, value);\r\n    }\r\n    remove(key) {\r\n        sessionStorage.removeItem(key);\r\n    }\r\n    clear() {\r\n        sessionStorage.clear();\r\n    }\r\n}\r\nDefaultSessionStorageService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: DefaultSessionStorageService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nDefaultSessionStorageService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: DefaultSessionStorageService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: DefaultSessionStorageService, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nclass OidcConfigService {\r\n    constructor(loggerService, publicEventsService, configurationProvider, authWellKnownService, storagePersistenceService, configValidationService, platformProvider, defaultSessionStorageService) {\r\n        this.loggerService = loggerService;\r\n        this.publicEventsService = publicEventsService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.authWellKnownService = authWellKnownService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.configValidationService = configValidationService;\r\n        this.platformProvider = platformProvider;\r\n        this.defaultSessionStorageService = defaultSessionStorageService;\r\n    }\r\n    withConfigs(passedConfigs) {\r\n        if (!this.configValidationService.validateConfigs(passedConfigs)) {\r\n            return of(null);\r\n        }\r\n        this.createUniqueIds(passedConfigs);\r\n        const allHandleConfigs$ = passedConfigs.map((x) => this.handleConfig(x));\r\n        return forkJoin(allHandleConfigs$);\r\n    }\r\n    createUniqueIds(passedConfigs) {\r\n        passedConfigs.forEach((config, index) => {\r\n            if (!config.configId) {\r\n                config.configId = `${index}-${config.clientId}`;\r\n            }\r\n        });\r\n    }\r\n    handleConfig(passedConfig) {\r\n        if (!this.configValidationService.validateConfig(passedConfig)) {\r\n            this.loggerService.logError(passedConfig.configId, 'Validation of config rejected with errors. Config is NOT set.');\r\n            return of(null);\r\n        }\r\n        if (!passedConfig.authWellknownEndpointUrl) {\r\n            passedConfig.authWellknownEndpointUrl = passedConfig.authority;\r\n        }\r\n        const usedConfig = this.prepareConfig(passedConfig);\r\n        this.configurationProvider.setConfig(usedConfig);\r\n        const alreadyExistingAuthWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', usedConfig.configId);\r\n        if (!!alreadyExistingAuthWellKnownEndpoints) {\r\n            usedConfig.authWellknownEndpoints = alreadyExistingAuthWellKnownEndpoints;\r\n            this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, usedConfig);\r\n            return of(usedConfig);\r\n        }\r\n        const passedAuthWellKnownEndpoints = usedConfig.authWellknownEndpoints;\r\n        if (!!passedAuthWellKnownEndpoints) {\r\n            this.authWellKnownService.storeWellKnownEndpoints(usedConfig.configId, passedAuthWellKnownEndpoints);\r\n            usedConfig.authWellknownEndpoints = passedAuthWellKnownEndpoints;\r\n            this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, usedConfig);\r\n            return of(usedConfig);\r\n        }\r\n        if (usedConfig.eagerLoadAuthWellKnownEndpoints) {\r\n            return this.authWellKnownService.getAuthWellKnownEndPoints(usedConfig.authWellknownEndpointUrl, usedConfig.configId).pipe(catchError((error) => {\r\n                this.loggerService.logError(usedConfig.configId, 'Getting auth well known endpoints failed on start', error);\r\n                return throwError(() => new Error(error));\r\n            }), tap((wellknownEndPoints) => {\r\n                usedConfig.authWellknownEndpoints = wellknownEndPoints;\r\n                this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, usedConfig);\r\n            }), switchMap(() => of(usedConfig)));\r\n        }\r\n        else {\r\n            this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, usedConfig);\r\n            return of(usedConfig);\r\n        }\r\n    }\r\n    prepareConfig(configuration) {\r\n        const openIdConfigurationInternal = Object.assign(Object.assign({}, DEFAULT_CONFIG), configuration);\r\n        this.setSpecialCases(openIdConfigurationInternal);\r\n        this.setStorage(openIdConfigurationInternal);\r\n        return openIdConfigurationInternal;\r\n    }\r\n    setSpecialCases(currentConfig) {\r\n        if (!this.platformProvider.isBrowser) {\r\n            currentConfig.startCheckSession = false;\r\n            currentConfig.silentRenew = false;\r\n            currentConfig.useRefreshToken = false;\r\n            currentConfig.usePushedAuthorisationRequests = false;\r\n        }\r\n    }\r\n    setStorage(currentConfig) {\r\n        if (currentConfig.storage) {\r\n            return;\r\n        }\r\n        if (this.hasBrowserStorage()) {\r\n            currentConfig.storage = this.defaultSessionStorageService;\r\n        }\r\n        else {\r\n            currentConfig.storage = null;\r\n        }\r\n    }\r\n    hasBrowserStorage() {\r\n        return typeof navigator !== 'undefined' && navigator.cookieEnabled && typeof Storage !== 'undefined';\r\n    }\r\n}\r\nOidcConfigService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: OidcConfigService, deps: [{ token: LoggerService }, { token: PublicEventsService }, { token: ConfigurationProvider }, { token: AuthWellKnownService }, { token: StoragePersistenceService }, { token: ConfigValidationService }, { token: PlatformProvider }, { token: DefaultSessionStorageService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nOidcConfigService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: OidcConfigService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: OidcConfigService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: PublicEventsService }, { type: ConfigurationProvider }, { type: AuthWellKnownService }, { type: StoragePersistenceService }, { type: ConfigValidationService }, { type: PlatformProvider }, { type: DefaultSessionStorageService }]; } });\n\nclass OpenIdConfigLoader {\r\n}\r\nclass StsConfigLoader {\r\n}\r\nclass StsConfigStaticLoader {\r\n    constructor(passedConfigs) {\r\n        this.passedConfigs = passedConfigs;\r\n    }\r\n    loadConfigs() {\r\n        if (Array.isArray(this.passedConfigs)) {\r\n            return this.passedConfigs.map((x) => of(x));\r\n        }\r\n        const singleStaticConfig$ = of(this.passedConfigs);\r\n        return [singleStaticConfig$];\r\n    }\r\n}\r\nclass StsConfigHttpLoader {\r\n    constructor(configs$) {\r\n        this.configs$ = configs$;\r\n    }\r\n    loadConfigs() {\r\n        return Array.isArray(this.configs$) ? this.configs$ : [this.configs$];\r\n    }\r\n}\n\nclass ClosestMatchingRouteService {\r\n    constructor(configProvider) {\r\n        this.configProvider = configProvider;\r\n    }\r\n    getConfigIdForClosestMatchingRoute(route) {\r\n        const allConfiguredRoutes = this.getAllConfiguredRoutes();\r\n        for (const routesWithConfig of allConfiguredRoutes) {\r\n            const allRoutesForConfig = routesWithConfig.routes;\r\n            for (const configuredRoute of allRoutesForConfig) {\r\n                if (route.startsWith(configuredRoute)) {\r\n                    return {\r\n                        matchingRoute: configuredRoute,\r\n                        matchingConfigId: routesWithConfig.configId,\r\n                    };\r\n                }\r\n            }\r\n        }\r\n        return {\r\n            matchingRoute: null,\r\n            matchingConfigId: null,\r\n        };\r\n    }\r\n    getAllConfiguredRoutes() {\r\n        const allConfigurations = this.configProvider.getAllConfigurations();\r\n        return allConfigurations.map((x) => ({ routes: x.secureRoutes, configId: x.configId }));\r\n    }\r\n}\r\nClosestMatchingRouteService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: ClosestMatchingRouteService, deps: [{ token: ConfigurationProvider }], target: i0.ɵɵFactoryTarget.Injectable });\r\nClosestMatchingRouteService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: ClosestMatchingRouteService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: ClosestMatchingRouteService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: ConfigurationProvider }]; } });\n\nclass ResponseTypeValidationService {\r\n    constructor(loggerService, flowHelper) {\r\n        this.loggerService = loggerService;\r\n        this.flowHelper = flowHelper;\r\n    }\r\n    hasConfigValidResponseType(configId) {\r\n        if (this.flowHelper.isCurrentFlowAnyImplicitFlow(configId)) {\r\n            return true;\r\n        }\r\n        if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\r\n            return true;\r\n        }\r\n        this.loggerService.logWarning(configId, 'module configured incorrectly, invalid response_type. Check the responseType in the config');\r\n        return false;\r\n    }\r\n}\r\nResponseTypeValidationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: ResponseTypeValidationService, deps: [{ token: LoggerService }, { token: FlowHelper }], target: i0.ɵɵFactoryTarget.Injectable });\r\nResponseTypeValidationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: ResponseTypeValidationService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: ResponseTypeValidationService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: FlowHelper }]; } });\n\nclass RedirectService {\r\n    constructor(doc) {\r\n        this.doc = doc;\r\n    }\r\n    redirectTo(url) {\r\n        this.doc.location.href = url;\r\n    }\r\n}\r\nRedirectService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: RedirectService, deps: [{ token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRedirectService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: RedirectService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: RedirectService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () {\r\n        return [{ type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [DOCUMENT]\r\n                    }] }];\r\n    } });\n\nclass ParService {\r\n    constructor(loggerService, urlService, dataService, storagePersistenceService) {\r\n        this.loggerService = loggerService;\r\n        this.urlService = urlService;\r\n        this.dataService = dataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n    }\r\n    postParRequest(configId, customParams) {\r\n        let headers = new HttpHeaders();\r\n        headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\r\n        const authWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        if (!authWellKnownEndpoints) {\r\n            return throwError(() => new Error('Could not read PAR endpoint because authWellKnownEndPoints are not given'));\r\n        }\r\n        const parEndpoint = authWellKnownEndpoints.parEndpoint;\r\n        if (!parEndpoint) {\r\n            return throwError(() => new Error('Could not read PAR endpoint from authWellKnownEndpoints'));\r\n        }\r\n        return this.urlService.createBodyForParCodeFlowRequest(configId, customParams).pipe(switchMap((data) => {\r\n            return this.dataService.post(parEndpoint, data, configId, headers).pipe(retry(2), map((response) => {\r\n                this.loggerService.logDebug(configId, 'par response: ', response);\r\n                return {\r\n                    expiresIn: response.expires_in,\r\n                    requestUri: response.request_uri,\r\n                };\r\n            }), catchError((error) => {\r\n                const errorMessage = `There was an error on ParService postParRequest`;\r\n                this.loggerService.logError(configId, errorMessage, error);\r\n                return throwError(() => new Error(errorMessage));\r\n            }));\r\n        }));\r\n    }\r\n}\r\nParService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: ParService, deps: [{ token: LoggerService }, { token: UrlService }, { token: DataService }, { token: StoragePersistenceService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nParService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: ParService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: ParService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: UrlService }, { type: DataService }, { type: StoragePersistenceService }]; } });\n\nclass ParLoginService {\r\n    constructor(loggerService, responseTypeValidationService, urlService, redirectService, configurationProvider, authWellKnownService, popupService, checkAuthService, parService) {\r\n        this.loggerService = loggerService;\r\n        this.responseTypeValidationService = responseTypeValidationService;\r\n        this.urlService = urlService;\r\n        this.redirectService = redirectService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.authWellKnownService = authWellKnownService;\r\n        this.popupService = popupService;\r\n        this.checkAuthService = checkAuthService;\r\n        this.parService = parService;\r\n    }\r\n    loginPar(configId, authOptions) {\r\n        if (!this.responseTypeValidationService.hasConfigValidResponseType(configId)) {\r\n            this.loggerService.logError(configId, 'Invalid response type!');\r\n            return;\r\n        }\r\n        const { authWellknownEndpointUrl } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!authWellknownEndpointUrl) {\r\n            this.loggerService.logError(configId, 'no authWellknownEndpoint given!');\r\n            return;\r\n        }\r\n        this.loggerService.logDebug(configId, 'BEGIN Authorize OIDC Flow, no auth data');\r\n        const { urlHandler, customParams } = authOptions || {};\r\n        this.authWellKnownService\r\n            .getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId)\r\n            .pipe(switchMap(() => this.parService.postParRequest(configId, customParams)))\r\n            .subscribe((response) => {\r\n            this.loggerService.logDebug(configId, 'par response: ', response);\r\n            const url = this.urlService.getAuthorizeParUrl(response.requestUri, configId);\r\n            this.loggerService.logDebug(configId, 'par request url: ', url);\r\n            if (!url) {\r\n                this.loggerService.logError(configId, `Could not create URL with param ${response.requestUri}: '${url}'`);\r\n                return;\r\n            }\r\n            if (urlHandler) {\r\n                urlHandler(url);\r\n            }\r\n            else {\r\n                this.redirectService.redirectTo(url);\r\n            }\r\n        });\r\n    }\r\n    loginWithPopUpPar(configId, authOptions, popupOptions) {\r\n        if (!this.responseTypeValidationService.hasConfigValidResponseType(configId)) {\r\n            const errorMessage = 'Invalid response type!';\r\n            this.loggerService.logError(configId, errorMessage);\r\n            return throwError(() => new Error(errorMessage));\r\n        }\r\n        const { authWellknownEndpointUrl } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!authWellknownEndpointUrl) {\r\n            const errorMessage = 'no authWellknownEndpoint given!';\r\n            this.loggerService.logError(configId, errorMessage);\r\n            return throwError(() => new Error(errorMessage));\r\n        }\r\n        this.loggerService.logDebug(configId, 'BEGIN Authorize OIDC Flow with popup, no auth data');\r\n        const { customParams } = authOptions || {};\r\n        return this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).pipe(switchMap(() => this.parService.postParRequest(configId, customParams)), switchMap((response) => {\r\n            this.loggerService.logDebug(configId, 'par response: ', response);\r\n            const url = this.urlService.getAuthorizeParUrl(response.requestUri, configId);\r\n            this.loggerService.logDebug(configId, 'par request url: ', url);\r\n            if (!url) {\r\n                const errorMessage = `Could not create URL with param ${response.requestUri}: 'url'`;\r\n                this.loggerService.logError(configId, errorMessage);\r\n                return throwError(() => new Error(errorMessage));\r\n            }\r\n            this.popupService.openPopUp(url, popupOptions);\r\n            return this.popupService.result$.pipe(take(1), switchMap((result) => {\r\n                const { userClosed, receivedUrl } = result;\r\n                if (userClosed) {\r\n                    return of({\r\n                        isAuthenticated: false,\r\n                        errorMessage: 'User closed popup',\r\n                        userData: null,\r\n                        idToken: null,\r\n                        accessToken: null,\r\n                        configId,\r\n                    });\r\n                }\r\n                return this.checkAuthService.checkAuth(configId, receivedUrl);\r\n            }));\r\n        }));\r\n    }\r\n}\r\nParLoginService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: ParLoginService, deps: [{ token: LoggerService }, { token: ResponseTypeValidationService }, { token: UrlService }, { token: RedirectService }, { token: ConfigurationProvider }, { token: AuthWellKnownService }, { token: PopUpService }, { token: CheckAuthService }, { token: ParService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nParLoginService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: ParLoginService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: ParLoginService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: ResponseTypeValidationService }, { type: UrlService }, { type: RedirectService }, { type: ConfigurationProvider }, { type: AuthWellKnownService }, { type: PopUpService }, { type: CheckAuthService }, { type: ParService }]; } });\n\nclass PopUpLoginService {\r\n    constructor(loggerService, responseTypeValidationService, urlService, configurationProvider, authWellKnownService, popupService, checkAuthService) {\r\n        this.loggerService = loggerService;\r\n        this.responseTypeValidationService = responseTypeValidationService;\r\n        this.urlService = urlService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.authWellKnownService = authWellKnownService;\r\n        this.popupService = popupService;\r\n        this.checkAuthService = checkAuthService;\r\n    }\r\n    loginWithPopUpStandard(configId, authOptions, popupOptions) {\r\n        if (!this.responseTypeValidationService.hasConfigValidResponseType(configId)) {\r\n            const errorMessage = 'Invalid response type!';\r\n            this.loggerService.logError(configId, errorMessage);\r\n            return throwError(() => new Error(errorMessage));\r\n        }\r\n        const { authWellknownEndpointUrl } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!authWellknownEndpointUrl) {\r\n            const errorMessage = 'no authWellknownEndpoint given!';\r\n            this.loggerService.logError(configId, errorMessage);\r\n            return throwError(() => new Error(errorMessage));\r\n        }\r\n        this.loggerService.logDebug(configId, 'BEGIN Authorize OIDC Flow with popup, no auth data');\r\n        return this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).pipe(switchMap(() => {\r\n            const { customParams } = authOptions || {};\r\n            return this.urlService.getAuthorizeUrl(configId, customParams);\r\n        }), tap((authUrl) => this.popupService.openPopUp(authUrl, popupOptions)), switchMap(() => {\r\n            return this.popupService.result$.pipe(take(1), switchMap((result) => {\r\n                const { userClosed, receivedUrl } = result;\r\n                if (userClosed) {\r\n                    return of({\r\n                        isAuthenticated: false,\r\n                        errorMessage: 'User closed popup',\r\n                        userData: null,\r\n                        idToken: null,\r\n                        accessToken: null,\r\n                        configId,\r\n                    });\r\n                }\r\n                return this.checkAuthService.checkAuth(configId, receivedUrl);\r\n            }));\r\n        }));\r\n    }\r\n}\r\nPopUpLoginService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: PopUpLoginService, deps: [{ token: LoggerService }, { token: ResponseTypeValidationService }, { token: UrlService }, { token: ConfigurationProvider }, { token: AuthWellKnownService }, { token: PopUpService }, { token: CheckAuthService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nPopUpLoginService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: PopUpLoginService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: PopUpLoginService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: ResponseTypeValidationService }, { type: UrlService }, { type: ConfigurationProvider }, { type: AuthWellKnownService }, { type: PopUpService }, { type: CheckAuthService }]; } });\n\nclass StandardLoginService {\r\n    constructor(loggerService, responseTypeValidationService, urlService, redirectService, configurationProvider, authWellKnownService) {\r\n        this.loggerService = loggerService;\r\n        this.responseTypeValidationService = responseTypeValidationService;\r\n        this.urlService = urlService;\r\n        this.redirectService = redirectService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.authWellKnownService = authWellKnownService;\r\n    }\r\n    loginStandard(configId, authOptions) {\r\n        if (!this.responseTypeValidationService.hasConfigValidResponseType(configId)) {\r\n            this.loggerService.logError(configId, 'Invalid response type!');\r\n            return;\r\n        }\r\n        const { authWellknownEndpointUrl } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!authWellknownEndpointUrl) {\r\n            this.loggerService.logError(configId, 'no authWellknownEndpoint given!');\r\n            return;\r\n        }\r\n        this.loggerService.logDebug(configId, 'BEGIN Authorize OIDC Flow, no auth data');\r\n        this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).subscribe(() => {\r\n            const { urlHandler, customParams } = authOptions || {};\r\n            this.urlService.getAuthorizeUrl(configId, customParams).subscribe((url) => {\r\n                if (!url) {\r\n                    this.loggerService.logError(configId, 'Could not create URL', url);\r\n                    return;\r\n                }\r\n                if (urlHandler) {\r\n                    urlHandler(url);\r\n                }\r\n                else {\r\n                    this.redirectService.redirectTo(url);\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\nStandardLoginService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: StandardLoginService, deps: [{ token: LoggerService }, { token: ResponseTypeValidationService }, { token: UrlService }, { token: RedirectService }, { token: ConfigurationProvider }, { token: AuthWellKnownService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nStandardLoginService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: StandardLoginService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: StandardLoginService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: ResponseTypeValidationService }, { type: UrlService }, { type: RedirectService }, { type: ConfigurationProvider }, { type: AuthWellKnownService }]; } });\n\nclass LoginService {\r\n    constructor(configurationProvider, parLoginService, popUpLoginService, standardLoginService, storagePersistenceService) {\r\n        this.configurationProvider = configurationProvider;\r\n        this.parLoginService = parLoginService;\r\n        this.popUpLoginService = popUpLoginService;\r\n        this.standardLoginService = standardLoginService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n    }\r\n    login(configId, authOptions) {\r\n        if (authOptions === null || authOptions === void 0 ? void 0 : authOptions.customParams) {\r\n            this.storagePersistenceService.write('storageCustomParamsAuthRequest', authOptions.customParams, configId);\r\n        }\r\n        const { usePushedAuthorisationRequests } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (usePushedAuthorisationRequests) {\r\n            return this.parLoginService.loginPar(configId, authOptions);\r\n        }\r\n        else {\r\n            return this.standardLoginService.loginStandard(configId, authOptions);\r\n        }\r\n    }\r\n    loginWithPopUp(configId, authOptions, popupOptions) {\r\n        if (authOptions === null || authOptions === void 0 ? void 0 : authOptions.customParams) {\r\n            this.storagePersistenceService.write('storageCustomParamsAuthRequest', authOptions.customParams, configId);\r\n        }\r\n        const { usePushedAuthorisationRequests } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (usePushedAuthorisationRequests) {\r\n            return this.parLoginService.loginWithPopUpPar(configId, authOptions, popupOptions);\r\n        }\r\n        else {\r\n            return this.popUpLoginService.loginWithPopUpStandard(configId, authOptions, popupOptions);\r\n        }\r\n    }\r\n}\r\nLoginService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: LoginService, deps: [{ token: ConfigurationProvider }, { token: ParLoginService }, { token: PopUpLoginService }, { token: StandardLoginService }, { token: StoragePersistenceService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nLoginService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: LoginService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: LoginService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: ConfigurationProvider }, { type: ParLoginService }, { type: PopUpLoginService }, { type: StandardLoginService }, { type: StoragePersistenceService }]; } });\n\nclass LogoffRevocationService {\r\n    constructor(dataService, storagePersistenceService, loggerService, urlService, checkSessionService, resetAuthDataService, redirectService, configurationProvider) {\r\n        this.dataService = dataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.loggerService = loggerService;\r\n        this.urlService = urlService;\r\n        this.checkSessionService = checkSessionService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.redirectService = redirectService;\r\n        this.configurationProvider = configurationProvider;\r\n    }\r\n    // Logs out on the server and the local client.\r\n    // If the server state has changed, check session, then only a local logout.\r\n    logoff(configId, authOptions) {\r\n        const { urlHandler, customParams } = authOptions || {};\r\n        this.loggerService.logDebug(configId, 'logoff, remove auth ');\r\n        const endSessionUrl = this.getEndSessionUrl(configId, customParams);\r\n        this.resetAuthDataService.resetAuthorizationData(configId);\r\n        if (!endSessionUrl) {\r\n            this.loggerService.logDebug(configId, 'only local login cleaned up, no end_session_endpoint');\r\n            return;\r\n        }\r\n        if (this.checkSessionService.serverStateChanged(configId)) {\r\n            this.loggerService.logDebug(configId, 'only local login cleaned up, server session has changed');\r\n        }\r\n        else if (urlHandler) {\r\n            urlHandler(endSessionUrl);\r\n        }\r\n        else {\r\n            this.redirectService.redirectTo(endSessionUrl);\r\n        }\r\n    }\r\n    logoffLocal(configId) {\r\n        this.resetAuthDataService.resetAuthorizationData(configId);\r\n        this.checkSessionService.stop();\r\n    }\r\n    logoffLocalMultiple() {\r\n        const allConfigs = this.configurationProvider.getAllConfigurations();\r\n        allConfigs.forEach(({ configId }) => this.logoffLocal(configId));\r\n    }\r\n    // The refresh token and and the access token are revoked on the server. If the refresh token does not exist\r\n    // only the access token is revoked. Then the logout run.\r\n    logoffAndRevokeTokens(configId, authOptions) {\r\n        const { revocationEndpoint } = this.storagePersistenceService.read('authWellKnownEndPoints', configId) || {};\r\n        if (!revocationEndpoint) {\r\n            this.loggerService.logDebug(configId, 'revocation endpoint not supported');\r\n            this.logoff(configId, authOptions);\r\n        }\r\n        if (this.storagePersistenceService.getRefreshToken(configId)) {\r\n            return this.revokeRefreshToken(configId).pipe(switchMap((result) => this.revokeAccessToken(configId, result)), catchError((error) => {\r\n                const errorMessage = `revoke token failed`;\r\n                this.loggerService.logError(configId, errorMessage, error);\r\n                return throwError(() => new Error(errorMessage));\r\n            }), tap(() => this.logoff(configId, authOptions)));\r\n        }\r\n        else {\r\n            return this.revokeAccessToken(configId).pipe(catchError((error) => {\r\n                const errorMessage = `revoke accessToken failed`;\r\n                this.loggerService.logError(configId, errorMessage, error);\r\n                return throwError(() => new Error(errorMessage));\r\n            }), tap(() => this.logoff(configId, authOptions)));\r\n        }\r\n    }\r\n    // https://tools.ietf.org/html/rfc7009\r\n    // revokes an access token on the STS. If no token is provided, then the token from\r\n    // the storage is revoked. You can pass any token to revoke. This makes it possible to\r\n    // manage your own tokens. The is a public API.\r\n    revokeAccessToken(configId, accessToken) {\r\n        const accessTok = accessToken || this.storagePersistenceService.getAccessToken(configId);\r\n        const body = this.urlService.createRevocationEndpointBodyAccessToken(accessTok, configId);\r\n        return this.sendRevokeRequest(configId, body);\r\n    }\r\n    // https://tools.ietf.org/html/rfc7009\r\n    // revokes an refresh token on the STS. This is only required in the code flow with refresh tokens.\r\n    // If no token is provided, then the token from the storage is revoked. You can pass any token to revoke.\r\n    // This makes it possible to manage your own tokens.\r\n    revokeRefreshToken(configId, refreshToken) {\r\n        const refreshTok = refreshToken || this.storagePersistenceService.getRefreshToken(configId);\r\n        const body = this.urlService.createRevocationEndpointBodyRefreshToken(refreshTok, configId);\r\n        return this.sendRevokeRequest(configId, body);\r\n    }\r\n    getEndSessionUrl(configId, customParams) {\r\n        const idToken = this.storagePersistenceService.getIdToken(configId);\r\n        const { customParamsEndSessionRequest } = this.configurationProvider.getOpenIDConfiguration();\r\n        const mergedParams = Object.assign(Object.assign({}, customParamsEndSessionRequest), customParams);\r\n        return this.urlService.createEndSessionUrl(idToken, configId, mergedParams);\r\n    }\r\n    sendRevokeRequest(configId, body) {\r\n        const url = this.urlService.getRevocationEndpointUrl(configId);\r\n        let headers = new HttpHeaders();\r\n        headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\r\n        return this.dataService.post(url, body, configId, headers).pipe(retry(2), switchMap((response) => {\r\n            this.loggerService.logDebug(configId, 'revocation endpoint post response: ', response);\r\n            return of(response);\r\n        }), catchError((error) => {\r\n            const errorMessage = `Revocation request failed`;\r\n            this.loggerService.logError(configId, errorMessage, error);\r\n            return throwError(() => new Error(errorMessage));\r\n        }));\r\n    }\r\n}\r\nLogoffRevocationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: LogoffRevocationService, deps: [{ token: DataService }, { token: StoragePersistenceService }, { token: LoggerService }, { token: UrlService }, { token: CheckSessionService }, { token: ResetAuthDataService }, { token: RedirectService }, { token: ConfigurationProvider }], target: i0.ɵɵFactoryTarget.Injectable });\r\nLogoffRevocationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: LogoffRevocationService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: LogoffRevocationService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: DataService }, { type: StoragePersistenceService }, { type: LoggerService }, { type: UrlService }, { type: CheckSessionService }, { type: ResetAuthDataService }, { type: RedirectService }, { type: ConfigurationProvider }]; } });\n\nclass OidcSecurityService {\r\n    constructor(checkSessionService, checkAuthService, userService, tokenHelperService, configurationProvider, authStateService, flowsDataService, callbackService, logoffRevocationService, loginService, refreshSessionService, urlService) {\r\n        this.checkSessionService = checkSessionService;\r\n        this.checkAuthService = checkAuthService;\r\n        this.userService = userService;\r\n        this.tokenHelperService = tokenHelperService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.authStateService = authStateService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.callbackService = callbackService;\r\n        this.logoffRevocationService = logoffRevocationService;\r\n        this.loginService = loginService;\r\n        this.refreshSessionService = refreshSessionService;\r\n        this.urlService = urlService;\r\n    }\r\n    /**\r\n     * Provides information about the user after they have logged in.\r\n     *\r\n     * @returns Returns an object containing either the user data directly (single config) or\r\n     * the user data per config in case you are running with multiple configs\r\n     */\r\n    get userData$() {\r\n        return this.userService.userData$;\r\n    }\r\n    /**\r\n     * Emits each time an authorization event occurs.\r\n     *\r\n     * @returns Returns an object containing if you are authenticated or not.\r\n     * Single Config: true if config is authenticated, false if not.\r\n     * Multiple Configs: true is all configs are authenticated, false if only one of them is not\r\n     *\r\n     * The `allConfigsAuthenticated` property contains the auth information _per config_.\r\n     */\r\n    get isAuthenticated$() {\r\n        return this.authStateService.authenticated$;\r\n    }\r\n    /**\r\n     * Emits each time the server sends a CheckSession event and the value changed. This property will always return\r\n     * true.\r\n     */\r\n    get checkSessionChanged$() {\r\n        return this.checkSessionService.checkSessionChanged$;\r\n    }\r\n    /**\r\n     * Emits on a Security Token Service callback. The observable will never contain a value.\r\n     */\r\n    get stsCallback$() {\r\n        return this.callbackService.stsCallback$;\r\n    }\r\n    /**\r\n     * Returns the currently active OpenID configurations.\r\n     *\r\n     * @returns an array of OpenIdConfigurations.\r\n     */\r\n    getConfigurations() {\r\n        return this.configurationProvider.getAllConfigurations();\r\n    }\r\n    /**\r\n     * Returns a single active OpenIdConfiguration.\r\n     *\r\n     * @param configId The configId to identify the config. If not passed, the first one is being returned\r\n     */\r\n    getConfiguration(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration().configId;\r\n        return this.configurationProvider.getOpenIDConfiguration(configId);\r\n    }\r\n    /**\r\n     * Returns the userData for a configuration\r\n     *\r\n     * @param configId The configId to identify the config. If not passed, the first one is being used\r\n     */\r\n    getUserData(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration().configId;\r\n        return this.userService.getUserDataFromStore(configId);\r\n    }\r\n    /**\r\n     * Starts the complete setup flow for one configuration. Calling will start the entire authentication flow, and the returned observable\r\n     * will denote whether the user was successfully authenticated including the user data, the access token, the configId and\r\n     * an error message in case an error happened\r\n     *\r\n     * @param url The URL to perform the authorization on the behalf of.\r\n     * @param configId The configId to perform the authorization on the behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An object `LoginResponse` containing all information about the login\r\n     */\r\n    checkAuth(url, configId) {\r\n        return this.checkAuthService.checkAuth(configId, url);\r\n    }\r\n    /**\r\n     * Starts the complete setup flow for multiple configurations.\r\n     * Calling will start the entire authentication flow, and the returned observable\r\n     * will denote whether the user was successfully authenticated including the user data, the access token, the configId and\r\n     * an error message in case an error happened in an array for each config which was provided\r\n     *\r\n     * @param url The URL to perform the authorization on the behalf of.\r\n     * @param configId The configId to perform the authorization on the behalf of. If not passed, all of the current\r\n     * configured ones will be used to check.\r\n     *\r\n     * @returns An array of `LoginResponse` objects containing all information about the logins\r\n     */\r\n    checkAuthMultiple(url, configId) {\r\n        return this.checkAuthService.checkAuthMultiple(configId, url);\r\n    }\r\n    /**\r\n     * Provides information about the current authenticated state\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A boolean whether the config is authenticated or not.\r\n     */\r\n    isAuthenticated(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.authStateService.isAuthenticated(configId);\r\n    }\r\n    /**\r\n     * Checks the server for an authenticated session using the iframe silent renew if not locally authenticated.\r\n     */\r\n    checkAuthIncludingServer(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.checkAuthService.checkAuthIncludingServer(configId);\r\n    }\r\n    /**\r\n     * Returns the access token for the login scenario.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A string with the access token.\r\n     */\r\n    getAccessToken(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.authStateService.getAccessToken(configId);\r\n    }\r\n    /**\r\n     * Returns the ID token for the sign-in.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A string with the id token.\r\n     */\r\n    getIdToken(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.authStateService.getIdToken(configId);\r\n    }\r\n    /**\r\n     * Returns the refresh token, if present, for the sign-in.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A string with the refresh token.\r\n     */\r\n    getRefreshToken(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.authStateService.getRefreshToken(configId);\r\n    }\r\n    /**\r\n     * Returns the authentication result, if present, for the sign-in.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A object with the authentication result\r\n     */\r\n    getAuthenticationResult(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.authStateService.getAuthenticationResult(configId);\r\n    }\r\n    /**\r\n     * Returns the payload from the ID token.\r\n     *\r\n     * @param encode Set to true if the payload is base64 encoded\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns The payload from the id token.\r\n     */\r\n    getPayloadFromIdToken(encode = false, configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        const token = this.authStateService.getIdToken(configId);\r\n        return this.tokenHelperService.getPayloadFromToken(token, encode, configId);\r\n    }\r\n    /**\r\n     * Sets a custom state for the authorize request.\r\n     *\r\n     * @param state The state to set.\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     */\r\n    setState(state, configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        this.flowsDataService.setAuthStateControl(state, configId);\r\n    }\r\n    /**\r\n     * Gets the state value used for the authorize request.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns The state value used for the authorize request.\r\n     */\r\n    getState(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.flowsDataService.getAuthStateControl(configId);\r\n    }\r\n    /**\r\n     * Redirects the user to the Security Token Service to begin the authentication process.\r\n     *\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     * @param authOptions The custom options for the the authentication request.\r\n     */\r\n    authorize(configId, authOptions) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        this.loginService.login(configId, authOptions);\r\n    }\r\n    /**\r\n     * Opens the Security Token Service in a new window to begin the authentication process.\r\n     *\r\n     * @param authOptions The custom options for the authentication request.\r\n     * @param popupOptions The configuration for the popup window.\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An `Observable<LoginResponse>` containing all information about the login\r\n     */\r\n    authorizeWithPopUp(authOptions, popupOptions, configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.loginService.loginWithPopUp(configId, authOptions, popupOptions);\r\n    }\r\n    /**\r\n     * Manually refreshes the session.\r\n     *\r\n     * @param customParams Custom parameters to pass to the refresh request.\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An `Observable<LoginResponse>` containing all information about the login\r\n     */\r\n    forceRefreshSession(customParams, configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.refreshSessionService.userForceRefreshSession(configId, customParams);\r\n    }\r\n    /**\r\n     * Revokes the refresh token (if present) and the access token on the server and then performs the logoff operation.\r\n     * The refresh token and and the access token are revoked on the server. If the refresh token does not exist\r\n     * only the access token is revoked. Then the logout run.\r\n     *\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     * @param authOptions The custom options for the request.\r\n     *\r\n     * @returns An observable when the action is finished\r\n     */\r\n    logoffAndRevokeTokens(configId, authOptions) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.logoffRevocationService.logoffAndRevokeTokens(configId, authOptions);\r\n    }\r\n    /**\r\n     * Logs out on the server and the local client. If the server state has changed, confirmed via check session,\r\n     * then only a local logout is performed.\r\n     *\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     * @param authOptions with custom parameters and/or an custom url handler\r\n     */\r\n    logoff(configId, authOptions) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.logoffRevocationService.logoff(configId, authOptions);\r\n    }\r\n    /**\r\n     * Logs the user out of the application without logging them out of the server.\r\n     * Use this method if you have _one_ config enabled.\r\n     *\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     */\r\n    logoffLocal(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.logoffRevocationService.logoffLocal(configId);\r\n    }\r\n    /**\r\n     * Logs the user out of the application for all configs without logging them out of the server.\r\n     * Use this method if you have _multiple_ configs enabled.\r\n     */\r\n    logoffLocalMultiple() {\r\n        return this.logoffRevocationService.logoffLocalMultiple();\r\n    }\r\n    /**\r\n     * Revokes an access token on the Security Token Service. This is only required in the code flow with refresh tokens. If no token is\r\n     * provided, then the token from the storage is revoked. You can pass any token to revoke.\r\n     * https://tools.ietf.org/html/rfc7009\r\n     *\r\n     * @param accessToken The access token to revoke.\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An observable when the action is finished\r\n     */\r\n    revokeAccessToken(accessToken, configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.logoffRevocationService.revokeAccessToken(configId, accessToken);\r\n    }\r\n    /**\r\n     * Revokes a refresh token on the Security Token Service. This is only required in the code flow with refresh tokens. If no token is\r\n     * provided, then the token from the storage is revoked. You can pass any token to revoke.\r\n     * https://tools.ietf.org/html/rfc7009\r\n     *\r\n     * @param refreshToken The access token to revoke.\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An observable when the action is finished\r\n     */\r\n    revokeRefreshToken(refreshToken, configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.logoffRevocationService.revokeRefreshToken(configId, refreshToken);\r\n    }\r\n    /**\r\n     * Creates the end session URL which can be used to implement an alternate server logout.\r\n     *\r\n     * @param customParams\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A string with the end session url or null\r\n     */\r\n    getEndSessionUrl(customParams, configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.logoffRevocationService.getEndSessionUrl(configId, customParams);\r\n    }\r\n    /**\r\n     * Creates the authorize URL based on your flow\r\n     *\r\n     * @param customParams\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A string with the authorize URL or null\r\n     */\r\n    getAuthorizeUrl(customParams, configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.urlService.getAuthorizeUrl(configId, customParams);\r\n    }\r\n}\r\nOidcSecurityService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: OidcSecurityService, deps: [{ token: CheckSessionService }, { token: CheckAuthService }, { token: UserService }, { token: TokenHelperService }, { token: ConfigurationProvider }, { token: AuthStateService }, { token: FlowsDataService }, { token: CallbackService }, { token: LogoffRevocationService }, { token: LoginService }, { token: RefreshSessionService }, { token: UrlService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nOidcSecurityService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: OidcSecurityService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: OidcSecurityService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: CheckSessionService }, { type: CheckAuthService }, { type: UserService }, { type: TokenHelperService }, { type: ConfigurationProvider }, { type: AuthStateService }, { type: FlowsDataService }, { type: CallbackService }, { type: LogoffRevocationService }, { type: LoginService }, { type: RefreshSessionService }, { type: UrlService }]; } });\n\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\r\nfunction createStaticLoader(passedConfig) {\r\n    return new StsConfigStaticLoader(passedConfig.config);\r\n}\r\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\r\nfunction configurationProviderFactory(oidcConfigService, loader) {\r\n    const allConfigs$ = forkJoin(loader.loadConfigs());\r\n    const fn = () => allConfigs$.pipe(switchMap((configs) => oidcConfigService.withConfigs(configs)));\r\n    return fn;\r\n}\r\nconst PASSED_CONFIG = new InjectionToken('PASSED_CONFIG');\r\nclass AuthModule {\r\n    static forRoot(passedConfig) {\r\n        return {\r\n            ngModule: AuthModule,\r\n            providers: [\r\n                // Make the PASSED_CONFIG available through injection\r\n                { provide: PASSED_CONFIG, useValue: passedConfig },\r\n                // Create the loader: Either the one getting passed or a static one\r\n                (passedConfig === null || passedConfig === void 0 ? void 0 : passedConfig.loader) || { provide: StsConfigLoader, useFactory: createStaticLoader, deps: [PASSED_CONFIG] },\r\n                // Load the config when the app starts\r\n                {\r\n                    provide: APP_INITIALIZER,\r\n                    multi: true,\r\n                    deps: [OidcConfigService, StsConfigLoader, PASSED_CONFIG],\r\n                    useFactory: configurationProviderFactory,\r\n                },\r\n                OidcConfigService,\r\n                PublicEventsService,\r\n                FlowHelper,\r\n                ConfigurationProvider,\r\n                OidcSecurityService,\r\n                TokenValidationService,\r\n                PlatformProvider,\r\n                CheckSessionService,\r\n                FlowsDataService,\r\n                FlowsService,\r\n                SilentRenewService,\r\n                LogoffRevocationService,\r\n                UserService,\r\n                RandomService,\r\n                HttpBaseService,\r\n                UrlService,\r\n                AuthStateService,\r\n                SigninKeyDataService,\r\n                StoragePersistenceService,\r\n                TokenHelperService,\r\n                LoggerService,\r\n                IFrameService,\r\n                EqualityService,\r\n                LoginService,\r\n                ParService,\r\n                AuthWellKnownDataService,\r\n                AuthWellKnownService,\r\n                DataService,\r\n                StateValidationService,\r\n                ConfigValidationService,\r\n                CheckAuthService,\r\n                ResetAuthDataService,\r\n                ImplicitFlowCallbackService,\r\n                HistoryJwtKeysCallbackHandlerService,\r\n                ResponseTypeValidationService,\r\n                UserCallbackHandlerService,\r\n                StateValidationCallbackHandlerService,\r\n                RefreshSessionCallbackHandlerService,\r\n                RefreshTokenCallbackHandlerService,\r\n                CodeFlowCallbackHandlerService,\r\n                ImplicitFlowCallbackHandlerService,\r\n                ParLoginService,\r\n                PopUpLoginService,\r\n                StandardLoginService,\r\n                AutoLoginService,\r\n                JwtWindowCryptoService,\r\n                CurrentUrlService,\r\n                ClosestMatchingRouteService,\r\n                DefaultSessionStorageService,\r\n                BrowserStorageService,\r\n            ],\r\n        };\r\n    }\r\n}\r\nAuthModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: AuthModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\r\nAuthModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: AuthModule, imports: [CommonModule, HttpClientModule] });\r\nAuthModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: AuthModule, imports: [[CommonModule, HttpClientModule]] });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: AuthModule, decorators: [{\r\n            type: NgModule,\r\n            args: [{\r\n                    imports: [CommonModule, HttpClientModule],\r\n                    declarations: [],\r\n                    exports: [],\r\n                }]\r\n        }] });\n\nclass AutoLoginAllRoutesGuard {\r\n    constructor(autoLoginService, checkAuthService, loginService, configurationProvider) {\r\n        this.autoLoginService = autoLoginService;\r\n        this.checkAuthService = checkAuthService;\r\n        this.loginService = loginService;\r\n        this.configurationProvider = configurationProvider;\r\n    }\r\n    canLoad(route, segments) {\r\n        const routeToRedirect = segments.join('/');\r\n        return this.checkAuth(routeToRedirect);\r\n    }\r\n    canActivate(route, state) {\r\n        return this.checkAuth(state.url);\r\n    }\r\n    canActivateChild(route, state) {\r\n        return this.checkAuth(state.url);\r\n    }\r\n    checkAuth(url) {\r\n        const configId = this.getId();\r\n        return this.checkAuthService.checkAuth().pipe(take(1), map(({ isAuthenticated }) => {\r\n            if (isAuthenticated) {\r\n                this.autoLoginService.checkSavedRedirectRouteAndNavigate(configId);\r\n            }\r\n            if (!isAuthenticated) {\r\n                this.autoLoginService.saveRedirectRoute(configId, url);\r\n                this.loginService.login(configId);\r\n            }\r\n            return isAuthenticated;\r\n        }));\r\n    }\r\n    getId() {\r\n        return this.configurationProvider.getOpenIDConfiguration().configId;\r\n    }\r\n}\r\nAutoLoginAllRoutesGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: AutoLoginAllRoutesGuard, deps: [{ token: AutoLoginService }, { token: CheckAuthService }, { token: LoginService }, { token: ConfigurationProvider }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAutoLoginAllRoutesGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: AutoLoginAllRoutesGuard, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: AutoLoginAllRoutesGuard, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: AutoLoginService }, { type: CheckAuthService }, { type: LoginService }, { type: ConfigurationProvider }]; } });\n\nclass AutoLoginPartialRoutesGuard {\r\n    constructor(autoLoginService, authStateService, loginService, configurationProvider) {\r\n        this.autoLoginService = autoLoginService;\r\n        this.authStateService = authStateService;\r\n        this.loginService = loginService;\r\n        this.configurationProvider = configurationProvider;\r\n    }\r\n    canLoad(route, segments) {\r\n        const routeToRedirect = segments.join('/');\r\n        return this.checkAuth(routeToRedirect);\r\n    }\r\n    canActivate(route, state) {\r\n        return this.checkAuth(state.url);\r\n    }\r\n    canActivateChild(route, state) {\r\n        return this.checkAuth(state.url);\r\n    }\r\n    checkAuth(url) {\r\n        const configId = this.getId();\r\n        const isAuthenticated = this.authStateService.areAuthStorageTokensValid(configId);\r\n        if (isAuthenticated) {\r\n            this.autoLoginService.checkSavedRedirectRouteAndNavigate(configId);\r\n        }\r\n        if (!isAuthenticated) {\r\n            this.autoLoginService.saveRedirectRoute(configId, url);\r\n            this.loginService.login(configId);\r\n        }\r\n        return isAuthenticated;\r\n    }\r\n    getId() {\r\n        return this.configurationProvider.getOpenIDConfiguration().configId;\r\n    }\r\n}\r\nAutoLoginPartialRoutesGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: AutoLoginPartialRoutesGuard, deps: [{ token: AutoLoginService }, { token: AuthStateService }, { token: LoginService }, { token: ConfigurationProvider }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAutoLoginPartialRoutesGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: AutoLoginPartialRoutesGuard, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: AutoLoginPartialRoutesGuard, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: AutoLoginService }, { type: AuthStateService }, { type: LoginService }, { type: ConfigurationProvider }]; } });\n\nclass AuthInterceptor {\r\n    constructor(authStateService, configurationProvider, loggerService, closestMatchingRouteService) {\r\n        this.authStateService = authStateService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.loggerService = loggerService;\r\n        this.closestMatchingRouteService = closestMatchingRouteService;\r\n    }\r\n    intercept(req, next) {\r\n        if (!this.configurationProvider.hasAtLeastOneConfig()) {\r\n            return next.handle(req);\r\n        }\r\n        const allConfigurations = this.configurationProvider.getAllConfigurations();\r\n        const allRoutesConfigured = allConfigurations.map((x) => x.secureRoutes || []);\r\n        const allRoutesConfiguredFlat = [].concat.apply([], allRoutesConfigured);\r\n        if (allRoutesConfiguredFlat.length === 0) {\r\n            const { configId } = allConfigurations[0];\r\n            this.loggerService.logDebug(configId, `No routes to check configured`);\r\n            return next.handle(req);\r\n        }\r\n        const { matchingConfigId, matchingRoute } = this.closestMatchingRouteService.getConfigIdForClosestMatchingRoute(req.url);\r\n        if (!matchingConfigId) {\r\n            const { configId } = allConfigurations[0];\r\n            this.loggerService.logDebug(configId, `Did not find any configured route for route ${req.url}`);\r\n            return next.handle(req);\r\n        }\r\n        this.loggerService.logDebug(matchingConfigId, `'${req.url}' matches configured route '${matchingRoute}'`);\r\n        const token = this.authStateService.getAccessToken(matchingConfigId);\r\n        if (!token) {\r\n            this.loggerService.logDebug(matchingConfigId, `Wanted to add token to ${req.url} but found no token: '${token}'`);\r\n            return next.handle(req);\r\n        }\r\n        this.loggerService.logDebug(matchingConfigId, `'${req.url}' matches configured route '${matchingRoute}', adding token`);\r\n        req = req.clone({\r\n            headers: req.headers.set('Authorization', 'Bearer ' + token),\r\n        });\r\n        return next.handle(req);\r\n    }\r\n}\r\nAuthInterceptor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: AuthInterceptor, deps: [{ token: AuthStateService }, { token: ConfigurationProvider }, { token: LoggerService }, { token: ClosestMatchingRouteService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAuthInterceptor.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: AuthInterceptor });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: AuthInterceptor, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: AuthStateService }, { type: ConfigurationProvider }, { type: LoggerService }, { type: ClosestMatchingRouteService }]; } });\n\n/**\r\n * Implement this class-interface to create a custom storage.\r\n */\r\nclass AbstractSecurityStorage {\r\n}\r\nAbstractSecurityStorage.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: AbstractSecurityStorage, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nAbstractSecurityStorage.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: AbstractSecurityStorage });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: AbstractSecurityStorage, decorators: [{\r\n            type: Injectable\r\n        }] });\n\n// Public classes.\n\n/*\r\n * Public API Surface of angular-auth-oidc-client\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { AbstractSecurityStorage, AuthInterceptor, AuthModule, AutoLoginAllRoutesGuard, AutoLoginPartialRoutesGuard, EventTypes, LogLevel, LoggerService, OidcConfigService, OidcSecurityService, OpenIdConfigLoader, PASSED_CONFIG, PopUpService, PublicEventsService, StateValidationResult, StsConfigHttpLoader, StsConfigLoader, StsConfigStaticLoader, TokenHelperService, TokenValidationService, ValidationResult, configurationProviderFactory, createStaticLoader };\n"]},"metadata":{},"sourceType":"module"}