{"ast":null,"code":"import { DOCUMENT, isPlatformBrowser, CommonModule } from '@angular/common';\nimport * as i1 from '@angular/common/http';\nimport { HttpHeaders, HttpParams, HttpErrorResponse, HttpResponse, HttpClientModule } from '@angular/common/http';\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject, PLATFORM_ID, InjectionToken, APP_INITIALIZER, NgModule } from '@angular/core';\nimport { ReplaySubject, BehaviorSubject, throwError, of, timer, Observable, Subject, forkJoin, TimeoutError } from 'rxjs';\nimport { distinctUntilChanged, switchMap, retryWhen, catchError, mergeMap, map, retry, tap, concatMap, take, timeout } from 'rxjs/operators';\nimport { KJUR, hextob64u, KEYUTIL } from 'jsrsasign-reduced';\nimport * as i2 from '@angular/router';\n\nclass HttpBaseService {\n  constructor(http) {\n    this.http = http;\n  }\n\n  get(url, params) {\n    return this.http.get(url, params);\n  }\n\n  post(url, body, params) {\n    return this.http.post(url, body, params);\n  }\n\n}\n\nHttpBaseService.ɵfac = function HttpBaseService_Factory(t) {\n  return new (t || HttpBaseService)(i0.ɵɵinject(i1.HttpClient));\n};\n\nHttpBaseService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: HttpBaseService,\n  factory: HttpBaseService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(HttpBaseService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i1.HttpClient\n    }];\n  }, null);\n})();\n\nclass ConfigurationProvider {\n  constructor() {\n    this.configsInternal = {};\n  }\n\n  hasAsLeastOneConfig() {\n    return Object.keys(this.configsInternal).length > 0;\n  }\n\n  hasManyConfigs() {\n    return Object.keys(this.configsInternal).length > 1;\n  }\n\n  setConfig(readyConfig) {\n    const {\n      configId\n    } = readyConfig;\n    this.configsInternal[configId] = readyConfig;\n  }\n\n  getOpenIDConfiguration(configId) {\n    if (!!configId) {\n      return this.configsInternal[configId] || null;\n    }\n\n    const [, value] = Object.entries(this.configsInternal)[0] || [[null, null]];\n    return value || null;\n  }\n\n  getAllConfigurations() {\n    return Object.values(this.configsInternal);\n  }\n\n}\n\nConfigurationProvider.ɵfac = function ConfigurationProvider_Factory(t) {\n  return new (t || ConfigurationProvider)();\n};\n\nConfigurationProvider.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ConfigurationProvider,\n  factory: ConfigurationProvider.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ConfigurationProvider, [{\n    type: Injectable\n  }], null, null);\n})();\n\nconst NGSW_CUSTOM_PARAM = 'ngsw-bypass';\n\nclass DataService {\n  constructor(httpClient, configurationProvider) {\n    this.httpClient = httpClient;\n    this.configurationProvider = configurationProvider;\n  }\n\n  get(url, configId, token) {\n    const headers = this.prepareHeaders(token);\n    const params = this.prepareParams(configId);\n    return this.httpClient.get(url, {\n      headers,\n      params\n    });\n  }\n\n  post(url, body, configId, headersParams) {\n    const headers = headersParams || this.prepareHeaders();\n    const params = this.prepareParams(configId);\n    return this.httpClient.post(url, body, {\n      headers,\n      params\n    });\n  }\n\n  prepareHeaders(token) {\n    let headers = new HttpHeaders();\n    headers = headers.set('Accept', 'application/json');\n\n    if (!!token) {\n      headers = headers.set('Authorization', 'Bearer ' + decodeURIComponent(token));\n    }\n\n    return headers;\n  }\n\n  prepareParams(configId) {\n    let params = new HttpParams();\n    const {\n      ngswBypass\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (ngswBypass) {\n      params = params.set(NGSW_CUSTOM_PARAM, '');\n    }\n\n    return params;\n  }\n\n}\n\nDataService.ɵfac = function DataService_Factory(t) {\n  return new (t || DataService)(i0.ɵɵinject(HttpBaseService), i0.ɵɵinject(ConfigurationProvider));\n};\n\nDataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DataService,\n  factory: DataService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: HttpBaseService\n    }, {\n      type: ConfigurationProvider\n    }];\n  }, null);\n})(); // eslint-disable-next-line no-shadow\n\n\nvar EventTypes;\n\n(function (EventTypes) {\n  /**\r\n   *  This only works in the AppModule Constructor\r\n   */\n  EventTypes[EventTypes[\"ConfigLoaded\"] = 0] = \"ConfigLoaded\";\n  EventTypes[EventTypes[\"ConfigLoadingFailed\"] = 1] = \"ConfigLoadingFailed\";\n  EventTypes[EventTypes[\"CheckSessionReceived\"] = 2] = \"CheckSessionReceived\";\n  EventTypes[EventTypes[\"UserDataChanged\"] = 3] = \"UserDataChanged\";\n  EventTypes[EventTypes[\"NewAuthenticationResult\"] = 4] = \"NewAuthenticationResult\";\n  EventTypes[EventTypes[\"TokenExpired\"] = 5] = \"TokenExpired\";\n  EventTypes[EventTypes[\"IdTokenExpired\"] = 6] = \"IdTokenExpired\";\n  EventTypes[EventTypes[\"SilentRenewStarted\"] = 7] = \"SilentRenewStarted\";\n})(EventTypes || (EventTypes = {})); // eslint-disable-next-line no-shadow\n\n\nvar LogLevel;\n\n(function (LogLevel) {\n  LogLevel[LogLevel[\"None\"] = 0] = \"None\";\n  LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\n  LogLevel[LogLevel[\"Warn\"] = 2] = \"Warn\";\n  LogLevel[LogLevel[\"Error\"] = 3] = \"Error\";\n})(LogLevel || (LogLevel = {}));\n\nclass LoggerService {\n  constructor(configurationProvider) {\n    this.configurationProvider = configurationProvider;\n  }\n\n  logError(configId, message, ...args) {\n    if (!!configId) {\n      this.logErrorWithConfig(configId, message, ...args);\n    } else {\n      this.logErrorWithoutConfig(message, ...args);\n    }\n  }\n\n  logWarning(configId, message, ...args) {\n    if (!!configId) {\n      this.logWarningWithConfig(configId, message, ...args);\n    } else {\n      this.logWarningWithoutConfig(message, ...args);\n    }\n  }\n\n  logDebug(configId, message, ...args) {\n    if (!this.logLevelIsSet(configId)) {\n      return;\n    }\n\n    if (this.loggingIsTurnedOff(configId)) {\n      return;\n    }\n\n    if (!this.currentLogLevelIsEqualOrSmallerThan(configId, LogLevel.Debug)) {\n      return;\n    }\n\n    if (!!args && !!args.length) {\n      console.log(`[DEBUG] ${configId} - ${message}`, ...args);\n    } else {\n      console.log(`[DEBUG] ${configId} - ${message}`);\n    }\n  }\n\n  logWarningWithoutConfig(message, ...args) {\n    if (!!args && !!args.length) {\n      console.warn(`[WARN] - ${message}`, ...args);\n    } else {\n      console.warn(`[WARN] - ${message}`);\n    }\n  }\n\n  logWarningWithConfig(configId, message, ...args) {\n    if (!this.logLevelIsSet(configId)) {\n      return;\n    }\n\n    if (this.loggingIsTurnedOff(configId)) {\n      return;\n    }\n\n    if (!this.currentLogLevelIsEqualOrSmallerThan(configId, LogLevel.Warn)) {\n      return;\n    }\n\n    if (!!args && !!args.length) {\n      console.warn(`[WARN] ${configId} - ${message}`, ...args);\n    } else {\n      console.warn(`[WARN] ${configId} - ${message}`);\n    }\n  }\n\n  logErrorWithConfig(configId, message, ...args) {\n    if (this.loggingIsTurnedOff(configId)) {\n      return;\n    }\n\n    if (!!args && !!args.length) {\n      console.error(`[ERROR] ${configId} - ${message}`, ...args);\n    } else {\n      console.error(`[ERROR] ${configId} - ${message}`);\n    }\n  }\n\n  logErrorWithoutConfig(message, ...args) {\n    if (!!args && !!args.length) {\n      console.error(`[ERROR] - ${message}`, ...args);\n    } else {\n      console.error(`[ERROR] - ${message}`);\n    }\n  }\n\n  currentLogLevelIsEqualOrSmallerThan(configId, logLevelToCompare) {\n    const {\n      logLevel\n    } = this.configurationProvider.getOpenIDConfiguration(configId) || {};\n    return logLevel <= logLevelToCompare;\n  }\n\n  logLevelIsSet(configId) {\n    const {\n      logLevel\n    } = this.configurationProvider.getOpenIDConfiguration(configId) || {};\n\n    if (logLevel === null) {\n      return false;\n    }\n\n    if (logLevel === undefined) {\n      return false;\n    }\n\n    return true;\n  }\n\n  loggingIsTurnedOff(configId) {\n    const {\n      logLevel\n    } = this.configurationProvider.getOpenIDConfiguration(configId) || {};\n    return logLevel === LogLevel.None;\n  }\n\n}\n\nLoggerService.ɵfac = function LoggerService_Factory(t) {\n  return new (t || LoggerService)(i0.ɵɵinject(ConfigurationProvider));\n};\n\nLoggerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: LoggerService,\n  factory: LoggerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LoggerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ConfigurationProvider\n    }];\n  }, null);\n})();\n\nclass BrowserStorageService {\n  constructor(configProvider, loggerService) {\n    this.configProvider = configProvider;\n    this.loggerService = loggerService;\n  }\n\n  read(key, configId) {\n    if (!this.hasStorage()) {\n      this.loggerService.logDebug(configId, `Wanted to read '${key}' but Storage was undefined`);\n      return null;\n    }\n\n    const storage = this.getStorage(configId);\n\n    if (!storage) {\n      this.loggerService.logDebug(configId, `Wanted to read config for '${configId}' but Storage was falsy`);\n      return null;\n    }\n\n    const storedConfig = storage.read(configId);\n\n    if (!storedConfig) {\n      return null;\n    }\n\n    return JSON.parse(storedConfig);\n  }\n\n  write(value, configId) {\n    if (!this.hasStorage()) {\n      this.loggerService.logDebug(configId, `Wanted to write '${value}' but Storage was falsy`);\n      return false;\n    }\n\n    const storage = this.getStorage(configId);\n\n    if (!storage) {\n      this.loggerService.logDebug(configId, `Wanted to write '${value}' but Storage was falsy`);\n      return false;\n    }\n\n    value = value || null;\n    storage.write(configId, JSON.stringify(value));\n    return true;\n  }\n\n  remove(key, configId) {\n    if (!this.hasStorage()) {\n      this.loggerService.logDebug(configId, `Wanted to remove '${key}' but Storage was falsy`);\n      return false;\n    }\n\n    const storage = this.getStorage(configId);\n\n    if (!storage) {\n      this.loggerService.logDebug(configId, `Wanted to write '${key}' but Storage was falsy`);\n      return false;\n    }\n\n    storage.remove(key);\n    return true;\n  } // TODO THIS STORAGE WANTS AN ID BUT CLEARS EVERYTHING\n\n\n  clear(configId) {\n    if (!this.hasStorage()) {\n      this.loggerService.logDebug(configId, `Wanted to clear storage but Storage was falsy`);\n      return false;\n    }\n\n    const storage = this.getStorage(configId);\n\n    if (!storage) {\n      this.loggerService.logDebug(configId, `Wanted to clear storage but Storage was falsy`);\n      return false;\n    }\n\n    storage.clear();\n    return true;\n  }\n\n  getStorage(configId) {\n    const {\n      storage\n    } = this.configProvider.getOpenIDConfiguration(configId) || {};\n    return storage;\n  }\n\n  hasStorage() {\n    return typeof Storage !== 'undefined';\n  }\n\n}\n\nBrowserStorageService.ɵfac = function BrowserStorageService_Factory(t) {\n  return new (t || BrowserStorageService)(i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(LoggerService));\n};\n\nBrowserStorageService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: BrowserStorageService,\n  factory: BrowserStorageService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(BrowserStorageService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ConfigurationProvider\n    }, {\n      type: LoggerService\n    }];\n  }, null);\n})();\n\nclass StoragePersistenceService {\n  constructor(browserStorageService) {\n    this.browserStorageService = browserStorageService;\n  }\n\n  read(key, configId) {\n    const storedConfig = this.browserStorageService.read(key, configId) || {};\n    return storedConfig[key];\n  }\n\n  write(key, value, configId) {\n    const storedConfig = this.browserStorageService.read(key, configId) || {};\n    storedConfig[key] = value;\n    this.browserStorageService.write(storedConfig, configId);\n  }\n\n  remove(key, configId) {\n    const storedConfig = this.browserStorageService.read(key, configId) || {};\n    delete storedConfig[key];\n    this.browserStorageService.write(storedConfig, configId);\n  }\n\n  clear(configId) {\n    this.browserStorageService.clear(configId);\n  }\n\n  resetStorageFlowData(configId) {\n    this.remove('session_state', configId);\n    this.remove('storageSilentRenewRunning', configId);\n    this.remove('codeVerifier', configId);\n    this.remove('userData', configId);\n    this.remove('storageCustomParamsAuthRequest', configId);\n    this.remove('access_token_expires_at', configId);\n    this.remove('storageCustomParamsRefresh', configId);\n    this.remove('storageCustomParamsEndSession', configId);\n  }\n\n  resetAuthStateInStorage(configId) {\n    this.remove('authzData', configId);\n    this.remove('authnResult', configId);\n  }\n\n  getAccessToken(configId) {\n    return this.read('authzData', configId);\n  }\n\n  getIdToken(configId) {\n    var _a;\n\n    return (_a = this.read('authnResult', configId)) === null || _a === void 0 ? void 0 : _a.id_token;\n  }\n\n  getRefreshToken(configId) {\n    var _a;\n\n    return (_a = this.read('authnResult', configId)) === null || _a === void 0 ? void 0 : _a.refresh_token;\n  }\n\n  getAuthenticationResult(configId) {\n    return this.read('authnResult', configId);\n  }\n\n}\n\nStoragePersistenceService.ɵfac = function StoragePersistenceService_Factory(t) {\n  return new (t || StoragePersistenceService)(i0.ɵɵinject(BrowserStorageService));\n};\n\nStoragePersistenceService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StoragePersistenceService,\n  factory: StoragePersistenceService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StoragePersistenceService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: BrowserStorageService\n    }];\n  }, null);\n})();\n\nclass PublicEventsService {\n  constructor() {\n    this.notify = new ReplaySubject(1);\n  }\n  /**\r\n   * Fires a new event.\r\n   *\r\n   * @param type The event type.\r\n   * @param value The event value.\r\n   */\n\n\n  fireEvent(type, value) {\n    this.notify.next({\n      type,\n      value\n    });\n  }\n  /**\r\n   * Wires up the event notification observable.\r\n   */\n\n\n  registerForEvents() {\n    return this.notify.asObservable();\n  }\n\n}\n\nPublicEventsService.ɵfac = function PublicEventsService_Factory(t) {\n  return new (t || PublicEventsService)();\n};\n\nPublicEventsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PublicEventsService,\n  factory: PublicEventsService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PublicEventsService, [{\n    type: Injectable\n  }], null, null);\n})();\n\nconst PARTS_OF_TOKEN = 3;\n\nclass TokenHelperService {\n  constructor(loggerService) {\n    this.loggerService = loggerService;\n  }\n\n  getTokenExpirationDate(dataIdToken) {\n    if (!dataIdToken.hasOwnProperty('exp')) {\n      return new Date(new Date().toUTCString());\n    }\n\n    const date = new Date(0); // The 0 here is the key, which sets the date to the epoch\n\n    date.setUTCSeconds(dataIdToken.exp);\n    return date;\n  }\n\n  getHeaderFromToken(token, encoded, configId) {\n    if (!this.tokenIsValid(token, configId)) {\n      return {};\n    }\n\n    return this.getPartOfToken(token, 0, encoded);\n  }\n\n  getPayloadFromToken(token, encoded, configId) {\n    if (!this.tokenIsValid(token, configId)) {\n      return {};\n    }\n\n    return this.getPartOfToken(token, 1, encoded);\n  }\n\n  getSignatureFromToken(token, encoded, configId) {\n    if (!this.tokenIsValid(token, configId)) {\n      return {};\n    }\n\n    return this.getPartOfToken(token, 2, encoded);\n  }\n\n  getPartOfToken(token, index, encoded) {\n    const partOfToken = this.extractPartOfToken(token, index);\n\n    if (encoded) {\n      return partOfToken;\n    }\n\n    const result = this.urlBase64Decode(partOfToken);\n    return JSON.parse(result);\n  }\n\n  urlBase64Decode(str) {\n    let output = str.replace(/-/g, '+').replace(/_/g, '/');\n\n    switch (output.length % 4) {\n      case 0:\n        break;\n\n      case 2:\n        output += '==';\n        break;\n\n      case 3:\n        output += '=';\n        break;\n\n      default:\n        throw Error('Illegal base64url string!');\n    }\n\n    const decoded = typeof window !== 'undefined' ? window.atob(output) : Buffer.from(output, 'base64').toString('binary');\n\n    try {\n      // Going backwards: from byte stream, to percent-encoding, to original string.\n      return decodeURIComponent(decoded.split('').map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join(''));\n    } catch (err) {\n      return decoded;\n    }\n  }\n\n  tokenIsValid(token, configId) {\n    if (!token) {\n      this.loggerService.logError(configId, `token '${token}' is not valid --> token falsy`);\n      return false;\n    }\n\n    if (!token.includes('.')) {\n      this.loggerService.logError(configId, `token '${token}' is not valid --> no dots included`);\n      return false;\n    }\n\n    const parts = token.split('.');\n\n    if (parts.length !== PARTS_OF_TOKEN) {\n      this.loggerService.logError(configId, `token '${token}' is not valid --> token has to have exactly ${PARTS_OF_TOKEN - 1} dots`);\n      return false;\n    }\n\n    return true;\n  }\n\n  extractPartOfToken(token, index) {\n    return token.split('.')[index];\n  }\n\n}\n\nTokenHelperService.ɵfac = function TokenHelperService_Factory(t) {\n  return new (t || TokenHelperService)(i0.ɵɵinject(LoggerService));\n};\n\nTokenHelperService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: TokenHelperService,\n  factory: TokenHelperService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TokenHelperService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }];\n  }, null);\n})();\n\nclass JsrsAsignReducedService {\n  generateCodeChallenge(codeVerifier) {\n    const hash = KJUR.crypto.Util.hashString(codeVerifier, 'sha256');\n    const testData = hextob64u(hash);\n    return testData;\n  }\n\n  generateAtHash(accessToken, sha) {\n    const hash = KJUR.crypto.Util.hashString(accessToken, sha);\n    const first128bits = hash.substr(0, hash.length / 2);\n    const testData = hextob64u(first128bits);\n    return testData;\n  }\n\n}\n\nJsrsAsignReducedService.ɵfac = function JsrsAsignReducedService_Factory(t) {\n  return new (t || JsrsAsignReducedService)();\n};\n\nJsrsAsignReducedService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: JsrsAsignReducedService,\n  factory: JsrsAsignReducedService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(JsrsAsignReducedService, [{\n    type: Injectable\n  }], null, null);\n})(); // http://openid.net/specs/openid-connect-implicit-1_0.html\n// id_token\n// id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)\n// MUST exactly match the value of the iss (issuer) Claim.\n//\n// id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified\n// by the iss (issuer) Claim as an audience.The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience,\n// or if it contains additional audiences not trusted by the Client.\n//\n// id_token C3: If the ID Token contains multiple audiences, the Client SHOULD verify that an azp Claim is present.\n//\n// id_token C4: If an azp (authorized party) Claim is present, the Client SHOULD verify that its client_id is the Claim Value.\n//\n// id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the\n// alg Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.\n//\n// id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the OpenID Connect\n// Core 1.0\n// [OpenID.Core] specification.\n//\n// id_token C7: The current time MUST be before the time represented by the exp Claim (possibly allowing for some small leeway to account\n// for clock skew).\n//\n// id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,\n// limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.\n//\n// id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one that was sent\n// in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.The precise method for detecting replay attacks\n// is Client specific.\n//\n// id_token C10: If the acr Claim was requested, the Client SHOULD check that the asserted Claim Value is appropriate.\n// The meaning and processing of acr Claim Values is out of scope for this document.\n//\n// id_token C11: When a max_age request is made, the Client SHOULD check the auth_time Claim value and request re- authentication\n// if it determines too much time has elapsed since the last End- User authentication.\n// Access Token Validation\n// access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]\n// for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.\n// access_token C2: Take the left- most half of the hash and base64url- encode it.\n// access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash is present\n// in the ID Token.\n\n\nclass TokenValidationService {\n  constructor(tokenHelperService, loggerService, jsrsAsignReducedService) {\n    this.tokenHelperService = tokenHelperService;\n    this.loggerService = loggerService;\n    this.jsrsAsignReducedService = jsrsAsignReducedService;\n    this.keyAlgorithms = ['HS256', 'HS384', 'HS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'PS256', 'PS384', 'PS512'];\n  } // id_token C7: The current time MUST be before the time represented by the exp Claim\n  // (possibly allowing for some small leeway to account for clock skew).\n\n\n  hasIdTokenExpired(token, configId, offsetSeconds) {\n    const decoded = this.tokenHelperService.getPayloadFromToken(token, false, configId);\n    return !this.validateIdTokenExpNotExpired(decoded, configId, offsetSeconds);\n  } // id_token C7: The current time MUST be before the time represented by the exp Claim\n  // (possibly allowing for some small leeway to account for clock skew).\n\n\n  validateIdTokenExpNotExpired(decodedIdToken, configId, offsetSeconds) {\n    const tokenExpirationDate = this.tokenHelperService.getTokenExpirationDate(decodedIdToken);\n    offsetSeconds = offsetSeconds || 0;\n\n    if (!tokenExpirationDate) {\n      return false;\n    }\n\n    const tokenExpirationValue = tokenExpirationDate.valueOf();\n    const nowWithOffset = new Date(new Date().toUTCString()).valueOf() + offsetSeconds * 1000;\n    const tokenNotExpired = tokenExpirationValue > nowWithOffset;\n    this.loggerService.logDebug(configId, `Has idToken expired: ${!tokenNotExpired} --> expires in ${this.millisToMinutesAndSeconds(tokenExpirationValue - nowWithOffset)} , ${new Date(tokenExpirationValue).toLocaleTimeString()} > ${new Date(nowWithOffset).toLocaleTimeString()}`); // Token not expired?\n\n    return tokenNotExpired;\n  }\n\n  validateAccessTokenNotExpired(accessTokenExpiresAt, configId, offsetSeconds) {\n    // value is optional, so if it does not exist, then it has not expired\n    if (!accessTokenExpiresAt) {\n      return true;\n    }\n\n    offsetSeconds = offsetSeconds || 0;\n    const accessTokenExpirationValue = accessTokenExpiresAt.valueOf();\n    const nowWithOffset = new Date(new Date().toUTCString()).valueOf() + offsetSeconds * 1000;\n    const tokenNotExpired = accessTokenExpirationValue > nowWithOffset;\n    this.loggerService.logDebug(configId, `Has accessToken expired: ${!tokenNotExpired} --> expires in ${this.millisToMinutesAndSeconds(accessTokenExpirationValue - nowWithOffset)} , ${new Date(accessTokenExpirationValue).toLocaleTimeString()} > ${new Date(nowWithOffset).toLocaleTimeString()}`); // access token not expired?\n\n    return tokenNotExpired;\n  } // iss\n  // REQUIRED. Issuer Identifier for the Issuer of the response.The iss value is a case-sensitive URL using the\n  // https scheme that contains scheme, host,\n  // and optionally, port number and path components and no query or fragment components.\n  //\n  // sub\n  // REQUIRED. Subject Identifier.Locally unique and never reassigned identifier within the Issuer for the End- User,\n  // which is intended to be consumed by the Client, e.g., 24400320 or AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4.\n  // It MUST NOT exceed 255 ASCII characters in length.The sub value is a case-sensitive string.\n  //\n  // aud\n  // REQUIRED. Audience(s) that this ID Token is intended for. It MUST contain the OAuth 2.0 client_id of the Relying Party as an\n  // audience value.\n  // It MAY also contain identifiers for other audiences.In the general case, the aud value is an array of case-sensitive strings.\n  // In the common special case when there is one audience, the aud value MAY be a single case-sensitive string.\n  //\n  // exp\n  // REQUIRED. Expiration time on or after which the ID Token MUST NOT be accepted for processing.\n  // The processing of this parameter requires that the current date/ time MUST be before the expiration date/ time listed in the value.\n  // Implementers MAY provide for some small leeway, usually no more than a few minutes, to account for clock skew.\n  // Its value is a JSON [RFC7159] number representing the number of seconds from 1970- 01 - 01T00: 00:00Z as measured in UTC until\n  // the date/ time.\n  // See RFC 3339 [RFC3339] for details regarding date/ times in general and UTC in particular.\n  //\n  // iat\n  // REQUIRED. Time at which the JWT was issued. Its value is a JSON number representing the number of seconds from\n  // 1970- 01 - 01T00: 00: 00Z as measured\n  // in UTC until the date/ time.\n\n\n  validateRequiredIdToken(dataIdToken, configId) {\n    let validated = true;\n\n    if (!dataIdToken.hasOwnProperty('iss')) {\n      validated = false;\n      this.loggerService.logWarning(configId, 'iss is missing, this is required in the id_token');\n    }\n\n    if (!dataIdToken.hasOwnProperty('sub')) {\n      validated = false;\n      this.loggerService.logWarning(configId, 'sub is missing, this is required in the id_token');\n    }\n\n    if (!dataIdToken.hasOwnProperty('aud')) {\n      validated = false;\n      this.loggerService.logWarning(configId, 'aud is missing, this is required in the id_token');\n    }\n\n    if (!dataIdToken.hasOwnProperty('exp')) {\n      validated = false;\n      this.loggerService.logWarning(configId, 'exp is missing, this is required in the id_token');\n    }\n\n    if (!dataIdToken.hasOwnProperty('iat')) {\n      validated = false;\n      this.loggerService.logWarning(configId, 'iat is missing, this is required in the id_token');\n    }\n\n    return validated;\n  } // id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,\n  // limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.\n\n\n  validateIdTokenIatMaxOffset(dataIdToken, maxOffsetAllowedInSeconds, disableIatOffsetValidation, configId) {\n    if (disableIatOffsetValidation) {\n      return true;\n    }\n\n    if (!dataIdToken.hasOwnProperty('iat')) {\n      return false;\n    }\n\n    const dateTimeIatIdToken = new Date(0); // The 0 here is the key, which sets the date to the epoch\n\n    dateTimeIatIdToken.setUTCSeconds(dataIdToken.iat);\n    maxOffsetAllowedInSeconds = maxOffsetAllowedInSeconds || 0;\n    const nowInUtc = new Date(new Date().toUTCString());\n    const diff = nowInUtc.valueOf() - dateTimeIatIdToken.valueOf();\n    const maxOffsetAllowedInMilliseconds = maxOffsetAllowedInSeconds * 1000;\n    this.loggerService.logDebug(configId, `validate id token iat max offset ${diff} < ${maxOffsetAllowedInMilliseconds}`);\n\n    if (diff > 0) {\n      return diff < maxOffsetAllowedInMilliseconds;\n    }\n\n    return -diff < maxOffsetAllowedInMilliseconds;\n  } // id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one\n  // that was sent in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.\n  // The precise method for detecting replay attacks is Client specific.\n  // However the nonce claim SHOULD not be present for the refresh_token grant type\n  // https://bitbucket.org/openid/connect/issues/1025/ambiguity-with-how-nonce-is-handled-on\n  // The current spec is ambiguous and KeyCloak does send it.\n\n\n  validateIdTokenNonce(dataIdToken, localNonce, ignoreNonceAfterRefresh, configId) {\n    const isFromRefreshToken = (dataIdToken.nonce === undefined || ignoreNonceAfterRefresh) && localNonce === TokenValidationService.refreshTokenNoncePlaceholder;\n\n    if (!isFromRefreshToken && dataIdToken.nonce !== localNonce) {\n      this.loggerService.logDebug(configId, 'Validate_id_token_nonce failed, dataIdToken.nonce: ' + dataIdToken.nonce + ' local_nonce:' + localNonce);\n      return false;\n    }\n\n    return true;\n  } // id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)\n  // MUST exactly match the value of the iss (issuer) Claim.\n\n\n  validateIdTokenIss(dataIdToken, authWellKnownEndpointsIssuer, configId) {\n    if (dataIdToken.iss !== authWellKnownEndpointsIssuer) {\n      this.loggerService.logDebug(configId, 'Validate_id_token_iss failed, dataIdToken.iss: ' + dataIdToken.iss + ' authWellKnownEndpoints issuer:' + authWellKnownEndpointsIssuer);\n      return false;\n    }\n\n    return true;\n  } // id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified\n  // by the iss (issuer) Claim as an audience.\n  // The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience, or if it contains additional audiences\n  // not trusted by the Client.\n\n\n  validateIdTokenAud(dataIdToken, aud, configId) {\n    if (Array.isArray(dataIdToken.aud)) {\n      const result = dataIdToken.aud.includes(aud);\n\n      if (!result) {\n        this.loggerService.logDebug(configId, 'Validate_id_token_aud array failed, dataIdToken.aud: ' + dataIdToken.aud + ' client_id:' + aud);\n        return false;\n      }\n\n      return true;\n    } else if (dataIdToken.aud !== aud) {\n      this.loggerService.logDebug(configId, 'Validate_id_token_aud failed, dataIdToken.aud: ' + dataIdToken.aud + ' client_id:' + aud);\n      return false;\n    }\n\n    return true;\n  }\n\n  validateIdTokenAzpExistsIfMoreThanOneAud(dataIdToken) {\n    if (!dataIdToken) {\n      return false;\n    }\n\n    if (Array.isArray(dataIdToken.aud) && dataIdToken.aud.length > 1 && !dataIdToken.azp) {\n      return false;\n    }\n\n    return true;\n  } // If an azp (authorized party) Claim is present, the Client SHOULD verify that its client_id is the Claim Value.\n\n\n  validateIdTokenAzpValid(dataIdToken, clientId) {\n    if (!(dataIdToken === null || dataIdToken === void 0 ? void 0 : dataIdToken.azp)) {\n      return true;\n    }\n\n    if (dataIdToken.azp === clientId) {\n      return true;\n    }\n\n    return false;\n  }\n\n  validateStateFromHashCallback(state, localState, configId) {\n    if (state !== localState) {\n      this.loggerService.logDebug(configId, 'ValidateStateFromHashCallback failed, state: ' + state + ' local_state:' + localState);\n      return false;\n    }\n\n    return true;\n  } // id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the alg\n  // Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.\n  // id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the\n  // OpenID Connect Core 1.0 [OpenID.Core] specification.\n\n\n  validateSignatureIdToken(idToken, jwtkeys, configId) {\n    if (!jwtkeys || !jwtkeys.keys) {\n      return false;\n    }\n\n    const headerData = this.tokenHelperService.getHeaderFromToken(idToken, false, configId);\n\n    if (Object.keys(headerData).length === 0 && headerData.constructor === Object) {\n      this.loggerService.logWarning(configId, 'id token has no header data');\n      return false;\n    }\n\n    const kid = headerData.kid;\n    const alg = headerData.alg;\n\n    if (!this.keyAlgorithms.includes(alg)) {\n      this.loggerService.logWarning(configId, 'alg not supported', alg);\n      return false;\n    }\n\n    let jwtKtyToUse = 'RSA';\n\n    if (alg.charAt(0) === 'E') {\n      jwtKtyToUse = 'EC';\n    }\n\n    let isValid = false; // No kid in the Jose header\n\n    if (!kid) {\n      let keyToValidate; // If only one key, use it\n\n      if (jwtkeys.keys.length === 1 && jwtkeys.keys[0].kty === jwtKtyToUse) {\n        keyToValidate = jwtkeys.keys[0];\n      } else {\n        // More than one key\n        // Make sure there's exactly 1 key candidate\n        // kty \"RSA\" and \"EC\" uses \"sig\"\n        let amountOfMatchingKeys = 0;\n\n        for (const key of jwtkeys.keys) {\n          if (key.kty === jwtKtyToUse && key.use === 'sig') {\n            amountOfMatchingKeys++;\n            keyToValidate = key;\n          }\n        }\n\n        if (amountOfMatchingKeys > 1) {\n          this.loggerService.logWarning(configId, 'no ID Token kid claim in JOSE header and multiple supplied in jwks_uri');\n          return false;\n        }\n      }\n\n      if (!keyToValidate) {\n        this.loggerService.logWarning(configId, 'no keys found, incorrect Signature, validation failed for id_token');\n        return false;\n      }\n\n      isValid = KJUR.jws.JWS.verify(idToken, KEYUTIL.getKey(keyToValidate), [alg]);\n\n      if (!isValid) {\n        this.loggerService.logWarning(configId, 'incorrect Signature, validation failed for id_token');\n      }\n\n      return isValid;\n    } else {\n      // kid in the Jose header of id_token\n      for (const key of jwtkeys.keys) {\n        if (key.kid === kid) {\n          const publicKey = KEYUTIL.getKey(key);\n          isValid = KJUR.jws.JWS.verify(idToken, publicKey, [alg]);\n\n          if (!isValid) {\n            this.loggerService.logWarning(configId, 'incorrect Signature, validation failed for id_token');\n          }\n\n          return isValid;\n        }\n      }\n    }\n\n    return isValid;\n  } // Accepts ID Token without 'kid' claim in JOSE header if only one JWK supplied in 'jwks_url'\n  //// private validate_no_kid_in_header_only_one_allowed_in_jwtkeys(header_data: any, jwtkeys: any): boolean {\n  ////    this.oidcSecurityCommon.logDebug('amount of jwtkeys.keys: ' + jwtkeys.keys.length);\n  ////    if (!header_data.hasOwnProperty('kid')) {\n  ////        // no kid defined in Jose header\n  ////        if (jwtkeys.keys.length != 1) {\n  ////            this.oidcSecurityCommon.logDebug('jwtkeys.keys.length != 1 and no kid in header');\n  ////            return false;\n  ////        }\n  ////    }\n  ////    return true;\n  //// }\n  // Access Token Validation\n  // access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]\n  // for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.\n  // access_token C2: Take the left- most half of the hash and base64url- encode it.\n  // access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash\n  // is present in the ID Token.\n\n\n  validateIdTokenAtHash(accessToken, atHash, idTokenAlg, configId) {\n    this.loggerService.logDebug(configId, 'at_hash from the server:' + atHash); // 'sha256' 'sha384' 'sha512'\n\n    let sha = 'sha256';\n\n    if (idTokenAlg.includes('384')) {\n      sha = 'sha384';\n    } else if (idTokenAlg.includes('512')) {\n      sha = 'sha512';\n    }\n\n    const testData = this.jsrsAsignReducedService.generateAtHash('' + accessToken, sha);\n    this.loggerService.logDebug(configId, 'at_hash client validation not decoded:' + testData);\n\n    if (testData === atHash) {\n      return true; // isValid;\n    } else {\n      const testValue = this.jsrsAsignReducedService.generateAtHash('' + decodeURIComponent(accessToken), sha);\n      this.loggerService.logDebug(configId, '-gen access--' + testValue);\n\n      if (testValue === atHash) {\n        return true; // isValid\n      }\n    }\n\n    return false;\n  }\n\n  millisToMinutesAndSeconds(millis) {\n    const minutes = Math.floor(millis / 60000);\n    const seconds = (millis % 60000 / 1000).toFixed(0);\n    return minutes + ':' + (+seconds < 10 ? '0' : '') + seconds;\n  }\n\n}\n\nTokenValidationService.refreshTokenNoncePlaceholder = '--RefreshToken--';\n\nTokenValidationService.ɵfac = function TokenValidationService_Factory(t) {\n  return new (t || TokenValidationService)(i0.ɵɵinject(TokenHelperService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(JsrsAsignReducedService));\n};\n\nTokenValidationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: TokenValidationService,\n  factory: TokenValidationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TokenValidationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: TokenHelperService\n    }, {\n      type: LoggerService\n    }, {\n      type: JsrsAsignReducedService\n    }];\n  }, null);\n})();\n\nconst DEFAULT_AUTHRESULT = {\n  isAuthenticated: false,\n  allConfigsAuthenticated: []\n};\n\nclass AuthStateService {\n  constructor(storagePersistenceService, loggerService, publicEventsService, configurationProvider, tokenValidationService) {\n    this.storagePersistenceService = storagePersistenceService;\n    this.loggerService = loggerService;\n    this.publicEventsService = publicEventsService;\n    this.configurationProvider = configurationProvider;\n    this.tokenValidationService = tokenValidationService;\n    this.authenticatedInternal$ = new BehaviorSubject(DEFAULT_AUTHRESULT);\n  }\n\n  get authenticated$() {\n    return this.authenticatedInternal$.asObservable().pipe(distinctUntilChanged());\n  }\n\n  setAuthenticatedAndFireEvent() {\n    const result = this.composeAuthenticatedResult();\n    this.authenticatedInternal$.next(result);\n  }\n\n  setUnauthenticatedAndFireEvent(configIdToReset) {\n    this.storagePersistenceService.resetAuthStateInStorage(configIdToReset);\n    const result = this.composeUnAuthenticatedResult();\n    this.authenticatedInternal$.next(result);\n  }\n\n  updateAndPublishAuthState(authenticationResult) {\n    this.publicEventsService.fireEvent(EventTypes.NewAuthenticationResult, authenticationResult);\n  }\n\n  setAuthorizationData(accessToken, authResult, configId) {\n    this.loggerService.logDebug(configId, `storing the accessToken '${accessToken}'`);\n    this.storagePersistenceService.write('authzData', accessToken, configId);\n    this.persistAccessTokenExpirationTime(authResult, configId);\n    this.setAuthenticatedAndFireEvent();\n  }\n\n  getAccessToken(configId) {\n    if (!this.isAuthenticated(configId)) {\n      return null;\n    }\n\n    const token = this.storagePersistenceService.getAccessToken(configId);\n    return this.decodeURIComponentSafely(token);\n  }\n\n  getIdToken(configId) {\n    if (!this.isAuthenticated(configId)) {\n      return null;\n    }\n\n    const token = this.storagePersistenceService.getIdToken(configId);\n    return this.decodeURIComponentSafely(token);\n  }\n\n  getRefreshToken(configId) {\n    if (!this.isAuthenticated(configId)) {\n      return null;\n    }\n\n    const token = this.storagePersistenceService.getRefreshToken(configId);\n    return this.decodeURIComponentSafely(token);\n  }\n\n  getAuthenticationResult(configId) {\n    if (!this.isAuthenticated(configId)) {\n      return null;\n    }\n\n    return this.storagePersistenceService.getAuthenticationResult(configId);\n  }\n\n  areAuthStorageTokensValid(configId) {\n    if (!this.isAuthenticated(configId)) {\n      return false;\n    }\n\n    if (this.hasIdTokenExpiredAndRenewCheckIsEnabled(configId)) {\n      this.loggerService.logDebug(configId, 'persisted idToken is expired');\n      return false;\n    }\n\n    if (this.hasAccessTokenExpiredIfExpiryExists(configId)) {\n      this.loggerService.logDebug(configId, 'persisted accessToken is expired');\n      return false;\n    }\n\n    this.loggerService.logDebug(configId, 'persisted idToken and accessToken are valid');\n    return true;\n  }\n\n  hasIdTokenExpiredAndRenewCheckIsEnabled(configId) {\n    const {\n      renewTimeBeforeTokenExpiresInSeconds,\n      enableIdTokenExpiredValidationInRenew\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!enableIdTokenExpiredValidationInRenew) {\n      return false;\n    }\n\n    const tokenToCheck = this.storagePersistenceService.getIdToken(configId);\n    const idTokenExpired = this.tokenValidationService.hasIdTokenExpired(tokenToCheck, configId, renewTimeBeforeTokenExpiresInSeconds);\n\n    if (idTokenExpired) {\n      this.publicEventsService.fireEvent(EventTypes.IdTokenExpired, idTokenExpired);\n    }\n\n    return idTokenExpired;\n  }\n\n  hasAccessTokenExpiredIfExpiryExists(configId) {\n    const {\n      renewTimeBeforeTokenExpiresInSeconds\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    const accessTokenExpiresIn = this.storagePersistenceService.read('access_token_expires_at', configId);\n    const accessTokenHasNotExpired = this.tokenValidationService.validateAccessTokenNotExpired(accessTokenExpiresIn, configId, renewTimeBeforeTokenExpiresInSeconds);\n    const hasExpired = !accessTokenHasNotExpired;\n\n    if (hasExpired) {\n      this.publicEventsService.fireEvent(EventTypes.TokenExpired, hasExpired);\n    }\n\n    return hasExpired;\n  }\n\n  isAuthenticated(configId) {\n    return !!this.storagePersistenceService.getAccessToken(configId) && !!this.storagePersistenceService.getIdToken(configId);\n  }\n\n  decodeURIComponentSafely(token) {\n    if (token) {\n      return decodeURIComponent(token);\n    } else {\n      return '';\n    }\n  }\n\n  persistAccessTokenExpirationTime(authResult, configId) {\n    if (authResult === null || authResult === void 0 ? void 0 : authResult.expires_in) {\n      const accessTokenExpiryTime = new Date(new Date().toUTCString()).valueOf() + authResult.expires_in * 1000;\n      this.storagePersistenceService.write('access_token_expires_at', accessTokenExpiryTime, configId);\n    }\n  }\n\n  composeAuthenticatedResult() {\n    if (!this.configurationProvider.hasManyConfigs()) {\n      const {\n        configId\n      } = this.configurationProvider.getOpenIDConfiguration();\n      return {\n        isAuthenticated: true,\n        allConfigsAuthenticated: [{\n          configId,\n          isAuthenticated: true\n        }]\n      };\n    }\n\n    return this.checkAllConfigsIfTheyAreAuthenticated();\n  }\n\n  composeUnAuthenticatedResult() {\n    if (!this.configurationProvider.hasManyConfigs()) {\n      const {\n        configId\n      } = this.configurationProvider.getOpenIDConfiguration();\n      return {\n        isAuthenticated: false,\n        allConfigsAuthenticated: [{\n          configId,\n          isAuthenticated: false\n        }]\n      };\n    }\n\n    return this.checkAllConfigsIfTheyAreAuthenticated();\n  }\n\n  checkAllConfigsIfTheyAreAuthenticated() {\n    const configs = this.configurationProvider.getAllConfigurations();\n    const allConfigsAuthenticated = configs.map(({\n      configId\n    }) => ({\n      configId,\n      isAuthenticated: this.isAuthenticated(configId)\n    }));\n    const isAuthenticated = allConfigsAuthenticated.every(x => !!x.isAuthenticated);\n    return {\n      allConfigsAuthenticated,\n      isAuthenticated\n    };\n  }\n\n}\n\nAuthStateService.ɵfac = function AuthStateService_Factory(t) {\n  return new (t || AuthStateService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(TokenValidationService));\n};\n\nAuthStateService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AuthStateService,\n  factory: AuthStateService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthStateService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: LoggerService\n    }, {\n      type: PublicEventsService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: TokenValidationService\n    }];\n  }, null);\n})();\n\nconst STORAGE_KEY = 'redirect';\n\nclass AutoLoginService {\n  constructor(storageService, router) {\n    this.storageService = storageService;\n    this.router = router;\n  }\n\n  checkSavedRedirectRouteAndNavigate(configId) {\n    const savedRouteForRedirect = this.getStoredRedirectRoute(configId);\n\n    if (savedRouteForRedirect) {\n      this.deleteStoredRedirectRoute(configId);\n      this.router.navigateByUrl(savedRouteForRedirect);\n    }\n  }\n  /**\r\n   * Saves the redirect URL to storage.\r\n   *\r\n   * @param url The redirect URL to save.\r\n   */\n\n\n  saveRedirectRoute(configId, url) {\n    this.storageService.write(STORAGE_KEY, url, configId);\n  }\n  /**\r\n   * Gets the stored redirect URL from storage.\r\n   */\n\n\n  getStoredRedirectRoute(configId) {\n    return this.storageService.read(STORAGE_KEY, configId);\n  }\n  /**\r\n   * Removes the redirect URL from storage.\r\n   */\n\n\n  deleteStoredRedirectRoute(configId) {\n    this.storageService.remove(STORAGE_KEY, configId);\n  }\n\n}\n\nAutoLoginService.ɵfac = function AutoLoginService_Factory(t) {\n  return new (t || AutoLoginService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(i2.Router));\n};\n\nAutoLoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AutoLoginService,\n  factory: AutoLoginService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AutoLoginService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: i2.Router\n    }];\n  }, null);\n})();\n\nclass UriEncoder {\n  encodeKey(key) {\n    return encodeURIComponent(key);\n  }\n\n  encodeValue(value) {\n    return encodeURIComponent(value);\n  }\n\n  decodeKey(key) {\n    return decodeURIComponent(key);\n  }\n\n  decodeValue(value) {\n    return decodeURIComponent(value);\n  }\n\n}\n\nclass RandomService {\n  constructor(doc, loggerService) {\n    this.doc = doc;\n    this.loggerService = loggerService;\n  }\n\n  createRandom(requiredLength, configId) {\n    if (requiredLength <= 0) {\n      return '';\n    }\n\n    if (requiredLength > 0 && requiredLength < 7) {\n      this.loggerService.logWarning(configId, `RandomService called with ${requiredLength} but 7 chars is the minimum, returning 10 chars`);\n      requiredLength = 10;\n    }\n\n    const length = requiredLength - 6;\n    const arr = new Uint8Array(Math.floor((length || length) / 2));\n\n    if (this.getCrypto()) {\n      this.getCrypto().getRandomValues(arr);\n    }\n\n    return Array.from(arr, this.toHex).join('') + this.randomString(7);\n  }\n\n  toHex(dec) {\n    return ('0' + dec.toString(16)).substr(-2);\n  }\n\n  randomString(length) {\n    let result = '';\n    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    const values = new Uint32Array(length);\n\n    if (this.getCrypto()) {\n      this.getCrypto().getRandomValues(values);\n\n      for (let i = 0; i < length; i++) {\n        result += characters[values[i] % characters.length];\n      }\n    }\n\n    return result;\n  }\n\n  getCrypto() {\n    // support for IE,  (window.crypto || window.msCrypto)\n    return this.doc.defaultView.crypto || this.doc.defaultView.msCrypto;\n  }\n\n}\n\nRandomService.ɵfac = function RandomService_Factory(t) {\n  return new (t || RandomService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(LoggerService));\n};\n\nRandomService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RandomService,\n  factory: RandomService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RandomService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: LoggerService\n    }];\n  }, null);\n})();\n\nclass FlowsDataService {\n  constructor(storagePersistenceService, randomService, configurationProvider, loggerService) {\n    this.storagePersistenceService = storagePersistenceService;\n    this.randomService = randomService;\n    this.configurationProvider = configurationProvider;\n    this.loggerService = loggerService;\n  }\n\n  createNonce(configId) {\n    const nonce = this.randomService.createRandom(40, configId);\n    this.loggerService.logDebug(configId, 'Nonce created. nonce:' + nonce);\n    this.setNonce(nonce, configId);\n    return nonce;\n  }\n\n  setNonce(nonce, configId) {\n    this.storagePersistenceService.write('authNonce', nonce, configId);\n  }\n\n  getAuthStateControl(configId) {\n    return this.storagePersistenceService.read('authStateControl', configId);\n  }\n\n  setAuthStateControl(authStateControl, configId) {\n    this.storagePersistenceService.write('authStateControl', authStateControl, configId);\n  }\n\n  getExistingOrCreateAuthStateControl(configId) {\n    let state = this.storagePersistenceService.read('authStateControl', configId);\n\n    if (!state) {\n      state = this.randomService.createRandom(40, configId);\n      this.storagePersistenceService.write('authStateControl', state, configId);\n    }\n\n    return state;\n  }\n\n  setSessionState(sessionState, configId) {\n    this.storagePersistenceService.write('session_state', sessionState, configId);\n  }\n\n  resetStorageFlowData(configId) {\n    this.storagePersistenceService.resetStorageFlowData(configId);\n  }\n\n  getCodeVerifier(configId) {\n    return this.storagePersistenceService.read('codeVerifier', configId);\n  }\n\n  createCodeVerifier(configId) {\n    const codeVerifier = this.randomService.createRandom(67, configId);\n    this.storagePersistenceService.write('codeVerifier', codeVerifier, configId);\n    return codeVerifier;\n  }\n\n  isSilentRenewRunning(configId) {\n    const storageObject = this.getSilentRenewRunningStorageEntry(configId);\n\n    if (!storageObject) {\n      return false;\n    }\n\n    const {\n      silentRenewTimeoutInSeconds\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    const timeOutInMilliseconds = silentRenewTimeoutInSeconds * 1000;\n    const dateOfLaunchedProcessUtc = Date.parse(storageObject.dateOfLaunchedProcessUtc);\n    const currentDateUtc = Date.parse(new Date().toISOString());\n    const elapsedTimeInMilliseconds = Math.abs(currentDateUtc - dateOfLaunchedProcessUtc);\n    const isProbablyStuck = elapsedTimeInMilliseconds > timeOutInMilliseconds;\n\n    if (isProbablyStuck) {\n      this.loggerService.logDebug(configId, 'silent renew process is probably stuck, state will be reset.', configId);\n      this.resetSilentRenewRunning(configId);\n      return false;\n    }\n\n    return storageObject.state === 'running';\n  }\n\n  setSilentRenewRunning(configId) {\n    const storageObject = {\n      state: 'running',\n      dateOfLaunchedProcessUtc: new Date().toISOString()\n    };\n    this.storagePersistenceService.write('storageSilentRenewRunning', JSON.stringify(storageObject), configId);\n  }\n\n  resetSilentRenewRunning(configId) {\n    this.storagePersistenceService.write('storageSilentRenewRunning', '', configId);\n  }\n\n  getSilentRenewRunningStorageEntry(configId) {\n    const storageEntry = this.storagePersistenceService.read('storageSilentRenewRunning', configId);\n\n    if (!storageEntry) {\n      return null;\n    }\n\n    return JSON.parse(storageEntry);\n  }\n\n}\n\nFlowsDataService.ɵfac = function FlowsDataService_Factory(t) {\n  return new (t || FlowsDataService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(RandomService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(LoggerService));\n};\n\nFlowsDataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: FlowsDataService,\n  factory: FlowsDataService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(FlowsDataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: RandomService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: LoggerService\n    }];\n  }, null);\n})();\n\nclass FlowHelper {\n  constructor(configurationProvider) {\n    this.configurationProvider = configurationProvider;\n  }\n\n  isCurrentFlowCodeFlow(configId) {\n    return this.currentFlowIs('code', configId);\n  }\n\n  isCurrentFlowAnyImplicitFlow(configId) {\n    return this.isCurrentFlowImplicitFlowWithAccessToken(configId) || this.isCurrentFlowImplicitFlowWithoutAccessToken(configId);\n  }\n\n  isCurrentFlowCodeFlowWithRefreshTokens(configId) {\n    const {\n      useRefreshToken\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (this.isCurrentFlowCodeFlow(configId) && useRefreshToken) {\n      return true;\n    }\n\n    return false;\n  }\n\n  isCurrentFlowImplicitFlowWithAccessToken(configId) {\n    return this.currentFlowIs('id_token token', configId);\n  }\n\n  currentFlowIs(flowTypes, configId) {\n    const {\n      responseType\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (Array.isArray(flowTypes)) {\n      return flowTypes.some(x => responseType === x);\n    }\n\n    return responseType === flowTypes;\n  }\n\n  isCurrentFlowImplicitFlowWithoutAccessToken(configId) {\n    return this.currentFlowIs('id_token', configId);\n  }\n\n}\n\nFlowHelper.ɵfac = function FlowHelper_Factory(t) {\n  return new (t || FlowHelper)(i0.ɵɵinject(ConfigurationProvider));\n};\n\nFlowHelper.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: FlowHelper,\n  factory: FlowHelper.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(FlowHelper, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ConfigurationProvider\n    }];\n  }, null);\n})();\n\nconst CALLBACK_PARAMS_TO_CHECK = ['code', 'state', 'token', 'id_token'];\nconst AUTH0_ENDPOINT = 'auth0.com';\n\nclass UrlService {\n  constructor(configurationProvider, loggerService, flowsDataService, flowHelper, storagePersistenceService, jsrsAsignReducedService) {\n    this.configurationProvider = configurationProvider;\n    this.loggerService = loggerService;\n    this.flowsDataService = flowsDataService;\n    this.flowHelper = flowHelper;\n    this.storagePersistenceService = storagePersistenceService;\n    this.jsrsAsignReducedService = jsrsAsignReducedService;\n  }\n\n  getUrlParameter(urlToCheck, name) {\n    if (!urlToCheck) {\n      return '';\n    }\n\n    if (!name) {\n      return '';\n    }\n\n    name = name.replace(/[\\[]/, '\\\\[').replace(/[\\]]/, '\\\\]');\n    const regex = new RegExp('[\\\\?&]' + name + '=([^&#]*)');\n    const results = regex.exec(urlToCheck);\n    return results === null ? '' : decodeURIComponent(results[1]);\n  }\n\n  isCallbackFromSts(currentUrl) {\n    return CALLBACK_PARAMS_TO_CHECK.some(x => !!this.getUrlParameter(currentUrl, x));\n  }\n\n  getRefreshSessionSilentRenewUrl(configId, customParams) {\n    if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\n      return this.createUrlCodeFlowWithSilentRenew(configId, customParams);\n    }\n\n    return this.createUrlImplicitFlowWithSilentRenew(configId, customParams) || '';\n  }\n\n  getAuthorizeParUrl(requestUri, configId) {\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n    if (!authWellKnownEndPoints) {\n      this.loggerService.logError(configId, 'authWellKnownEndpoints is undefined');\n      return null;\n    }\n\n    const authorizationEndpoint = authWellKnownEndPoints.authorizationEndpoint;\n\n    if (!authorizationEndpoint) {\n      this.loggerService.logError(configId, `Can not create an authorize URL when authorizationEndpoint is '${authorizationEndpoint}'`);\n      return null;\n    }\n\n    const {\n      clientId\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!clientId) {\n      this.loggerService.logError(configId, `getAuthorizeParUrl could not add clientId because it was: `, clientId);\n      return null;\n    }\n\n    const urlParts = authorizationEndpoint.split('?');\n    const authorizationUrl = urlParts[0];\n    const existingParams = urlParts[1];\n    let params = this.createHttpParams(existingParams);\n    params = params.set('request_uri', requestUri);\n    params = params.append('client_id', clientId);\n    return `${authorizationUrl}?${params}`;\n  }\n\n  getAuthorizeUrl(configId, customParams) {\n    if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\n      return this.createUrlCodeFlowAuthorize(configId, customParams);\n    }\n\n    return this.createUrlImplicitFlowAuthorize(configId, customParams) || '';\n  }\n\n  createEndSessionUrl(idTokenHint, configId, customParamsEndSession) {\n    // Auth0 needs a special logout url\n    // See https://auth0.com/docs/api/authentication#logout\n    if (this.isAuth0Endpoint(configId)) {\n      return this.composeAuth0Endpoint(configId);\n    }\n\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n    const endSessionEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.endSessionEndpoint;\n\n    if (!endSessionEndpoint) {\n      return null;\n    }\n\n    const urlParts = endSessionEndpoint.split('?');\n    const authorizationEndSessionUrl = urlParts[0];\n    const existingParams = urlParts[1];\n    let params = this.createHttpParams(existingParams);\n    params = params.set('id_token_hint', idTokenHint);\n    const postLogoutRedirectUri = this.getPostLogoutRedirectUrl(configId);\n\n    if (postLogoutRedirectUri) {\n      params = params.append('post_logout_redirect_uri', postLogoutRedirectUri);\n    }\n\n    if (customParamsEndSession) {\n      params = this.appendCustomParams(Object.assign({}, customParamsEndSession), params);\n    }\n\n    return `${authorizationEndSessionUrl}?${params}`;\n  }\n\n  createRevocationEndpointBodyAccessToken(token, configId) {\n    const clientId = this.getClientId(configId);\n\n    if (!clientId) {\n      return null;\n    }\n\n    let params = this.createHttpParams();\n    params = params.set('client_id', clientId);\n    params = params.set('token', token);\n    params = params.set('token_type_hint', 'access_token');\n    return params.toString();\n  }\n\n  createRevocationEndpointBodyRefreshToken(token, configId) {\n    const clientId = this.getClientId(configId);\n\n    if (!clientId) {\n      return null;\n    }\n\n    let params = this.createHttpParams();\n    params = params.set('client_id', clientId);\n    params = params.set('token', token);\n    params = params.set('token_type_hint', 'refresh_token');\n    return params.toString();\n  }\n\n  getRevocationEndpointUrl(configId) {\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n    const revocationEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.revocationEndpoint;\n\n    if (!revocationEndpoint) {\n      return null;\n    }\n\n    const urlParts = revocationEndpoint.split('?');\n    const revocationEndpointUrl = urlParts[0];\n    return revocationEndpointUrl;\n  }\n\n  createBodyForCodeFlowCodeRequest(code, configId, customTokenParams) {\n    const codeVerifier = this.flowsDataService.getCodeVerifier(configId);\n\n    if (!codeVerifier) {\n      this.loggerService.logError(configId, `CodeVerifier is not set `, codeVerifier);\n      return null;\n    }\n\n    const clientId = this.getClientId(configId);\n\n    if (!clientId) {\n      return null;\n    }\n\n    let params = this.createHttpParams();\n    params = params.set('grant_type', 'authorization_code');\n    params = params.set('client_id', clientId);\n    params = params.set('code_verifier', codeVerifier);\n    params = params.set('code', code);\n\n    if (customTokenParams) {\n      params = this.appendCustomParams(Object.assign({}, customTokenParams), params);\n    }\n\n    const silentRenewUrl = this.getSilentRenewUrl(configId);\n\n    if (this.flowsDataService.isSilentRenewRunning(configId) && silentRenewUrl) {\n      params = params.set('redirect_uri', silentRenewUrl);\n      return params.toString();\n    }\n\n    const redirectUrl = this.getRedirectUrl(configId);\n\n    if (!redirectUrl) {\n      return null;\n    }\n\n    params = params.set('redirect_uri', redirectUrl);\n    return params.toString();\n  }\n\n  createBodyForCodeFlowRefreshTokensRequest(refreshToken, configId, customParamsRefresh) {\n    const clientId = this.getClientId(configId);\n\n    if (!clientId) {\n      return null;\n    }\n\n    let params = this.createHttpParams();\n    params = params.set('grant_type', 'refresh_token');\n    params = params.set('client_id', clientId);\n    params = params.set('refresh_token', refreshToken);\n\n    if (customParamsRefresh) {\n      params = this.appendCustomParams(Object.assign({}, customParamsRefresh), params);\n    }\n\n    return params.toString();\n  }\n\n  createBodyForParCodeFlowRequest(configId, customParamsRequest) {\n    const redirectUrl = this.getRedirectUrl(configId);\n\n    if (!redirectUrl) {\n      return null;\n    }\n\n    const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\n    const nonce = this.flowsDataService.createNonce(configId);\n    this.loggerService.logDebug(configId, 'Authorize created. adding myautostate: ' + state); // code_challenge with \"S256\"\n\n    const codeVerifier = this.flowsDataService.createCodeVerifier(configId);\n    const codeChallenge = this.jsrsAsignReducedService.generateCodeChallenge(codeVerifier);\n    const {\n      clientId,\n      responseType,\n      scope,\n      hdParam,\n      customParamsAuthRequest\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    let params = this.createHttpParams('');\n    params = params.set('client_id', clientId);\n    params = params.append('redirect_uri', redirectUrl);\n    params = params.append('response_type', responseType);\n    params = params.append('scope', scope);\n    params = params.append('nonce', nonce);\n    params = params.append('state', state);\n    params = params.append('code_challenge', codeChallenge);\n    params = params.append('code_challenge_method', 'S256');\n\n    if (hdParam) {\n      params = params.append('hd', hdParam);\n    }\n\n    if (customParamsAuthRequest) {\n      params = this.appendCustomParams(Object.assign({}, customParamsAuthRequest), params);\n    }\n\n    if (customParamsRequest) {\n      params = this.appendCustomParams(Object.assign({}, customParamsRequest), params);\n    }\n\n    return params.toString();\n  }\n\n  createAuthorizeUrl(codeChallenge, redirectUrl, nonce, state, configId, prompt, customRequestParams) {\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n    const authorizationEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.authorizationEndpoint;\n\n    if (!authorizationEndpoint) {\n      this.loggerService.logError(configId, `Can not create an authorize URL when authorizationEndpoint is '${authorizationEndpoint}'`);\n      return null;\n    }\n\n    const {\n      clientId,\n      responseType,\n      scope,\n      hdParam,\n      customParamsAuthRequest\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!clientId) {\n      this.loggerService.logError(configId, `createAuthorizeUrl could not add clientId because it was: `, clientId);\n      return null;\n    }\n\n    if (!responseType) {\n      this.loggerService.logError(configId, `createAuthorizeUrl could not add responseType because it was: `, responseType);\n      return null;\n    }\n\n    if (!scope) {\n      this.loggerService.logError(configId, `createAuthorizeUrl could not add scope because it was: `, scope);\n      return null;\n    }\n\n    const urlParts = authorizationEndpoint.split('?');\n    const authorizationUrl = urlParts[0];\n    const existingParams = urlParts[1];\n    let params = this.createHttpParams(existingParams);\n    params = params.set('client_id', clientId);\n    params = params.append('redirect_uri', redirectUrl);\n    params = params.append('response_type', responseType);\n    params = params.append('scope', scope);\n    params = params.append('nonce', nonce);\n    params = params.append('state', state);\n\n    if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\n      params = params.append('code_challenge', codeChallenge);\n      params = params.append('code_challenge_method', 'S256');\n    }\n\n    const mergedParams = Object.assign(Object.assign({}, customParamsAuthRequest), customRequestParams);\n\n    if (Object.keys(mergedParams).length > 0) {\n      params = this.appendCustomParams(Object.assign({}, mergedParams), params);\n    }\n\n    if (prompt) {\n      params = this.overWriteParam(params, 'prompt', prompt);\n    }\n\n    if (hdParam) {\n      params = params.append('hd', hdParam);\n    }\n\n    return `${authorizationUrl}?${params}`;\n  }\n\n  createUrlImplicitFlowWithSilentRenew(configId, customParams) {\n    const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\n    const nonce = this.flowsDataService.createNonce(configId);\n    const silentRenewUrl = this.getSilentRenewUrl(configId);\n\n    if (!silentRenewUrl) {\n      return null;\n    }\n\n    this.loggerService.logDebug(configId, 'RefreshSession created. adding myautostate: ', state);\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n    if (authWellKnownEndPoints) {\n      return this.createAuthorizeUrl('', silentRenewUrl, nonce, state, configId, 'none', customParams);\n    }\n\n    this.loggerService.logError(configId, 'authWellKnownEndpoints is undefined');\n    return null;\n  }\n\n  createUrlCodeFlowWithSilentRenew(configId, customParams) {\n    const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\n    const nonce = this.flowsDataService.createNonce(configId);\n    this.loggerService.logDebug(configId, 'RefreshSession created. adding myautostate: ' + state); // code_challenge with \"S256\"\n\n    const codeVerifier = this.flowsDataService.createCodeVerifier(configId);\n    const codeChallenge = this.jsrsAsignReducedService.generateCodeChallenge(codeVerifier);\n    const silentRenewUrl = this.getSilentRenewUrl(configId);\n\n    if (!silentRenewUrl) {\n      return null;\n    }\n\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n    if (authWellKnownEndPoints) {\n      return this.createAuthorizeUrl(codeChallenge, silentRenewUrl, nonce, state, configId, 'none', customParams);\n    }\n\n    this.loggerService.logWarning(configId, 'authWellKnownEndpoints is undefined');\n    return null;\n  }\n\n  createUrlImplicitFlowAuthorize(configId, customParams) {\n    const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\n    const nonce = this.flowsDataService.createNonce(configId);\n    this.loggerService.logDebug(configId, 'Authorize created. adding myautostate: ' + state);\n    const redirectUrl = this.getRedirectUrl(configId);\n\n    if (!redirectUrl) {\n      return null;\n    }\n\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n    if (authWellKnownEndPoints) {\n      return this.createAuthorizeUrl('', redirectUrl, nonce, state, configId, null, customParams);\n    }\n\n    this.loggerService.logError(configId, 'authWellKnownEndpoints is undefined');\n    return null;\n  }\n\n  createUrlCodeFlowAuthorize(configId, customParams) {\n    const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\n    const nonce = this.flowsDataService.createNonce(configId);\n    this.loggerService.logDebug(configId, 'Authorize created. adding myautostate: ' + state);\n    const redirectUrl = this.getRedirectUrl(configId);\n\n    if (!redirectUrl) {\n      return null;\n    } // code_challenge with \"S256\"\n\n\n    const codeVerifier = this.flowsDataService.createCodeVerifier(configId);\n    const codeChallenge = this.jsrsAsignReducedService.generateCodeChallenge(codeVerifier);\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n    if (authWellKnownEndPoints) {\n      return this.createAuthorizeUrl(codeChallenge, redirectUrl, nonce, state, configId, null, customParams);\n    }\n\n    this.loggerService.logError(configId, 'authWellKnownEndpoints is undefined');\n    return null;\n  }\n\n  getRedirectUrl(configId) {\n    const {\n      redirectUrl\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!redirectUrl) {\n      this.loggerService.logError(configId, `could not get redirectUrl, was: `, redirectUrl);\n      null;\n    }\n\n    return redirectUrl;\n  }\n\n  getSilentRenewUrl(configId) {\n    const {\n      silentRenewUrl\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!silentRenewUrl) {\n      this.loggerService.logError(configId, `could not get silentRenewUrl, was: `, silentRenewUrl);\n      return null;\n    }\n\n    return silentRenewUrl;\n  }\n\n  getPostLogoutRedirectUrl(configId) {\n    const {\n      postLogoutRedirectUri\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!postLogoutRedirectUri) {\n      this.loggerService.logError(configId, `could not get postLogoutRedirectUri, was: `, postLogoutRedirectUri);\n      return null;\n    }\n\n    return postLogoutRedirectUri;\n  }\n\n  getClientId(configId) {\n    const {\n      clientId\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!clientId) {\n      this.loggerService.logError(configId, `could not get clientId, was: `, clientId);\n      return null;\n    }\n\n    return clientId;\n  }\n\n  appendCustomParams(customParams, params) {\n    for (const [key, value] of Object.entries(Object.assign({}, customParams))) {\n      params = params.append(key, value.toString());\n    }\n\n    return params;\n  }\n\n  overWriteParam(params, key, value) {\n    return params.set(key, value);\n  }\n\n  createHttpParams(existingParams) {\n    existingParams = existingParams !== null && existingParams !== void 0 ? existingParams : '';\n    const params = new HttpParams({\n      fromString: existingParams,\n      encoder: new UriEncoder()\n    });\n    return params;\n  }\n\n  isAuth0Endpoint(configId) {\n    const {\n      authority\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!authority) {\n      return false;\n    }\n\n    return authority.endsWith(AUTH0_ENDPOINT);\n  }\n\n  composeAuth0Endpoint(configId) {\n    // format: https://YOUR_DOMAIN/v2/logout?client_id=YOUR_CLIENT_ID&returnTo=LOGOUT_URL\n    const {\n      authority,\n      clientId\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    const postLogoutRedirectUrl = this.getPostLogoutRedirectUrl(configId);\n    return `${authority}/v2/logout?client_id=${clientId}&returnTo=${postLogoutRedirectUrl}`;\n  }\n\n}\n\nUrlService.ɵfac = function UrlService_Factory(t) {\n  return new (t || UrlService)(i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(LoggerService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(FlowHelper), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(JsrsAsignReducedService));\n};\n\nUrlService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: UrlService,\n  factory: UrlService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(UrlService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ConfigurationProvider\n    }, {\n      type: LoggerService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: FlowHelper\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: JsrsAsignReducedService\n    }];\n  }, null);\n})();\n\nclass CodeFlowCallbackHandlerService {\n  constructor(urlService, loggerService, tokenValidationService, flowsDataService, configurationProvider, storagePersistenceService, dataService) {\n    this.urlService = urlService;\n    this.loggerService = loggerService;\n    this.tokenValidationService = tokenValidationService;\n    this.flowsDataService = flowsDataService;\n    this.configurationProvider = configurationProvider;\n    this.storagePersistenceService = storagePersistenceService;\n    this.dataService = dataService;\n  } // STEP 1 Code Flow\n\n\n  codeFlowCallback(urlToCheck, configId) {\n    const code = this.urlService.getUrlParameter(urlToCheck, 'code');\n    const state = this.urlService.getUrlParameter(urlToCheck, 'state');\n    const sessionState = this.urlService.getUrlParameter(urlToCheck, 'session_state');\n\n    if (!state) {\n      this.loggerService.logDebug(configId, 'no state in url');\n      return throwError('no state in url');\n    }\n\n    if (!code) {\n      this.loggerService.logDebug(configId, 'no code in url');\n      return throwError('no code in url');\n    }\n\n    this.loggerService.logDebug(configId, 'running validation for callback', urlToCheck);\n    const initialCallbackContext = {\n      code,\n      refreshToken: null,\n      state,\n      sessionState,\n      authResult: null,\n      isRenewProcess: false,\n      jwtKeys: null,\n      validationResult: null,\n      existingIdToken: null\n    };\n    return of(initialCallbackContext);\n  } // STEP 2 Code Flow //  Code Flow Silent Renew starts here\n\n\n  codeFlowCodeRequest(callbackContext, configId) {\n    const authStateControl = this.flowsDataService.getAuthStateControl(configId);\n    const isStateCorrect = this.tokenValidationService.validateStateFromHashCallback(callbackContext.state, authStateControl, configId);\n\n    if (!isStateCorrect) {\n      return throwError('codeFlowCodeRequest incorrect state');\n    }\n\n    const authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n    const tokenEndpoint = authWellknownEndpoints === null || authWellknownEndpoints === void 0 ? void 0 : authWellknownEndpoints.tokenEndpoint;\n\n    if (!tokenEndpoint) {\n      return throwError('Token Endpoint not defined');\n    }\n\n    let headers = new HttpHeaders();\n    headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n    const config = this.configurationProvider.getOpenIDConfiguration(configId);\n    const bodyForCodeFlow = this.urlService.createBodyForCodeFlowCodeRequest(callbackContext.code, configId, config === null || config === void 0 ? void 0 : config.customParamsCodeRequest);\n    return this.dataService.post(tokenEndpoint, bodyForCodeFlow, configId, headers).pipe(switchMap(response => {\n      let authResult = new Object();\n      authResult = response;\n      authResult.state = callbackContext.state;\n      authResult.session_state = callbackContext.sessionState;\n      callbackContext.authResult = authResult;\n      return of(callbackContext);\n    }), retryWhen(error => this.handleRefreshRetry(error, configId)), catchError(error => {\n      const {\n        authority\n      } = this.configurationProvider.getOpenIDConfiguration(configId);\n      const errorMessage = `OidcService code request ${authority}`;\n      this.loggerService.logError(configId, errorMessage, error);\n      return throwError(errorMessage);\n    }));\n  }\n\n  handleRefreshRetry(errors, configId) {\n    return errors.pipe(mergeMap(error => {\n      // retry token refresh if there is no internet connection\n      if (error && error instanceof HttpErrorResponse && error.error instanceof ProgressEvent && error.error.type === 'error') {\n        const {\n          authority,\n          refreshTokenRetryInSeconds\n        } = this.configurationProvider.getOpenIDConfiguration(configId);\n        const errorMessage = `OidcService code request ${authority} - no internet connection`;\n        this.loggerService.logWarning(configId, errorMessage, error);\n        return timer(refreshTokenRetryInSeconds * 1000);\n      }\n\n      return throwError(error);\n    }));\n  }\n\n}\n\nCodeFlowCallbackHandlerService.ɵfac = function CodeFlowCallbackHandlerService_Factory(t) {\n  return new (t || CodeFlowCallbackHandlerService)(i0.ɵɵinject(UrlService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(TokenValidationService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(DataService));\n};\n\nCodeFlowCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CodeFlowCallbackHandlerService,\n  factory: CodeFlowCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CodeFlowCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: UrlService\n    }, {\n      type: LoggerService\n    }, {\n      type: TokenValidationService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: DataService\n    }];\n  }, null);\n})();\n\nconst DEFAULT_USERRESULT = {\n  userData: null,\n  allUserData: []\n};\n\nclass UserService {\n  constructor(oidcDataService, storagePersistenceService, eventService, loggerService, tokenHelperService, flowHelper, configurationProvider) {\n    this.oidcDataService = oidcDataService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.eventService = eventService;\n    this.loggerService = loggerService;\n    this.tokenHelperService = tokenHelperService;\n    this.flowHelper = flowHelper;\n    this.configurationProvider = configurationProvider;\n    this.userDataInternal$ = new BehaviorSubject(DEFAULT_USERRESULT);\n  }\n\n  get userData$() {\n    return this.userDataInternal$.asObservable();\n  }\n\n  getAndPersistUserDataInStore(configId, isRenewProcess = false, idToken, decodedIdToken) {\n    idToken = idToken || this.storagePersistenceService.getIdToken(configId);\n    decodedIdToken = decodedIdToken || this.tokenHelperService.getPayloadFromToken(idToken, false, configId);\n    const existingUserDataFromStorage = this.getUserDataFromStore(configId);\n    const haveUserData = !!existingUserDataFromStorage;\n    const isCurrentFlowImplicitFlowWithAccessToken = this.flowHelper.isCurrentFlowImplicitFlowWithAccessToken(configId);\n    const isCurrentFlowCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(configId);\n    const accessToken = this.storagePersistenceService.getAccessToken(configId);\n\n    if (!(isCurrentFlowImplicitFlowWithAccessToken || isCurrentFlowCodeFlow)) {\n      this.loggerService.logDebug(configId, `authCallback idToken flow with accessToken ${accessToken}`);\n      this.setUserDataToStore(decodedIdToken, configId);\n      return of(decodedIdToken);\n    }\n\n    const {\n      renewUserInfoAfterTokenRenew\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!isRenewProcess || renewUserInfoAfterTokenRenew || !haveUserData) {\n      return this.getUserDataOidcFlowAndSave(decodedIdToken.sub, configId).pipe(switchMap(userData => {\n        this.loggerService.logDebug(configId, 'Received user data: ', userData);\n\n        if (!!userData) {\n          this.loggerService.logDebug(configId, 'accessToken: ', accessToken);\n          return of(userData);\n        } else {\n          return throwError('Received no user data, request failed');\n        }\n      }));\n    }\n\n    return of(existingUserDataFromStorage);\n  }\n\n  getUserDataFromStore(configId) {\n    return this.storagePersistenceService.read('userData', configId) || null;\n  }\n\n  publishUserDataIfExists(configId) {\n    const userData = this.getUserDataFromStore(configId);\n\n    if (userData) {\n      this.fireUserDataEvent(configId, userData);\n    }\n  }\n\n  setUserDataToStore(userData, configId) {\n    this.storagePersistenceService.write('userData', userData, configId);\n    this.fireUserDataEvent(configId, userData);\n  }\n\n  resetUserDataInStore(configId) {\n    this.storagePersistenceService.remove('userData', configId);\n    this.fireUserDataEvent(configId, null);\n  }\n\n  getUserDataOidcFlowAndSave(idTokenSub, configId) {\n    return this.getIdentityUserData(configId).pipe(map(data => {\n      if (this.validateUserDataSubIdToken(idTokenSub, data === null || data === void 0 ? void 0 : data.sub)) {\n        this.setUserDataToStore(data, configId);\n        return data;\n      } else {\n        // something went wrong, user data sub does not match that from id_token\n        this.loggerService.logWarning(configId, `User data sub does not match sub in id_token, resetting`);\n        this.resetUserDataInStore(configId);\n        return null;\n      }\n    }));\n  }\n\n  getIdentityUserData(configId) {\n    const token = this.storagePersistenceService.getAccessToken(configId);\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n    if (!authWellKnownEndPoints) {\n      this.loggerService.logWarning(configId, 'init check session: authWellKnownEndpoints is undefined');\n      return throwError('authWellKnownEndpoints is undefined');\n    }\n\n    const userInfoEndpoint = authWellKnownEndPoints.userInfoEndpoint;\n\n    if (!userInfoEndpoint) {\n      this.loggerService.logError(configId, 'init check session: authWellKnownEndpoints.userinfo_endpoint is undefined; set auto_userinfo = false in config');\n      return throwError('authWellKnownEndpoints.userinfo_endpoint is undefined');\n    }\n\n    return this.oidcDataService.get(userInfoEndpoint, configId, token).pipe(retry(2));\n  }\n\n  validateUserDataSubIdToken(idTokenSub, userDataSub) {\n    if (!idTokenSub) {\n      return false;\n    }\n\n    if (!userDataSub) {\n      return false;\n    }\n\n    if (idTokenSub !== userDataSub) {\n      this.loggerService.logDebug('validateUserDataSubIdToken failed', idTokenSub, userDataSub);\n      return false;\n    }\n\n    return true;\n  }\n\n  fireUserDataEvent(configId, passedUserData) {\n    const userData = this.composeSingleOrMultipleUserDataObject(configId, passedUserData);\n    this.userDataInternal$.next(userData);\n    this.eventService.fireEvent(EventTypes.UserDataChanged, {\n      configId,\n      userData: passedUserData\n    });\n  }\n\n  composeSingleOrMultipleUserDataObject(configId, passedUserData) {\n    const hasManyConfigs = this.configurationProvider.hasManyConfigs();\n\n    if (!hasManyConfigs) {\n      return this.composeSingleUserDataResult(configId, passedUserData);\n    }\n\n    const configs = this.configurationProvider.getAllConfigurations();\n    const allUserData = configs.map(config => {\n      if (this.currentConfigIsToUpdate(configId, config)) {\n        return {\n          configId: config.configId,\n          userData: passedUserData\n        };\n      }\n\n      const alreadySavedUserData = this.storagePersistenceService.read('userData', config.configId) || null;\n      return {\n        configId: config.configId,\n        userData: alreadySavedUserData\n      };\n    });\n    return {\n      userData: null,\n      allUserData\n    };\n  }\n\n  composeSingleUserDataResult(configId, userData) {\n    return {\n      userData,\n      allUserData: [{\n        configId,\n        userData\n      }]\n    };\n  }\n\n  currentConfigIsToUpdate(configId, config) {\n    return config.configId === configId;\n  }\n\n}\n\nUserService.ɵfac = function UserService_Factory(t) {\n  return new (t || UserService)(i0.ɵɵinject(DataService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(TokenHelperService), i0.ɵɵinject(FlowHelper), i0.ɵɵinject(ConfigurationProvider));\n};\n\nUserService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: UserService,\n  factory: UserService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(UserService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: DataService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: PublicEventsService\n    }, {\n      type: LoggerService\n    }, {\n      type: TokenHelperService\n    }, {\n      type: FlowHelper\n    }, {\n      type: ConfigurationProvider\n    }];\n  }, null);\n})();\n\nclass ResetAuthDataService {\n  constructor(authStateService, flowsDataService, userService) {\n    this.authStateService = authStateService;\n    this.flowsDataService = flowsDataService;\n    this.userService = userService;\n  }\n\n  resetAuthorizationData(configId) {\n    this.userService.resetUserDataInStore(configId);\n    this.flowsDataService.resetStorageFlowData(configId);\n    this.authStateService.setUnauthenticatedAndFireEvent(configId);\n  }\n\n}\n\nResetAuthDataService.ɵfac = function ResetAuthDataService_Factory(t) {\n  return new (t || ResetAuthDataService)(i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(UserService));\n};\n\nResetAuthDataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ResetAuthDataService,\n  factory: ResetAuthDataService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ResetAuthDataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: AuthStateService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: UserService\n    }];\n  }, null);\n})();\n\nclass ImplicitFlowCallbackHandlerService {\n  constructor(resetAuthDataService, loggerService, flowsDataService, doc) {\n    this.resetAuthDataService = resetAuthDataService;\n    this.loggerService = loggerService;\n    this.flowsDataService = flowsDataService;\n    this.doc = doc;\n  } // STEP 1 Code Flow\n  // STEP 1 Implicit Flow\n\n\n  implicitFlowCallback(configId, hash) {\n    const isRenewProcessData = this.flowsDataService.isSilentRenewRunning(configId);\n    this.loggerService.logDebug(configId, 'BEGIN callback, no auth data');\n\n    if (!isRenewProcessData) {\n      this.resetAuthDataService.resetAuthorizationData(configId);\n    }\n\n    hash = hash || this.doc.location.hash.substr(1);\n    const authResult = hash.split('&').reduce((resultData, item) => {\n      const parts = item.split('=');\n      resultData[parts.shift()] = parts.join('=');\n      return resultData;\n    }, {});\n    const callbackContext = {\n      code: null,\n      refreshToken: null,\n      state: null,\n      sessionState: null,\n      authResult,\n      isRenewProcess: isRenewProcessData,\n      jwtKeys: null,\n      validationResult: null,\n      existingIdToken: null\n    };\n    return of(callbackContext);\n  }\n\n}\n\nImplicitFlowCallbackHandlerService.ɵfac = function ImplicitFlowCallbackHandlerService_Factory(t) {\n  return new (t || ImplicitFlowCallbackHandlerService)(i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(DOCUMENT));\n};\n\nImplicitFlowCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ImplicitFlowCallbackHandlerService,\n  factory: ImplicitFlowCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ImplicitFlowCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ResetAuthDataService\n    }, {\n      type: LoggerService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n/* eslint-disable no-shadow */\n\n\nvar ValidationResult;\n\n(function (ValidationResult) {\n  ValidationResult[\"NotSet\"] = \"NotSet\";\n  ValidationResult[\"StatesDoNotMatch\"] = \"StatesDoNotMatch\";\n  ValidationResult[\"SignatureFailed\"] = \"SignatureFailed\";\n  ValidationResult[\"IncorrectNonce\"] = \"IncorrectNonce\";\n  ValidationResult[\"RequiredPropertyMissing\"] = \"RequiredPropertyMissing\";\n  ValidationResult[\"MaxOffsetExpired\"] = \"MaxOffsetExpired\";\n  ValidationResult[\"IssDoesNotMatchIssuer\"] = \"IssDoesNotMatchIssuer\";\n  ValidationResult[\"NoAuthWellKnownEndPoints\"] = \"NoAuthWellKnownEndPoints\";\n  ValidationResult[\"IncorrectAud\"] = \"IncorrectAud\";\n  ValidationResult[\"IncorrectIdTokenClaimsAfterRefresh\"] = \"IncorrectIdTokenClaimsAfterRefresh\";\n  ValidationResult[\"IncorrectAzp\"] = \"IncorrectAzp\";\n  ValidationResult[\"TokenExpired\"] = \"TokenExpired\";\n  ValidationResult[\"IncorrectAtHash\"] = \"IncorrectAtHash\";\n  ValidationResult[\"Ok\"] = \"Ok\";\n  ValidationResult[\"LoginRequired\"] = \"LoginRequired\";\n  ValidationResult[\"SecureTokenServerError\"] = \"SecureTokenServerError\";\n})(ValidationResult || (ValidationResult = {}));\n\nclass SigninKeyDataService {\n  constructor(storagePersistenceService, loggerService, dataService) {\n    this.storagePersistenceService = storagePersistenceService;\n    this.loggerService = loggerService;\n    this.dataService = dataService;\n  }\n\n  getSigningKeys(configId) {\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n    const jwksUri = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.jwksUri;\n\n    if (!jwksUri) {\n      const error = `getSigningKeys: authWellKnownEndpoints.jwksUri is: '${jwksUri}'`;\n      this.loggerService.logWarning(configId, error);\n      return throwError(error);\n    }\n\n    this.loggerService.logDebug(configId, 'Getting signinkeys from ', jwksUri);\n    return this.dataService.get(jwksUri, configId).pipe(retry(2), catchError(e => this.handleErrorGetSigningKeys(e, configId)));\n  }\n\n  handleErrorGetSigningKeys(errorResponse, configId) {\n    let errMsg = '';\n\n    if (errorResponse instanceof HttpResponse) {\n      const body = errorResponse.body || {};\n      const err = JSON.stringify(body);\n      const {\n        status,\n        statusText\n      } = errorResponse;\n      errMsg = `${status || ''} - ${statusText || ''} ${err || ''}`;\n    } else {\n      const {\n        message\n      } = errorResponse;\n      errMsg = !!message ? message : `${errorResponse}`;\n    }\n\n    this.loggerService.logError(configId, errMsg);\n    return throwError(errMsg);\n  }\n\n}\n\nSigninKeyDataService.ɵfac = function SigninKeyDataService_Factory(t) {\n  return new (t || SigninKeyDataService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(DataService));\n};\n\nSigninKeyDataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: SigninKeyDataService,\n  factory: SigninKeyDataService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SigninKeyDataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: LoggerService\n    }, {\n      type: DataService\n    }];\n  }, null);\n})();\n\nconst JWT_KEYS = 'jwtKeys';\n\nclass HistoryJwtKeysCallbackHandlerService {\n  constructor(loggerService, configurationProvider, authStateService, flowsDataService, signInKeyDataService, storagePersistenceService, resetAuthDataService) {\n    this.loggerService = loggerService;\n    this.configurationProvider = configurationProvider;\n    this.authStateService = authStateService;\n    this.flowsDataService = flowsDataService;\n    this.signInKeyDataService = signInKeyDataService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.resetAuthDataService = resetAuthDataService;\n  } // STEP 3 Code Flow, STEP 2 Implicit Flow, STEP 3 Refresh Token\n\n\n  callbackHistoryAndResetJwtKeys(callbackContext, configId) {\n    this.storagePersistenceService.write('authnResult', callbackContext.authResult, configId);\n\n    if (this.historyCleanUpTurnedOn(configId) && !callbackContext.isRenewProcess) {\n      this.resetBrowserHistory();\n    } else {\n      this.loggerService.logDebug(configId, 'history clean up inactive');\n    }\n\n    if (callbackContext.authResult.error) {\n      const errorMessage = `AuthCallback AuthResult came with error: ${callbackContext.authResult.error}`;\n      this.loggerService.logDebug(configId, errorMessage);\n      this.resetAuthDataService.resetAuthorizationData(configId);\n      this.flowsDataService.setNonce('', configId);\n      this.handleResultErrorFromCallback(callbackContext.authResult, callbackContext.isRenewProcess);\n      return throwError(errorMessage);\n    }\n\n    this.loggerService.logDebug(configId, `AuthResult '${JSON.stringify(callbackContext.authResult, null, 2)}'.\n      AuthCallback created, begin token validation`);\n    return this.signInKeyDataService.getSigningKeys(configId).pipe(tap(jwtKeys => this.storeSigningKeys(jwtKeys, configId)), catchError(err => {\n      // fallback: try to load jwtKeys from storage\n      const storedJwtKeys = this.readSigningKeys(configId);\n\n      if (!!storedJwtKeys) {\n        this.loggerService.logWarning(configId, `Failed to retrieve signing keys, fallback to stored keys`);\n        return of(storedJwtKeys);\n      }\n\n      return throwError(err);\n    }), switchMap(jwtKeys => {\n      if (jwtKeys) {\n        callbackContext.jwtKeys = jwtKeys;\n        return of(callbackContext);\n      }\n\n      const errorMessage = `Failed to retrieve signing key`;\n      this.loggerService.logWarning(configId, errorMessage);\n      return throwError(errorMessage);\n    }), catchError(err => {\n      const errorMessage = `Failed to retrieve signing key with error: ${err}`;\n      this.loggerService.logWarning(configId, errorMessage);\n      return throwError(errorMessage);\n    }));\n  }\n\n  handleResultErrorFromCallback(result, isRenewProcess) {\n    let validationResult = ValidationResult.SecureTokenServerError;\n\n    if (result.error === 'login_required') {\n      validationResult = ValidationResult.LoginRequired;\n    }\n\n    this.authStateService.updateAndPublishAuthState({\n      isAuthenticated: false,\n      validationResult,\n      isRenewProcess\n    });\n  }\n\n  historyCleanUpTurnedOn(configId) {\n    const {\n      historyCleanupOff\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    return !historyCleanupOff;\n  }\n\n  resetBrowserHistory() {\n    window.history.replaceState({}, window.document.title, window.location.origin + window.location.pathname);\n  }\n\n  storeSigningKeys(jwtKeys, configId) {\n    this.storagePersistenceService.write(JWT_KEYS, jwtKeys, configId);\n  }\n\n  readSigningKeys(configId) {\n    return this.storagePersistenceService.read(JWT_KEYS, configId);\n  }\n\n}\n\nHistoryJwtKeysCallbackHandlerService.ɵfac = function HistoryJwtKeysCallbackHandlerService_Factory(t) {\n  return new (t || HistoryJwtKeysCallbackHandlerService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(SigninKeyDataService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(ResetAuthDataService));\n};\n\nHistoryJwtKeysCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: HistoryJwtKeysCallbackHandlerService,\n  factory: HistoryJwtKeysCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(HistoryJwtKeysCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: AuthStateService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: SigninKeyDataService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: ResetAuthDataService\n    }];\n  }, null);\n})();\n\nclass UserCallbackHandlerService {\n  constructor(loggerService, configurationProvider, authStateService, flowsDataService, userService, resetAuthDataService) {\n    this.loggerService = loggerService;\n    this.configurationProvider = configurationProvider;\n    this.authStateService = authStateService;\n    this.flowsDataService = flowsDataService;\n    this.userService = userService;\n    this.resetAuthDataService = resetAuthDataService;\n  } // STEP 5 userData\n\n\n  callbackUser(callbackContext, configId) {\n    const {\n      isRenewProcess,\n      validationResult,\n      authResult,\n      refreshToken\n    } = callbackContext;\n    const {\n      autoUserInfo,\n      renewUserInfoAfterTokenRenew\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!autoUserInfo) {\n      if (!isRenewProcess || renewUserInfoAfterTokenRenew) {\n        // userData is set to the id_token decoded, auto get user data set to false\n        if (validationResult.decodedIdToken) {\n          this.userService.setUserDataToStore(validationResult.decodedIdToken, configId);\n        }\n      }\n\n      if (!isRenewProcess && !refreshToken) {\n        this.flowsDataService.setSessionState(authResult.session_state, configId);\n      }\n\n      this.publishAuthState(validationResult, isRenewProcess);\n      return of(callbackContext);\n    }\n\n    return this.userService.getAndPersistUserDataInStore(configId, isRenewProcess, validationResult.idToken, validationResult.decodedIdToken).pipe(switchMap(userData => {\n      if (!!userData) {\n        if (!refreshToken) {\n          this.flowsDataService.setSessionState(authResult.session_state, configId);\n        }\n\n        this.publishAuthState(validationResult, isRenewProcess);\n        return of(callbackContext);\n      } else {\n        this.resetAuthDataService.resetAuthorizationData(configId);\n        this.publishUnauthenticatedState(validationResult, isRenewProcess);\n        const errorMessage = `Called for userData but they were ${userData}`;\n        this.loggerService.logWarning(configId, errorMessage);\n        return throwError(errorMessage);\n      }\n    }), catchError(err => {\n      const errorMessage = `Failed to retrieve user info with error:  ${err}`;\n      this.loggerService.logWarning(configId, errorMessage);\n      return throwError(errorMessage);\n    }));\n  }\n\n  publishAuthState(stateValidationResult, isRenewProcess) {\n    this.authStateService.updateAndPublishAuthState({\n      isAuthenticated: true,\n      validationResult: stateValidationResult.state,\n      isRenewProcess\n    });\n  }\n\n  publishUnauthenticatedState(stateValidationResult, isRenewProcess) {\n    this.authStateService.updateAndPublishAuthState({\n      isAuthenticated: false,\n      validationResult: stateValidationResult.state,\n      isRenewProcess\n    });\n  }\n\n}\n\nUserCallbackHandlerService.ɵfac = function UserCallbackHandlerService_Factory(t) {\n  return new (t || UserCallbackHandlerService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(UserService), i0.ɵɵinject(ResetAuthDataService));\n};\n\nUserCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: UserCallbackHandlerService,\n  factory: UserCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(UserCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: AuthStateService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: UserService\n    }, {\n      type: ResetAuthDataService\n    }];\n  }, null);\n})();\n\nclass StateValidationResult {\n  constructor(accessToken = '', idToken = '', authResponseIsValid = false, decodedIdToken = {}, state = ValidationResult.NotSet) {\n    this.accessToken = accessToken;\n    this.idToken = idToken;\n    this.authResponseIsValid = authResponseIsValid;\n    this.decodedIdToken = decodedIdToken;\n    this.state = state;\n  }\n\n}\n\nclass EqualityService {\n  isStringEqualOrNonOrderedArrayEqual(value1, value2) {\n    if (this.isNullOrUndefined(value1)) {\n      return false;\n    }\n\n    if (this.isNullOrUndefined(value2)) {\n      return false;\n    }\n\n    if (this.oneValueIsStringAndTheOtherIsArray(value1, value2)) {\n      return false;\n    }\n\n    if (this.bothValuesAreStrings(value1, value2)) {\n      return value1 === value2;\n    }\n\n    if (this.bothValuesAreArrays(value1, value2)) {\n      return this.arraysHaveEqualContent(value1, value2);\n    }\n\n    return false;\n  }\n\n  areEqual(value1, value2) {\n    if (!value1 || !value2) {\n      return false;\n    }\n\n    if (this.bothValuesAreArrays(value1, value2)) {\n      return this.arraysStrictEqual(value1, value2);\n    }\n\n    if (this.bothValuesAreStrings(value1, value2)) {\n      return value1 === value2;\n    }\n\n    if (this.bothValuesAreObjects(value1, value2)) {\n      return JSON.stringify(value1).toLowerCase() === JSON.stringify(value2).toLowerCase();\n    }\n\n    if (this.oneValueIsStringAndTheOtherIsArray(value1, value2)) {\n      if (Array.isArray(value1) && this.valueIsString(value2)) {\n        return value1[0] === value2;\n      }\n\n      if (Array.isArray(value2) && this.valueIsString(value1)) {\n        return value2[0] === value1;\n      }\n    }\n\n    return false;\n  }\n\n  oneValueIsStringAndTheOtherIsArray(value1, value2) {\n    return Array.isArray(value1) && this.valueIsString(value2) || Array.isArray(value2) && this.valueIsString(value1);\n  }\n\n  bothValuesAreObjects(value1, value2) {\n    return this.valueIsObject(value1) && this.valueIsObject(value2);\n  }\n\n  bothValuesAreStrings(value1, value2) {\n    return this.valueIsString(value1) && this.valueIsString(value2);\n  }\n\n  bothValuesAreArrays(value1, value2) {\n    return Array.isArray(value1) && Array.isArray(value2);\n  }\n\n  valueIsString(value) {\n    return typeof value === 'string' || value instanceof String;\n  }\n\n  valueIsObject(value) {\n    return typeof value === 'object';\n  }\n\n  arraysStrictEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n      return false;\n    }\n\n    for (let i = arr1.length; i--;) {\n      if (arr1[i] !== arr2[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  arraysHaveEqualContent(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n      return false;\n    }\n\n    return arr1.some(v => arr2.includes(v));\n  }\n\n  isNullOrUndefined(val) {\n    return val === null || val === undefined;\n  }\n\n}\n\nEqualityService.ɵfac = function EqualityService_Factory(t) {\n  return new (t || EqualityService)();\n};\n\nEqualityService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: EqualityService,\n  factory: EqualityService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(EqualityService, [{\n    type: Injectable\n  }], null, null);\n})();\n\nclass StateValidationService {\n  constructor(storagePersistenceService, tokenValidationService, tokenHelperService, loggerService, configurationProvider, equalityService, flowHelper) {\n    this.storagePersistenceService = storagePersistenceService;\n    this.tokenValidationService = tokenValidationService;\n    this.tokenHelperService = tokenHelperService;\n    this.loggerService = loggerService;\n    this.configurationProvider = configurationProvider;\n    this.equalityService = equalityService;\n    this.flowHelper = flowHelper;\n  }\n\n  getValidatedStateResult(callbackContext, configId) {\n    if (!callbackContext) {\n      return new StateValidationResult('', '', false, {});\n    }\n\n    if (callbackContext.authResult.error) {\n      return new StateValidationResult('', '', false, {});\n    }\n\n    return this.validateState(callbackContext, configId);\n  }\n\n  validateState(callbackContext, configId) {\n    const toReturn = new StateValidationResult();\n    const authStateControl = this.storagePersistenceService.read('authStateControl', configId);\n\n    if (!this.tokenValidationService.validateStateFromHashCallback(callbackContext.authResult.state, authStateControl, configId)) {\n      this.loggerService.logWarning(configId, 'authCallback incorrect state');\n      toReturn.state = ValidationResult.StatesDoNotMatch;\n      this.handleUnsuccessfulValidation(configId);\n      return toReturn;\n    }\n\n    const isCurrentFlowImplicitFlowWithAccessToken = this.flowHelper.isCurrentFlowImplicitFlowWithAccessToken(configId);\n    const isCurrentFlowCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(configId);\n\n    if (isCurrentFlowImplicitFlowWithAccessToken || isCurrentFlowCodeFlow) {\n      toReturn.accessToken = callbackContext.authResult.access_token;\n    }\n\n    if (callbackContext.authResult.id_token) {\n      const {\n        clientId,\n        issValidationOff,\n        maxIdTokenIatOffsetAllowedInSeconds,\n        disableIatOffsetValidation,\n        ignoreNonceAfterRefresh\n      } = this.configurationProvider.getOpenIDConfiguration(configId);\n      toReturn.idToken = callbackContext.authResult.id_token;\n      toReturn.decodedIdToken = this.tokenHelperService.getPayloadFromToken(toReturn.idToken, false, configId);\n\n      if (!this.tokenValidationService.validateSignatureIdToken(toReturn.idToken, callbackContext.jwtKeys, configId)) {\n        this.loggerService.logDebug(configId, 'authCallback Signature validation failed id_token');\n        toReturn.state = ValidationResult.SignatureFailed;\n        this.handleUnsuccessfulValidation(configId);\n        return toReturn;\n      }\n\n      const authNonce = this.storagePersistenceService.read('authNonce', configId);\n\n      if (!this.tokenValidationService.validateIdTokenNonce(toReturn.decodedIdToken, authNonce, ignoreNonceAfterRefresh, configId)) {\n        this.loggerService.logWarning(configId, 'authCallback incorrect nonce, did you call the checkAuth() method multiple times?');\n        toReturn.state = ValidationResult.IncorrectNonce;\n        this.handleUnsuccessfulValidation(configId);\n        return toReturn;\n      }\n\n      if (!this.tokenValidationService.validateRequiredIdToken(toReturn.decodedIdToken, configId)) {\n        this.loggerService.logDebug(configId, 'authCallback Validation, one of the REQUIRED properties missing from id_token');\n        toReturn.state = ValidationResult.RequiredPropertyMissing;\n        this.handleUnsuccessfulValidation(configId);\n        return toReturn;\n      }\n\n      if (!this.tokenValidationService.validateIdTokenIatMaxOffset(toReturn.decodedIdToken, maxIdTokenIatOffsetAllowedInSeconds, disableIatOffsetValidation, configId)) {\n        this.loggerService.logWarning(configId, 'authCallback Validation, iat rejected id_token was issued too far away from the current time');\n        toReturn.state = ValidationResult.MaxOffsetExpired;\n        this.handleUnsuccessfulValidation(configId);\n        return toReturn;\n      }\n\n      const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n      if (authWellKnownEndPoints) {\n        if (issValidationOff) {\n          this.loggerService.logDebug(configId, 'iss validation is turned off, this is not recommended!');\n        } else if (!issValidationOff && !this.tokenValidationService.validateIdTokenIss(toReturn.decodedIdToken, authWellKnownEndPoints.issuer, configId)) {\n          this.loggerService.logWarning(configId, 'authCallback incorrect iss does not match authWellKnownEndpoints issuer');\n          toReturn.state = ValidationResult.IssDoesNotMatchIssuer;\n          this.handleUnsuccessfulValidation(configId);\n          return toReturn;\n        }\n      } else {\n        this.loggerService.logWarning(configId, 'authWellKnownEndpoints is undefined');\n        toReturn.state = ValidationResult.NoAuthWellKnownEndPoints;\n        this.handleUnsuccessfulValidation(configId);\n        return toReturn;\n      }\n\n      if (!this.tokenValidationService.validateIdTokenAud(toReturn.decodedIdToken, clientId, configId)) {\n        this.loggerService.logWarning(configId, 'authCallback incorrect aud');\n        toReturn.state = ValidationResult.IncorrectAud;\n        this.handleUnsuccessfulValidation(configId);\n        return toReturn;\n      }\n\n      if (!this.tokenValidationService.validateIdTokenAzpExistsIfMoreThanOneAud(toReturn.decodedIdToken)) {\n        this.loggerService.logWarning(configId, 'authCallback missing azp');\n        toReturn.state = ValidationResult.IncorrectAzp;\n        this.handleUnsuccessfulValidation(configId);\n        return toReturn;\n      }\n\n      if (!this.tokenValidationService.validateIdTokenAzpValid(toReturn.decodedIdToken, clientId)) {\n        this.loggerService.logWarning(configId, 'authCallback incorrect azp');\n        toReturn.state = ValidationResult.IncorrectAzp;\n        this.handleUnsuccessfulValidation(configId);\n        return toReturn;\n      }\n\n      if (!this.isIdTokenAfterRefreshTokenRequestValid(callbackContext, toReturn.decodedIdToken, configId)) {\n        this.loggerService.logWarning(configId, 'authCallback pre, post id_token claims do not match in refresh');\n        toReturn.state = ValidationResult.IncorrectIdTokenClaimsAfterRefresh;\n        this.handleUnsuccessfulValidation(configId);\n        return toReturn;\n      }\n\n      if (!this.tokenValidationService.validateIdTokenExpNotExpired(toReturn.decodedIdToken, configId)) {\n        this.loggerService.logWarning(configId, 'authCallback id token expired');\n        toReturn.state = ValidationResult.TokenExpired;\n        this.handleUnsuccessfulValidation(configId);\n        return toReturn;\n      }\n    } else {\n      this.loggerService.logDebug(configId, 'No id_token found, skipping id_token validation');\n    } // flow id_token\n\n\n    if (!isCurrentFlowImplicitFlowWithAccessToken && !isCurrentFlowCodeFlow) {\n      toReturn.authResponseIsValid = true;\n      toReturn.state = ValidationResult.Ok;\n      this.handleSuccessfulValidation(configId);\n      this.handleUnsuccessfulValidation(configId);\n      return toReturn;\n    } // only do check if id_token returned, no always the case when using refresh tokens\n\n\n    if (callbackContext.authResult.id_token) {\n      const idTokenHeader = this.tokenHelperService.getHeaderFromToken(toReturn.idToken, false, configId); // The at_hash is optional for the code flow\n\n      if (isCurrentFlowCodeFlow && !toReturn.decodedIdToken.at_hash) {\n        this.loggerService.logDebug(configId, 'Code Flow active, and no at_hash in the id_token, skipping check!');\n      } else if (!this.tokenValidationService.validateIdTokenAtHash(toReturn.accessToken, toReturn.decodedIdToken.at_hash, idTokenHeader.alg, // 'RSA256'\n      configId) || !toReturn.accessToken) {\n        this.loggerService.logWarning(configId, 'authCallback incorrect at_hash');\n        toReturn.state = ValidationResult.IncorrectAtHash;\n        this.handleUnsuccessfulValidation(configId);\n        return toReturn;\n      }\n    }\n\n    toReturn.authResponseIsValid = true;\n    toReturn.state = ValidationResult.Ok;\n    this.handleSuccessfulValidation(configId);\n    return toReturn;\n  }\n\n  isIdTokenAfterRefreshTokenRequestValid(callbackContext, newIdToken, configId) {\n    const {\n      useRefreshToken,\n      disableRefreshIdTokenAuthTimeValidation\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!useRefreshToken) {\n      return true;\n    }\n\n    if (!callbackContext.existingIdToken) {\n      return true;\n    }\n\n    const decodedIdToken = this.tokenHelperService.getPayloadFromToken(callbackContext.existingIdToken, false, configId); // Upon successful validation of the Refresh Token, the response body is the Token Response of Section 3.1.3.3\n    // except that it might not contain an id_token.\n    // If an ID Token is returned as a result of a token refresh request, the following requirements apply:\n    // its iss Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\n\n    if (decodedIdToken.iss !== newIdToken.iss) {\n      this.loggerService.logDebug(configId, `iss do not match: ${decodedIdToken.iss} ${newIdToken.iss}`);\n      return false;\n    } // its azp Claim Value MUST be the same as in the ID Token issued when the original authentication occurred;\n    //   if no azp Claim was present in the original ID Token, one MUST NOT be present in the new ID Token, and\n    // otherwise, the same rules apply as apply when issuing an ID Token at the time of the original authentication.\n\n\n    if (decodedIdToken.azp !== newIdToken.azp) {\n      this.loggerService.logDebug(configId, `azp do not match: ${decodedIdToken.azp} ${newIdToken.azp}`);\n      return false;\n    } // its sub Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\n\n\n    if (decodedIdToken.sub !== newIdToken.sub) {\n      this.loggerService.logDebug(configId, `sub do not match: ${decodedIdToken.sub} ${newIdToken.sub}`);\n      return false;\n    } // its aud Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\n\n\n    if (!this.equalityService.isStringEqualOrNonOrderedArrayEqual(decodedIdToken === null || decodedIdToken === void 0 ? void 0 : decodedIdToken.aud, newIdToken === null || newIdToken === void 0 ? void 0 : newIdToken.aud)) {\n      this.loggerService.logDebug(configId, `aud in new id_token is not valid: '${decodedIdToken === null || decodedIdToken === void 0 ? void 0 : decodedIdToken.aud}' '${newIdToken.aud}'`);\n      return false;\n    }\n\n    if (disableRefreshIdTokenAuthTimeValidation) {\n      return true;\n    } // its iat Claim MUST represent the time that the new ID Token is issued,\n    // if the ID Token contains an auth_time Claim, its value MUST represent the time of the original authentication\n    // - not the time that the new ID token is issued,\n\n\n    if (decodedIdToken.auth_time !== newIdToken.auth_time) {\n      this.loggerService.logDebug(configId, `auth_time do not match: ${decodedIdToken.auth_time} ${newIdToken.auth_time}`);\n      return false;\n    }\n\n    return true;\n  }\n\n  handleSuccessfulValidation(configId) {\n    const {\n      autoCleanStateAfterAuthentication\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    this.storagePersistenceService.write('authNonce', null, configId);\n\n    if (autoCleanStateAfterAuthentication) {\n      this.storagePersistenceService.write('authStateControl', '', configId);\n    }\n\n    this.loggerService.logDebug(configId, 'authCallback token(s) validated, continue');\n  }\n\n  handleUnsuccessfulValidation(configId) {\n    const {\n      autoCleanStateAfterAuthentication\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    this.storagePersistenceService.write('authNonce', null, configId);\n\n    if (autoCleanStateAfterAuthentication) {\n      this.storagePersistenceService.write('authStateControl', '', configId);\n    }\n\n    this.loggerService.logDebug(configId, 'authCallback token(s) invalid');\n  }\n\n}\n\nStateValidationService.ɵfac = function StateValidationService_Factory(t) {\n  return new (t || StateValidationService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(TokenValidationService), i0.ɵɵinject(TokenHelperService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(EqualityService), i0.ɵɵinject(FlowHelper));\n};\n\nStateValidationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StateValidationService,\n  factory: StateValidationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StateValidationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: TokenValidationService\n    }, {\n      type: TokenHelperService\n    }, {\n      type: LoggerService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: EqualityService\n    }, {\n      type: FlowHelper\n    }];\n  }, null);\n})();\n\nclass StateValidationCallbackHandlerService {\n  constructor(loggerService, stateValidationService, authStateService, resetAuthDataService, doc) {\n    this.loggerService = loggerService;\n    this.stateValidationService = stateValidationService;\n    this.authStateService = authStateService;\n    this.resetAuthDataService = resetAuthDataService;\n    this.doc = doc;\n  } // STEP 4 All flows\n\n\n  callbackStateValidation(callbackContext, configId) {\n    const validationResult = this.stateValidationService.getValidatedStateResult(callbackContext, configId);\n    callbackContext.validationResult = validationResult;\n\n    if (validationResult.authResponseIsValid) {\n      this.authStateService.setAuthorizationData(validationResult.accessToken, callbackContext.authResult, configId);\n      return of(callbackContext);\n    } else {\n      const errorMessage = `authorizedCallback, token(s) validation failed, resetting. Hash: ${this.doc.location.hash}`;\n      this.loggerService.logWarning(configId, errorMessage);\n      this.resetAuthDataService.resetAuthorizationData(configId);\n      this.publishUnauthorizedState(callbackContext.validationResult, callbackContext.isRenewProcess);\n      return throwError(errorMessage);\n    }\n  }\n\n  publishUnauthorizedState(stateValidationResult, isRenewProcess) {\n    this.authStateService.updateAndPublishAuthState({\n      isAuthenticated: false,\n      validationResult: stateValidationResult.state,\n      isRenewProcess\n    });\n  }\n\n}\n\nStateValidationCallbackHandlerService.ɵfac = function StateValidationCallbackHandlerService_Factory(t) {\n  return new (t || StateValidationCallbackHandlerService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(StateValidationService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(DOCUMENT));\n};\n\nStateValidationCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StateValidationCallbackHandlerService,\n  factory: StateValidationCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StateValidationCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: StateValidationService\n    }, {\n      type: AuthStateService\n    }, {\n      type: ResetAuthDataService\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nclass RefreshSessionCallbackHandlerService {\n  constructor(loggerService, authStateService, flowsDataService) {\n    this.loggerService = loggerService;\n    this.authStateService = authStateService;\n    this.flowsDataService = flowsDataService;\n  } // STEP 1 Refresh session\n\n\n  refreshSessionWithRefreshTokens(configId) {\n    const stateData = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\n    this.loggerService.logDebug(configId, 'RefreshSession created. Adding myautostate: ' + stateData);\n    const refreshToken = this.authStateService.getRefreshToken(configId);\n    const idToken = this.authStateService.getIdToken(configId);\n\n    if (refreshToken) {\n      const callbackContext = {\n        code: null,\n        refreshToken,\n        state: stateData,\n        sessionState: null,\n        authResult: null,\n        isRenewProcess: true,\n        jwtKeys: null,\n        validationResult: null,\n        existingIdToken: idToken\n      };\n      this.loggerService.logDebug(configId, 'found refresh code, obtaining new credentials with refresh code'); // Nonce is not used with refresh tokens; but Key cloak may send it anyway\n\n      this.flowsDataService.setNonce(TokenValidationService.refreshTokenNoncePlaceholder, configId);\n      return of(callbackContext);\n    } else {\n      const errorMessage = 'no refresh token found, please login';\n      this.loggerService.logError(configId, errorMessage);\n      return throwError(errorMessage);\n    }\n  }\n\n}\n\nRefreshSessionCallbackHandlerService.ɵfac = function RefreshSessionCallbackHandlerService_Factory(t) {\n  return new (t || RefreshSessionCallbackHandlerService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService));\n};\n\nRefreshSessionCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RefreshSessionCallbackHandlerService,\n  factory: RefreshSessionCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RefreshSessionCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: AuthStateService\n    }, {\n      type: FlowsDataService\n    }];\n  }, null);\n})();\n\nclass RefreshTokenCallbackHandlerService {\n  constructor(urlService, loggerService, configurationProvider, dataService, storagePersistenceService) {\n    this.urlService = urlService;\n    this.loggerService = loggerService;\n    this.configurationProvider = configurationProvider;\n    this.dataService = dataService;\n    this.storagePersistenceService = storagePersistenceService;\n  } // STEP 2 Refresh Token\n\n\n  refreshTokensRequestTokens(callbackContext, configId, customParamsRefresh) {\n    let headers = new HttpHeaders();\n    headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n    const authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n    const tokenEndpoint = authWellknownEndpoints === null || authWellknownEndpoints === void 0 ? void 0 : authWellknownEndpoints.tokenEndpoint;\n\n    if (!tokenEndpoint) {\n      return throwError('Token Endpoint not defined');\n    }\n\n    const data = this.urlService.createBodyForCodeFlowRefreshTokensRequest(callbackContext.refreshToken, configId, customParamsRefresh);\n    return this.dataService.post(tokenEndpoint, data, configId, headers).pipe(switchMap(response => {\n      this.loggerService.logDebug(configId, 'token refresh response: ', response);\n      let authResult = new Object();\n      authResult = response;\n      authResult.state = callbackContext.state;\n      callbackContext.authResult = authResult;\n      return of(callbackContext);\n    }), retryWhen(error => this.handleRefreshRetry(error, configId)), catchError(error => {\n      const {\n        authority\n      } = this.configurationProvider.getOpenIDConfiguration(configId);\n      const errorMessage = `OidcService code request ${authority}`;\n      this.loggerService.logError(configId, errorMessage, error);\n      return throwError(errorMessage);\n    }));\n  }\n\n  handleRefreshRetry(errors, configId) {\n    return errors.pipe(mergeMap(error => {\n      // retry token refresh if there is no internet connection\n      if (error && error instanceof HttpErrorResponse && error.error instanceof ProgressEvent && error.error.type === 'error') {\n        const {\n          authority,\n          refreshTokenRetryInSeconds\n        } = this.configurationProvider.getOpenIDConfiguration(configId);\n        const errorMessage = `OidcService code request ${authority} - no internet connection`;\n        this.loggerService.logWarning(configId, errorMessage, error);\n        return timer(refreshTokenRetryInSeconds * 1000);\n      }\n\n      return throwError(error);\n    }));\n  }\n\n}\n\nRefreshTokenCallbackHandlerService.ɵfac = function RefreshTokenCallbackHandlerService_Factory(t) {\n  return new (t || RefreshTokenCallbackHandlerService)(i0.ɵɵinject(UrlService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(DataService), i0.ɵɵinject(StoragePersistenceService));\n};\n\nRefreshTokenCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RefreshTokenCallbackHandlerService,\n  factory: RefreshTokenCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RefreshTokenCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: UrlService\n    }, {\n      type: LoggerService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: DataService\n    }, {\n      type: StoragePersistenceService\n    }];\n  }, null);\n})();\n\nclass FlowsService {\n  constructor(codeFlowCallbackHandlerService, implicitFlowCallbackHandlerService, historyJwtKeysCallbackHandlerService, userHandlerService, stateValidationCallbackHandlerService, refreshSessionCallbackHandlerService, refreshTokenCallbackHandlerService) {\n    this.codeFlowCallbackHandlerService = codeFlowCallbackHandlerService;\n    this.implicitFlowCallbackHandlerService = implicitFlowCallbackHandlerService;\n    this.historyJwtKeysCallbackHandlerService = historyJwtKeysCallbackHandlerService;\n    this.userHandlerService = userHandlerService;\n    this.stateValidationCallbackHandlerService = stateValidationCallbackHandlerService;\n    this.refreshSessionCallbackHandlerService = refreshSessionCallbackHandlerService;\n    this.refreshTokenCallbackHandlerService = refreshTokenCallbackHandlerService;\n  }\n\n  processCodeFlowCallback(urlToCheck, configId) {\n    return this.codeFlowCallbackHandlerService.codeFlowCallback(urlToCheck, configId).pipe(concatMap(callbackContext => this.codeFlowCallbackHandlerService.codeFlowCodeRequest(callbackContext, configId)), concatMap(callbackContext => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, configId)), concatMap(callbackContext => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, configId)), concatMap(callbackContext => this.userHandlerService.callbackUser(callbackContext, configId)));\n  }\n\n  processSilentRenewCodeFlowCallback(firstContext, configId) {\n    return this.codeFlowCallbackHandlerService.codeFlowCodeRequest(firstContext, configId).pipe(concatMap(callbackContext => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, configId)), concatMap(callbackContext => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, configId)), concatMap(callbackContext => this.userHandlerService.callbackUser(callbackContext, configId)));\n  }\n\n  processImplicitFlowCallback(configId, hash) {\n    return this.implicitFlowCallbackHandlerService.implicitFlowCallback(configId, hash).pipe(concatMap(callbackContext => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, configId)), concatMap(callbackContext => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, configId)), concatMap(callbackContext => this.userHandlerService.callbackUser(callbackContext, configId)));\n  }\n\n  processRefreshToken(configId, customParamsRefresh) {\n    return this.refreshSessionCallbackHandlerService.refreshSessionWithRefreshTokens(configId).pipe(concatMap(callbackContext => this.refreshTokenCallbackHandlerService.refreshTokensRequestTokens(callbackContext, configId, customParamsRefresh)), concatMap(callbackContext => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, configId)), concatMap(callbackContext => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, configId)), concatMap(callbackContext => this.userHandlerService.callbackUser(callbackContext, configId)));\n  }\n\n}\n\nFlowsService.ɵfac = function FlowsService_Factory(t) {\n  return new (t || FlowsService)(i0.ɵɵinject(CodeFlowCallbackHandlerService), i0.ɵɵinject(ImplicitFlowCallbackHandlerService), i0.ɵɵinject(HistoryJwtKeysCallbackHandlerService), i0.ɵɵinject(UserCallbackHandlerService), i0.ɵɵinject(StateValidationCallbackHandlerService), i0.ɵɵinject(RefreshSessionCallbackHandlerService), i0.ɵɵinject(RefreshTokenCallbackHandlerService));\n};\n\nFlowsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: FlowsService,\n  factory: FlowsService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(FlowsService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: CodeFlowCallbackHandlerService\n    }, {\n      type: ImplicitFlowCallbackHandlerService\n    }, {\n      type: HistoryJwtKeysCallbackHandlerService\n    }, {\n      type: UserCallbackHandlerService\n    }, {\n      type: StateValidationCallbackHandlerService\n    }, {\n      type: RefreshSessionCallbackHandlerService\n    }, {\n      type: RefreshTokenCallbackHandlerService\n    }];\n  }, null);\n})();\n\nclass IntervalService {\n  constructor(zone) {\n    this.zone = zone;\n    this.runTokenValidationRunning = null;\n  }\n\n  stopPeriodicTokenCheck() {\n    if (this.runTokenValidationRunning) {\n      this.runTokenValidationRunning.unsubscribe();\n      this.runTokenValidationRunning = null;\n    }\n  }\n\n  startPeriodicTokenCheck(repeatAfterSeconds) {\n    const millisecondsDelayBetweenTokenCheck = repeatAfterSeconds * 1000;\n    return new Observable(subscriber => {\n      let intervalId;\n      this.zone.runOutsideAngular(() => {\n        intervalId = setInterval(() => this.zone.run(() => subscriber.next()), millisecondsDelayBetweenTokenCheck);\n      });\n      return () => {\n        clearInterval(intervalId);\n      };\n    });\n  }\n\n}\n\nIntervalService.ɵfac = function IntervalService_Factory(t) {\n  return new (t || IntervalService)(i0.ɵɵinject(i0.NgZone));\n};\n\nIntervalService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: IntervalService,\n  factory: IntervalService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(IntervalService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: i0.NgZone\n    }];\n  }, null);\n})();\n\nclass ImplicitFlowCallbackService {\n  constructor(flowsService, configurationProvider, router, flowsDataService, intervalService) {\n    this.flowsService = flowsService;\n    this.configurationProvider = configurationProvider;\n    this.router = router;\n    this.flowsDataService = flowsDataService;\n    this.intervalService = intervalService;\n  }\n\n  authenticatedImplicitFlowCallback(configId, hash) {\n    const isRenewProcess = this.flowsDataService.isSilentRenewRunning(configId);\n    const {\n      triggerAuthorizationResultEvent,\n      postLoginRoute,\n      unauthorizedRoute\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    return this.flowsService.processImplicitFlowCallback(configId, hash).pipe(tap(callbackContext => {\n      if (!triggerAuthorizationResultEvent && !callbackContext.isRenewProcess) {\n        this.router.navigateByUrl(postLoginRoute);\n      }\n    }), catchError(error => {\n      this.flowsDataService.resetSilentRenewRunning(configId);\n      this.intervalService.stopPeriodicTokenCheck();\n\n      if (!triggerAuthorizationResultEvent && !isRenewProcess) {\n        this.router.navigateByUrl(unauthorizedRoute);\n      }\n\n      return throwError(error);\n    }));\n  }\n\n}\n\nImplicitFlowCallbackService.ɵfac = function ImplicitFlowCallbackService_Factory(t) {\n  return new (t || ImplicitFlowCallbackService)(i0.ɵɵinject(FlowsService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(i2.Router), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(IntervalService));\n};\n\nImplicitFlowCallbackService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ImplicitFlowCallbackService,\n  factory: ImplicitFlowCallbackService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ImplicitFlowCallbackService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: FlowsService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: i2.Router\n    }, {\n      type: FlowsDataService\n    }, {\n      type: IntervalService\n    }];\n  }, null);\n})();\n\nclass IFrameService {\n  constructor(doc, loggerService) {\n    this.doc = doc;\n    this.loggerService = loggerService;\n  }\n\n  getExistingIFrame(identifier) {\n    const iFrameOnParent = this.getIFrameFromParentWindow(identifier);\n\n    if (this.isIFrameElement(iFrameOnParent)) {\n      return iFrameOnParent;\n    }\n\n    const iFrameOnSelf = this.getIFrameFromWindow(identifier);\n\n    if (this.isIFrameElement(iFrameOnSelf)) {\n      return iFrameOnSelf;\n    }\n\n    return null;\n  }\n\n  addIFrameToWindowBody(identifier, configId) {\n    const sessionIframe = this.doc.createElement('iframe');\n    sessionIframe.id = identifier;\n    sessionIframe.title = identifier;\n    this.loggerService.logDebug(configId, sessionIframe);\n    sessionIframe.style.display = 'none';\n    this.doc.body.appendChild(sessionIframe);\n    return sessionIframe;\n  }\n\n  getIFrameFromParentWindow(identifier) {\n    try {\n      const iFrameElement = this.doc.defaultView.parent.document.getElementById(identifier);\n\n      if (this.isIFrameElement(iFrameElement)) {\n        return iFrameElement;\n      }\n\n      return null;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  getIFrameFromWindow(identifier) {\n    const iFrameElement = this.doc.getElementById(identifier);\n\n    if (this.isIFrameElement(iFrameElement)) {\n      return iFrameElement;\n    }\n\n    return null;\n  }\n\n  isIFrameElement(element) {\n    return !!element && element instanceof HTMLIFrameElement;\n  }\n\n}\n\nIFrameService.ɵfac = function IFrameService_Factory(t) {\n  return new (t || IFrameService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(LoggerService));\n};\n\nIFrameService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: IFrameService,\n  factory: IFrameService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(IFrameService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: LoggerService\n    }];\n  }, null);\n})();\n\nconst IFRAME_FOR_CHECK_SESSION_IDENTIFIER = 'myiFrameForCheckSession'; // http://openid.net/specs/openid-connect-session-1_0-ID4.html\n\nclass CheckSessionService {\n  constructor(storagePersistenceService, loggerService, iFrameService, eventService, configurationProvider, zone) {\n    this.storagePersistenceService = storagePersistenceService;\n    this.loggerService = loggerService;\n    this.iFrameService = iFrameService;\n    this.eventService = eventService;\n    this.configurationProvider = configurationProvider;\n    this.zone = zone;\n    this.checkSessionReceived = false;\n    this.lastIFrameRefresh = 0;\n    this.outstandingMessages = 0;\n    this.heartBeatInterval = 3000;\n    this.iframeRefreshInterval = 60000;\n    this.checkSessionChangedInternal$ = new BehaviorSubject(false);\n  }\n\n  get checkSessionChanged$() {\n    return this.checkSessionChangedInternal$.asObservable();\n  }\n\n  isCheckSessionConfigured(configId) {\n    const {\n      startCheckSession\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    return startCheckSession;\n  }\n\n  start(configId) {\n    if (!!this.scheduledHeartBeatRunning) {\n      return;\n    }\n\n    const {\n      clientId\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    this.pollServerSession(clientId, configId);\n  }\n\n  stop() {\n    if (!this.scheduledHeartBeatRunning) {\n      return;\n    }\n\n    this.clearScheduledHeartBeat();\n    this.checkSessionReceived = false;\n  }\n\n  serverStateChanged(configId) {\n    const {\n      startCheckSession\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    return startCheckSession && this.checkSessionReceived;\n  }\n\n  getExistingIframe() {\n    return this.iFrameService.getExistingIFrame(IFRAME_FOR_CHECK_SESSION_IDENTIFIER);\n  }\n\n  init(configId) {\n    if (this.lastIFrameRefresh + this.iframeRefreshInterval > Date.now()) {\n      return of(undefined);\n    }\n\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n    if (!authWellKnownEndPoints) {\n      this.loggerService.logWarning(configId, 'CheckSession - init check session: authWellKnownEndpoints is undefined. Returning.');\n      return of();\n    }\n\n    const existingIframe = this.getOrCreateIframe(configId);\n    const checkSessionIframe = authWellKnownEndPoints.checkSessionIframe;\n\n    if (checkSessionIframe) {\n      existingIframe.contentWindow.location.replace(checkSessionIframe);\n    } else {\n      this.loggerService.logWarning(configId, 'CheckSession - init check session: checkSessionIframe is not configured to run');\n    }\n\n    return new Observable(observer => {\n      existingIframe.onload = () => {\n        this.lastIFrameRefresh = Date.now();\n        observer.next();\n        observer.complete();\n      };\n    });\n  }\n\n  pollServerSession(clientId, configId) {\n    this.outstandingMessages = 0;\n\n    const pollServerSessionRecur = () => {\n      this.init(configId).pipe(take(1)).subscribe(() => {\n        var _a;\n\n        const existingIframe = this.getExistingIframe();\n\n        if (existingIframe && clientId) {\n          this.loggerService.logDebug(configId, `CheckSession - clientId : '${clientId}' - existingIframe: '${existingIframe}'`);\n          const sessionState = this.storagePersistenceService.read('session_state', configId);\n          const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n          if (sessionState && (authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.checkSessionIframe)) {\n            const iframeOrigin = (_a = new URL(authWellKnownEndPoints.checkSessionIframe)) === null || _a === void 0 ? void 0 : _a.origin;\n            this.outstandingMessages++;\n            existingIframe.contentWindow.postMessage(clientId + ' ' + sessionState, iframeOrigin);\n          } else {\n            this.loggerService.logDebug(configId, `CheckSession - session_state is '${sessionState}' - AuthWellKnownEndPoints is '${JSON.stringify(authWellKnownEndPoints, null, 2)}'`);\n            this.checkSessionChangedInternal$.next(true);\n          }\n        } else {\n          this.loggerService.logWarning(configId, `CheckSession - OidcSecurityCheckSession pollServerSession checkSession IFrame does not exist:\n               clientId : '${clientId}' - existingIframe: '${existingIframe}'`);\n        } // after sending three messages with no response, fail.\n\n\n        if (this.outstandingMessages > 3) {\n          this.loggerService.logError(configId, `CheckSession - OidcSecurityCheckSession not receiving check session response messages.\n                            Outstanding messages: '${this.outstandingMessages}'. Server unreachable?`);\n        }\n\n        this.zone.runOutsideAngular(() => {\n          this.scheduledHeartBeatRunning = setTimeout(() => this.zone.run(pollServerSessionRecur), this.heartBeatInterval);\n        });\n      });\n    };\n\n    pollServerSessionRecur();\n  }\n\n  clearScheduledHeartBeat() {\n    clearTimeout(this.scheduledHeartBeatRunning);\n    this.scheduledHeartBeatRunning = null;\n  }\n\n  messageHandler(configId, e) {\n    var _a;\n\n    const existingIFrame = this.getExistingIframe();\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n    const startsWith = !!((_a = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.checkSessionIframe) === null || _a === void 0 ? void 0 : _a.startsWith(e.origin));\n    this.outstandingMessages = 0;\n\n    if (existingIFrame && startsWith && e.source === existingIFrame.contentWindow) {\n      if (e.data === 'error') {\n        this.loggerService.logWarning(configId, 'CheckSession - error from check session messageHandler');\n      } else if (e.data === 'changed') {\n        this.loggerService.logDebug(configId, `CheckSession - ${e} from check session messageHandler`);\n        this.checkSessionReceived = true;\n        this.eventService.fireEvent(EventTypes.CheckSessionReceived, e.data);\n        this.checkSessionChangedInternal$.next(true);\n      } else {\n        this.eventService.fireEvent(EventTypes.CheckSessionReceived, e.data);\n        this.loggerService.logDebug(configId, `CheckSession - ${e.data} from check session messageHandler`);\n      }\n    }\n  }\n\n  bindMessageEventToIframe(configId) {\n    const iframeMessageEvent = this.messageHandler.bind(this, configId);\n    window.addEventListener('message', iframeMessageEvent, false);\n  }\n\n  getOrCreateIframe(configId) {\n    const existingIframe = this.getExistingIframe();\n\n    if (!existingIframe) {\n      const frame = this.iFrameService.addIFrameToWindowBody(IFRAME_FOR_CHECK_SESSION_IDENTIFIER, configId);\n      this.bindMessageEventToIframe(configId);\n      return frame;\n    }\n\n    return existingIframe;\n  }\n\n}\n\nCheckSessionService.ɵfac = function CheckSessionService_Factory(t) {\n  return new (t || CheckSessionService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(IFrameService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(i0.NgZone));\n};\n\nCheckSessionService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CheckSessionService,\n  factory: CheckSessionService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CheckSessionService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: LoggerService\n    }, {\n      type: IFrameService\n    }, {\n      type: PublicEventsService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: i0.NgZone\n    }];\n  }, null);\n})();\n\nclass CurrentUrlService {\n  constructor(doc) {\n    this.doc = doc;\n  }\n\n  getStateParamFromCurrentUrl() {\n    const currentUrl = this.getCurrentUrl();\n    const parsedUrl = new URL(currentUrl);\n    const urlParams = new URLSearchParams(parsedUrl.search);\n    const stateFromUrl = urlParams.get('state');\n    return stateFromUrl;\n  }\n\n  currentUrlHasStateParam() {\n    return !!this.getStateParamFromCurrentUrl();\n  }\n\n  getCurrentUrl() {\n    return this.doc.defaultView.location.toString();\n  }\n\n}\n\nCurrentUrlService.ɵfac = function CurrentUrlService_Factory(t) {\n  return new (t || CurrentUrlService)(i0.ɵɵinject(DOCUMENT));\n};\n\nCurrentUrlService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CurrentUrlService,\n  factory: CurrentUrlService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CurrentUrlService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nconst IFRAME_FOR_SILENT_RENEW_IDENTIFIER = 'myiFrameForSilentRenew';\n\nclass SilentRenewService {\n  constructor(configurationProvider, iFrameService, flowsService, resetAuthDataService, flowsDataService, authStateService, loggerService, flowHelper, implicitFlowCallbackService, intervalService) {\n    this.configurationProvider = configurationProvider;\n    this.iFrameService = iFrameService;\n    this.flowsService = flowsService;\n    this.resetAuthDataService = resetAuthDataService;\n    this.flowsDataService = flowsDataService;\n    this.authStateService = authStateService;\n    this.loggerService = loggerService;\n    this.flowHelper = flowHelper;\n    this.implicitFlowCallbackService = implicitFlowCallbackService;\n    this.intervalService = intervalService;\n    this.refreshSessionWithIFrameCompletedInternal$ = new Subject();\n  }\n\n  get refreshSessionWithIFrameCompleted$() {\n    return this.refreshSessionWithIFrameCompletedInternal$.asObservable();\n  }\n\n  getOrCreateIframe(configId) {\n    const existingIframe = this.getExistingIframe();\n\n    if (!existingIframe) {\n      return this.iFrameService.addIFrameToWindowBody(IFRAME_FOR_SILENT_RENEW_IDENTIFIER, configId);\n    }\n\n    return existingIframe;\n  }\n\n  isSilentRenewConfigured(configId) {\n    const {\n      useRefreshToken,\n      silentRenew\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    return !useRefreshToken && silentRenew;\n  }\n\n  codeFlowCallbackSilentRenewIframe(urlParts, configId) {\n    const params = new HttpParams({\n      fromString: urlParts[1]\n    });\n    const error = params.get('error');\n\n    if (error) {\n      this.authStateService.updateAndPublishAuthState({\n        isAuthenticated: false,\n        validationResult: ValidationResult.LoginRequired,\n        isRenewProcess: true\n      });\n      this.resetAuthDataService.resetAuthorizationData(configId);\n      this.flowsDataService.setNonce('', configId);\n      this.intervalService.stopPeriodicTokenCheck();\n      return throwError(error);\n    }\n\n    const code = params.get('code');\n    const state = params.get('state');\n    const sessionState = params.get('session_state');\n    const callbackContext = {\n      code,\n      refreshToken: null,\n      state,\n      sessionState,\n      authResult: null,\n      isRenewProcess: true,\n      jwtKeys: null,\n      validationResult: null,\n      existingIdToken: null\n    };\n    return this.flowsService.processSilentRenewCodeFlowCallback(callbackContext, configId).pipe(catchError(errorFromFlow => {\n      this.intervalService.stopPeriodicTokenCheck();\n      this.resetAuthDataService.resetAuthorizationData(configId);\n      return throwError(errorFromFlow);\n    }));\n  }\n\n  silentRenewEventHandler(e, configId) {\n    this.loggerService.logDebug(configId, 'silentRenewEventHandler');\n\n    if (!e.detail) {\n      return;\n    }\n\n    let callback$ = of(null);\n    const isCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(configId);\n\n    if (isCodeFlow) {\n      const urlParts = e.detail.toString().split('?');\n      callback$ = this.codeFlowCallbackSilentRenewIframe(urlParts, configId);\n    } else {\n      callback$ = this.implicitFlowCallbackService.authenticatedImplicitFlowCallback(configId, e.detail);\n    }\n\n    callback$.subscribe(callbackContext => {\n      this.refreshSessionWithIFrameCompletedInternal$.next(callbackContext);\n      this.flowsDataService.resetSilentRenewRunning(configId);\n    }, err => {\n      this.loggerService.logError(configId, 'Error: ' + err);\n      this.refreshSessionWithIFrameCompletedInternal$.next(null);\n      this.flowsDataService.resetSilentRenewRunning(configId);\n    });\n  }\n\n  getExistingIframe() {\n    return this.iFrameService.getExistingIFrame(IFRAME_FOR_SILENT_RENEW_IDENTIFIER);\n  }\n\n}\n\nSilentRenewService.ɵfac = function SilentRenewService_Factory(t) {\n  return new (t || SilentRenewService)(i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(IFrameService), i0.ɵɵinject(FlowsService), i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(FlowHelper), i0.ɵɵinject(ImplicitFlowCallbackService), i0.ɵɵinject(IntervalService));\n};\n\nSilentRenewService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: SilentRenewService,\n  factory: SilentRenewService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SilentRenewService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ConfigurationProvider\n    }, {\n      type: IFrameService\n    }, {\n      type: FlowsService\n    }, {\n      type: ResetAuthDataService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: AuthStateService\n    }, {\n      type: LoggerService\n    }, {\n      type: FlowHelper\n    }, {\n      type: ImplicitFlowCallbackService\n    }, {\n      type: IntervalService\n    }];\n  }, null);\n})();\n\nclass CodeFlowCallbackService {\n  constructor(flowsService, flowsDataService, intervalService, configurationProvider, router) {\n    this.flowsService = flowsService;\n    this.flowsDataService = flowsDataService;\n    this.intervalService = intervalService;\n    this.configurationProvider = configurationProvider;\n    this.router = router;\n  }\n\n  authenticatedCallbackWithCode(urlToCheck, configId) {\n    const isRenewProcess = this.flowsDataService.isSilentRenewRunning(configId);\n    const {\n      triggerAuthorizationResultEvent,\n      postLoginRoute,\n      unauthorizedRoute\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    return this.flowsService.processCodeFlowCallback(urlToCheck, configId).pipe(tap(callbackContext => {\n      if (!triggerAuthorizationResultEvent && !callbackContext.isRenewProcess) {\n        this.router.navigateByUrl(postLoginRoute);\n      }\n    }), catchError(error => {\n      this.flowsDataService.resetSilentRenewRunning(configId);\n      this.intervalService.stopPeriodicTokenCheck();\n\n      if (!triggerAuthorizationResultEvent && !isRenewProcess) {\n        this.router.navigateByUrl(unauthorizedRoute);\n      }\n\n      return throwError(error);\n    }));\n  }\n\n}\n\nCodeFlowCallbackService.ɵfac = function CodeFlowCallbackService_Factory(t) {\n  return new (t || CodeFlowCallbackService)(i0.ɵɵinject(FlowsService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(IntervalService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(i2.Router));\n};\n\nCodeFlowCallbackService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CodeFlowCallbackService,\n  factory: CodeFlowCallbackService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CodeFlowCallbackService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: FlowsService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: IntervalService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: i2.Router\n    }];\n  }, null);\n})();\n\nclass CallbackService {\n  constructor(urlService, flowHelper, implicitFlowCallbackService, codeFlowCallbackService) {\n    this.urlService = urlService;\n    this.flowHelper = flowHelper;\n    this.implicitFlowCallbackService = implicitFlowCallbackService;\n    this.codeFlowCallbackService = codeFlowCallbackService;\n    this.stsCallbackInternal$ = new Subject();\n  }\n\n  get stsCallback$() {\n    return this.stsCallbackInternal$.asObservable();\n  }\n\n  isCallback(currentUrl) {\n    return this.urlService.isCallbackFromSts(currentUrl);\n  }\n\n  handleCallbackAndFireEvents(currentCallbackUrl, configId) {\n    let callback$;\n\n    if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\n      callback$ = this.codeFlowCallbackService.authenticatedCallbackWithCode(currentCallbackUrl, configId);\n    } else if (this.flowHelper.isCurrentFlowAnyImplicitFlow(configId)) {\n      callback$ = this.implicitFlowCallbackService.authenticatedImplicitFlowCallback(configId);\n    }\n\n    return callback$.pipe(tap(() => this.stsCallbackInternal$.next()));\n  }\n\n}\n\nCallbackService.ɵfac = function CallbackService_Factory(t) {\n  return new (t || CallbackService)(i0.ɵɵinject(UrlService), i0.ɵɵinject(FlowHelper), i0.ɵɵinject(ImplicitFlowCallbackService), i0.ɵɵinject(CodeFlowCallbackService));\n};\n\nCallbackService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CallbackService,\n  factory: CallbackService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CallbackService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: UrlService\n    }, {\n      type: FlowHelper\n    }, {\n      type: ImplicitFlowCallbackService\n    }, {\n      type: CodeFlowCallbackService\n    }];\n  }, null);\n})();\n\nconst WELL_KNOWN_SUFFIX = `/.well-known/openid-configuration`;\n\nclass AuthWellKnownDataService {\n  constructor(http) {\n    this.http = http;\n  }\n\n  getWellKnownEndPointsFromUrl(authWellknownEndpoint, configId) {\n    return this.getWellKnownDocument(authWellknownEndpoint, configId).pipe(map(wellKnownEndpoints => ({\n      issuer: wellKnownEndpoints.issuer,\n      jwksUri: wellKnownEndpoints.jwks_uri,\n      authorizationEndpoint: wellKnownEndpoints.authorization_endpoint,\n      tokenEndpoint: wellKnownEndpoints.token_endpoint,\n      userInfoEndpoint: wellKnownEndpoints.userinfo_endpoint,\n      endSessionEndpoint: wellKnownEndpoints.end_session_endpoint,\n      checkSessionIframe: wellKnownEndpoints.check_session_iframe,\n      revocationEndpoint: wellKnownEndpoints.revocation_endpoint,\n      introspectionEndpoint: wellKnownEndpoints.introspection_endpoint,\n      parEndpoint: wellKnownEndpoints.pushed_authorization_request_endpoint\n    })));\n  }\n\n  getWellKnownDocument(wellKnownEndpoint, configId) {\n    let url = wellKnownEndpoint;\n\n    if (!wellKnownEndpoint.includes(WELL_KNOWN_SUFFIX)) {\n      url = `${wellKnownEndpoint}${WELL_KNOWN_SUFFIX}`;\n    }\n\n    return this.http.get(url, configId).pipe(retry(2));\n  }\n\n}\n\nAuthWellKnownDataService.ɵfac = function AuthWellKnownDataService_Factory(t) {\n  return new (t || AuthWellKnownDataService)(i0.ɵɵinject(DataService));\n};\n\nAuthWellKnownDataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AuthWellKnownDataService,\n  factory: AuthWellKnownDataService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthWellKnownDataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: DataService\n    }];\n  }, null);\n})();\n\nclass AuthWellKnownService {\n  constructor(publicEventsService, dataService, storagePersistenceService) {\n    this.publicEventsService = publicEventsService;\n    this.dataService = dataService;\n    this.storagePersistenceService = storagePersistenceService;\n  }\n\n  getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId) {\n    const alreadySavedWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n    if (!!alreadySavedWellKnownEndpoints) {\n      return of(alreadySavedWellKnownEndpoints);\n    }\n\n    return this.getWellKnownEndPointsFromUrl(authWellknownEndpointUrl, configId).pipe(tap(mappedWellKnownEndpoints => this.storeWellKnownEndpoints(configId, mappedWellKnownEndpoints)), catchError(error => {\n      this.publicEventsService.fireEvent(EventTypes.ConfigLoadingFailed, null);\n      return throwError(error);\n    }));\n  }\n\n  storeWellKnownEndpoints(configId, mappedWellKnownEndpoints) {\n    this.storagePersistenceService.write('authWellKnownEndPoints', mappedWellKnownEndpoints, configId);\n  }\n\n  getWellKnownEndPointsFromUrl(authWellknownEndpointUrl, configId) {\n    return this.dataService.getWellKnownEndPointsFromUrl(authWellknownEndpointUrl, configId);\n  }\n\n}\n\nAuthWellKnownService.ɵfac = function AuthWellKnownService_Factory(t) {\n  return new (t || AuthWellKnownService)(i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(AuthWellKnownDataService), i0.ɵɵinject(StoragePersistenceService));\n};\n\nAuthWellKnownService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AuthWellKnownService,\n  factory: AuthWellKnownService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthWellKnownService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: PublicEventsService\n    }, {\n      type: AuthWellKnownDataService\n    }, {\n      type: StoragePersistenceService\n    }];\n  }, null);\n})();\n\nclass RefreshSessionIframeService {\n  constructor(doc, loggerService, urlService, silentRenewService, rendererFactory) {\n    this.doc = doc;\n    this.loggerService = loggerService;\n    this.urlService = urlService;\n    this.silentRenewService = silentRenewService;\n    this.renderer = rendererFactory.createRenderer(null, null);\n  }\n\n  refreshSessionWithIframe(configId, customParams) {\n    this.loggerService.logDebug(configId, 'BEGIN refresh session Authorize Iframe renew');\n    const url = this.urlService.getRefreshSessionSilentRenewUrl(configId, customParams);\n    return this.sendAuthorizeRequestUsingSilentRenew(url, configId);\n  }\n\n  sendAuthorizeRequestUsingSilentRenew(url, configId) {\n    const sessionIframe = this.silentRenewService.getOrCreateIframe(configId);\n    this.initSilentRenewRequest(configId);\n    this.loggerService.logDebug(configId, 'sendAuthorizeRequestUsingSilentRenew for URL:' + url);\n    return new Observable(observer => {\n      const onLoadHandler = () => {\n        sessionIframe.removeEventListener('load', onLoadHandler);\n        this.loggerService.logDebug(configId, 'removed event listener from IFrame');\n        observer.next(true);\n        observer.complete();\n      };\n\n      sessionIframe.addEventListener('load', onLoadHandler);\n      sessionIframe.contentWindow.location.replace(url);\n    });\n  }\n\n  initSilentRenewRequest(configId) {\n    const instanceId = Math.random();\n    const initDestroyHandler = this.renderer.listen('window', 'oidc-silent-renew-init', e => {\n      if (e.detail !== instanceId) {\n        initDestroyHandler();\n        renewDestroyHandler();\n      }\n    });\n    const renewDestroyHandler = this.renderer.listen('window', 'oidc-silent-renew-message', e => this.silentRenewService.silentRenewEventHandler(e, configId));\n    this.doc.defaultView.dispatchEvent(new CustomEvent('oidc-silent-renew-init', {\n      detail: instanceId\n    }));\n  }\n\n}\n\nRefreshSessionIframeService.ɵfac = function RefreshSessionIframeService_Factory(t) {\n  return new (t || RefreshSessionIframeService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(LoggerService), i0.ɵɵinject(UrlService), i0.ɵɵinject(SilentRenewService), i0.ɵɵinject(i0.RendererFactory2));\n};\n\nRefreshSessionIframeService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RefreshSessionIframeService,\n  factory: RefreshSessionIframeService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RefreshSessionIframeService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: LoggerService\n    }, {\n      type: UrlService\n    }, {\n      type: SilentRenewService\n    }, {\n      type: i0.RendererFactory2\n    }];\n  }, null);\n})();\n\nclass RefreshSessionRefreshTokenService {\n  constructor(loggerService, resetAuthDataService, flowsService, intervalService) {\n    this.loggerService = loggerService;\n    this.resetAuthDataService = resetAuthDataService;\n    this.flowsService = flowsService;\n    this.intervalService = intervalService;\n  }\n\n  refreshSessionWithRefreshTokens(configId, customParamsRefresh) {\n    this.loggerService.logDebug(configId, 'BEGIN refresh session Authorize');\n    return this.flowsService.processRefreshToken(configId, customParamsRefresh).pipe(catchError(error => {\n      this.intervalService.stopPeriodicTokenCheck();\n      this.resetAuthDataService.resetAuthorizationData(configId);\n      return throwError(error);\n    }));\n  }\n\n}\n\nRefreshSessionRefreshTokenService.ɵfac = function RefreshSessionRefreshTokenService_Factory(t) {\n  return new (t || RefreshSessionRefreshTokenService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(FlowsService), i0.ɵɵinject(IntervalService));\n};\n\nRefreshSessionRefreshTokenService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RefreshSessionRefreshTokenService,\n  factory: RefreshSessionRefreshTokenService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RefreshSessionRefreshTokenService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: ResetAuthDataService\n    }, {\n      type: FlowsService\n    }, {\n      type: IntervalService\n    }];\n  }, null);\n})();\n\nconst MAX_RETRY_ATTEMPTS = 3;\n\nclass RefreshSessionService {\n  constructor(flowHelper, configurationProvider, flowsDataService, loggerService, silentRenewService, authStateService, authWellKnownService, refreshSessionIframeService, storagePersistenceService, refreshSessionRefreshTokenService, userService) {\n    this.flowHelper = flowHelper;\n    this.configurationProvider = configurationProvider;\n    this.flowsDataService = flowsDataService;\n    this.loggerService = loggerService;\n    this.silentRenewService = silentRenewService;\n    this.authStateService = authStateService;\n    this.authWellKnownService = authWellKnownService;\n    this.refreshSessionIframeService = refreshSessionIframeService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.refreshSessionRefreshTokenService = refreshSessionRefreshTokenService;\n    this.userService = userService;\n  }\n\n  userForceRefreshSession(configId, extraCustomParams) {\n    this.persistCustomParams(extraCustomParams, configId);\n    return this.forceRefreshSession(configId, extraCustomParams);\n  }\n\n  forceRefreshSession(configId, extraCustomParams) {\n    const {\n      customParamsRefreshTokenRequest\n    } = this.configurationProvider.getOpenIDConfiguration();\n    const mergedParams = Object.assign(Object.assign({}, customParamsRefreshTokenRequest), extraCustomParams);\n\n    if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(configId)) {\n      return this.startRefreshSession(configId, mergedParams).pipe(map(() => {\n        const isAuthenticated = this.authStateService.areAuthStorageTokensValid(configId);\n\n        if (isAuthenticated) {\n          return {\n            idToken: this.authStateService.getIdToken(configId),\n            accessToken: this.authStateService.getAccessToken(configId),\n            userData: this.userService.getUserDataFromStore(configId),\n            isAuthenticated,\n            configId\n          };\n        }\n\n        return null;\n      }));\n    }\n\n    const {\n      silentRenewTimeoutInSeconds\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    const timeOutTime = silentRenewTimeoutInSeconds * 1000;\n    return forkJoin([this.startRefreshSession(configId, extraCustomParams), this.silentRenewService.refreshSessionWithIFrameCompleted$.pipe(take(1))]).pipe(timeout(timeOutTime), retryWhen(this.timeoutRetryStrategy.bind(this)), map(([_, callbackContext]) => {\n      var _a, _b;\n\n      const isAuthenticated = this.authStateService.areAuthStorageTokensValid(configId);\n\n      if (isAuthenticated) {\n        return {\n          idToken: (_a = callbackContext === null || callbackContext === void 0 ? void 0 : callbackContext.authResult) === null || _a === void 0 ? void 0 : _a.id_token,\n          accessToken: (_b = callbackContext === null || callbackContext === void 0 ? void 0 : callbackContext.authResult) === null || _b === void 0 ? void 0 : _b.access_token,\n          userData: this.userService.getUserDataFromStore(configId),\n          isAuthenticated,\n          configId\n        };\n      }\n\n      return null;\n    }));\n  }\n\n  persistCustomParams(extraCustomParams, configId) {\n    const {\n      useRefreshToken\n    } = this.configurationProvider.getOpenIDConfiguration();\n\n    if (extraCustomParams) {\n      if (useRefreshToken) {\n        this.storagePersistenceService.write('storageCustomParamsRefresh', extraCustomParams, configId);\n      } else {\n        this.storagePersistenceService.write('storageCustomParamsAuthRequest', extraCustomParams, configId);\n      }\n    }\n  }\n\n  startRefreshSession(configId, extraCustomParams) {\n    const isSilentRenewRunning = this.flowsDataService.isSilentRenewRunning(configId);\n    this.loggerService.logDebug(configId, `Checking: silentRenewRunning: ${isSilentRenewRunning}`);\n    const shouldBeExecuted = !isSilentRenewRunning;\n\n    if (!shouldBeExecuted) {\n      return of(null);\n    }\n\n    const {\n      authWellknownEndpointUrl\n    } = this.configurationProvider.getOpenIDConfiguration(configId) || {};\n\n    if (!authWellknownEndpointUrl) {\n      this.loggerService.logError(configId, 'no authWellKnownEndpoint given!');\n      return of(null);\n    }\n\n    return this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).pipe(switchMap(() => {\n      this.flowsDataService.setSilentRenewRunning(configId);\n\n      if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(configId)) {\n        // Refresh Session using Refresh tokens\n        return this.refreshSessionRefreshTokenService.refreshSessionWithRefreshTokens(configId, extraCustomParams);\n      }\n\n      return this.refreshSessionIframeService.refreshSessionWithIframe(configId, extraCustomParams);\n    }));\n  }\n\n  timeoutRetryStrategy(errorAttempts, configId) {\n    return errorAttempts.pipe(mergeMap((error, index) => {\n      const scalingDuration = 1000;\n      const currentAttempt = index + 1;\n\n      if (!(error instanceof TimeoutError) || currentAttempt > MAX_RETRY_ATTEMPTS) {\n        return throwError(error);\n      }\n\n      this.loggerService.logDebug(configId, `forceRefreshSession timeout. Attempt #${currentAttempt}`);\n      this.flowsDataService.resetSilentRenewRunning(configId);\n      return timer(currentAttempt * scalingDuration);\n    }));\n  }\n\n}\n\nRefreshSessionService.ɵfac = function RefreshSessionService_Factory(t) {\n  return new (t || RefreshSessionService)(i0.ɵɵinject(FlowHelper), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(SilentRenewService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(AuthWellKnownService), i0.ɵɵinject(RefreshSessionIframeService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(RefreshSessionRefreshTokenService), i0.ɵɵinject(UserService));\n};\n\nRefreshSessionService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RefreshSessionService,\n  factory: RefreshSessionService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RefreshSessionService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: FlowHelper\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: FlowsDataService\n    }, {\n      type: LoggerService\n    }, {\n      type: SilentRenewService\n    }, {\n      type: AuthStateService\n    }, {\n      type: AuthWellKnownService\n    }, {\n      type: RefreshSessionIframeService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: RefreshSessionRefreshTokenService\n    }, {\n      type: UserService\n    }];\n  }, null);\n})();\n\nclass PeriodicallyTokenCheckService {\n  constructor(resetAuthDataService, flowHelper, configurationProvider, flowsDataService, loggerService, userService, authStateService, refreshSessionIframeService, refreshSessionRefreshTokenService, intervalService, storagePersistenceService, publicEventsService) {\n    this.resetAuthDataService = resetAuthDataService;\n    this.flowHelper = flowHelper;\n    this.configurationProvider = configurationProvider;\n    this.flowsDataService = flowsDataService;\n    this.loggerService = loggerService;\n    this.userService = userService;\n    this.authStateService = authStateService;\n    this.refreshSessionIframeService = refreshSessionIframeService;\n    this.refreshSessionRefreshTokenService = refreshSessionRefreshTokenService;\n    this.intervalService = intervalService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.publicEventsService = publicEventsService;\n  }\n\n  startTokenValidationPeriodically() {\n    const configsWithSilentRenewEnabled = this.getConfigsWithSilentRenewEnabled();\n\n    if (configsWithSilentRenewEnabled.length <= 0) {\n      return;\n    }\n\n    const refreshTimeInSeconds = this.getSmallestRefreshTimeFromConfigs(configsWithSilentRenewEnabled);\n\n    if (!!this.intervalService.runTokenValidationRunning) {\n      return;\n    } // START PERIODICALLY CHECK ONCE AND CHECK EACH CONFIG WHICH HAS IT ENABLED\n\n\n    const periodicallyCheck$ = this.intervalService.startPeriodicTokenCheck(refreshTimeInSeconds).pipe(switchMap(() => {\n      const objectWithConfigIdsAndRefreshEvent = {};\n      configsWithSilentRenewEnabled.forEach(({\n        configId\n      }) => {\n        objectWithConfigIdsAndRefreshEvent[configId] = this.getRefreshEvent(configId);\n      });\n      return forkJoin(objectWithConfigIdsAndRefreshEvent);\n    }));\n    this.intervalService.runTokenValidationRunning = periodicallyCheck$.subscribe(objectWithConfigIds => {\n      for (const [key, _] of Object.entries(objectWithConfigIds)) {\n        this.loggerService.logDebug(key, 'silent renew, periodic check finished!');\n\n        if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(key)) {\n          this.flowsDataService.resetSilentRenewRunning(key);\n        }\n      }\n    });\n  }\n\n  getRefreshEvent(configId) {\n    const shouldStartRefreshEvent = this.shouldStartPeriodicallyCheckForConfig(configId);\n\n    if (!shouldStartRefreshEvent) {\n      return of(null);\n    }\n\n    const refreshEvent$ = this.createRefreshEventForConfig(configId);\n    this.publicEventsService.fireEvent(EventTypes.SilentRenewStarted);\n    const refreshEventWithErrorHandler$ = refreshEvent$.pipe(catchError(error => {\n      this.loggerService.logError(configId, 'silent renew failed!', error);\n      this.flowsDataService.resetSilentRenewRunning(configId);\n      return throwError(error);\n    }));\n    return refreshEventWithErrorHandler$;\n  }\n\n  getSmallestRefreshTimeFromConfigs(configsWithSilentRenewEnabled) {\n    const result = configsWithSilentRenewEnabled.reduce((prev, curr) => prev.tokenRefreshInSeconds < curr.tokenRefreshInSeconds ? prev : curr);\n    return result.tokenRefreshInSeconds;\n  }\n\n  getConfigsWithSilentRenewEnabled() {\n    return this.configurationProvider.getAllConfigurations().filter(x => x.silentRenew);\n  }\n\n  createRefreshEventForConfig(configId) {\n    this.loggerService.logDebug(configId, 'starting silent renew...');\n    const config = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!(config === null || config === void 0 ? void 0 : config.silentRenew)) {\n      this.resetAuthDataService.resetAuthorizationData(configId);\n      return of(null);\n    }\n\n    this.flowsDataService.setSilentRenewRunning(configId);\n\n    if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(configId)) {\n      // Retrieve Dynamically Set Custom Params for refresh body\n      const customParamsRefresh = this.storagePersistenceService.read('storageCustomParamsRefresh', configId) || {};\n      const {\n        customParamsRefreshTokenRequest\n      } = this.configurationProvider.getOpenIDConfiguration(configId);\n      const mergedParams = Object.assign(Object.assign({}, customParamsRefreshTokenRequest), customParamsRefresh); // Refresh Session using Refresh tokens\n\n      return this.refreshSessionRefreshTokenService.refreshSessionWithRefreshTokens(configId, mergedParams);\n    } // Retrieve Dynamically Set Custom Params\n\n\n    const customParams = this.storagePersistenceService.read('storageCustomParamsAuthRequest', configId);\n    return this.refreshSessionIframeService.refreshSessionWithIframe(configId, customParams);\n  }\n\n  shouldStartPeriodicallyCheckForConfig(configId) {\n    const idToken = this.authStateService.getIdToken(configId);\n    const isSilentRenewRunning = this.flowsDataService.isSilentRenewRunning(configId);\n    const userDataFromStore = this.userService.getUserDataFromStore(configId);\n    this.loggerService.logDebug(configId, `Checking: silentRenewRunning: ${isSilentRenewRunning} - has idToken: ${!!idToken} - has userData: ${!!userDataFromStore}`);\n    const shouldBeExecuted = !!userDataFromStore && !isSilentRenewRunning && !!idToken;\n\n    if (!shouldBeExecuted) {\n      return false;\n    }\n\n    const idTokenStillValid = this.authStateService.hasIdTokenExpiredAndRenewCheckIsEnabled(configId);\n    const accessTokenHasExpired = this.authStateService.hasAccessTokenExpiredIfExpiryExists(configId);\n\n    if (!idTokenStillValid && !accessTokenHasExpired) {\n      return false;\n    }\n\n    return true;\n  }\n\n}\n\nPeriodicallyTokenCheckService.ɵfac = function PeriodicallyTokenCheckService_Factory(t) {\n  return new (t || PeriodicallyTokenCheckService)(i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(FlowHelper), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(UserService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(RefreshSessionIframeService), i0.ɵɵinject(RefreshSessionRefreshTokenService), i0.ɵɵinject(IntervalService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(PublicEventsService));\n};\n\nPeriodicallyTokenCheckService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PeriodicallyTokenCheckService,\n  factory: PeriodicallyTokenCheckService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PeriodicallyTokenCheckService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: ResetAuthDataService\n    }, {\n      type: FlowHelper\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: FlowsDataService\n    }, {\n      type: LoggerService\n    }, {\n      type: UserService\n    }, {\n      type: AuthStateService\n    }, {\n      type: RefreshSessionIframeService\n    }, {\n      type: RefreshSessionRefreshTokenService\n    }, {\n      type: IntervalService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: PublicEventsService\n    }];\n  }, null);\n})();\n\nclass PopUpService {\n  constructor() {\n    this.STORAGE_IDENTIFIER = 'popupauth';\n    this.resultInternal$ = new Subject();\n  }\n\n  get result$() {\n    return this.resultInternal$.asObservable();\n  }\n\n  isCurrentlyInPopup() {\n    if (this.canAccessSessionStorage()) {\n      const popup = sessionStorage.getItem(this.STORAGE_IDENTIFIER);\n      return !!window.opener && window.opener !== window && !!popup;\n    }\n\n    return false;\n  }\n\n  openPopUp(url, popupOptions) {\n    const optionsToPass = this.getOptions(popupOptions);\n    this.popUp = window.open(url, '_blank', optionsToPass);\n    this.popUp.sessionStorage.setItem(this.STORAGE_IDENTIFIER, 'true');\n\n    const listener = event => {\n      if (!(event === null || event === void 0 ? void 0 : event.data) || typeof event.data !== 'string') {\n        return;\n      }\n\n      this.resultInternal$.next({\n        userClosed: false,\n        receivedUrl: event.data\n      });\n      this.cleanUp(listener);\n    };\n\n    window.addEventListener('message', listener, false);\n    this.handle = window.setInterval(() => {\n      if (this.popUp.closed) {\n        this.resultInternal$.next({\n          userClosed: true\n        });\n        this.cleanUp(listener);\n      }\n    }, 200);\n  }\n\n  sendMessageToMainWindow(url) {\n    if (window.opener) {\n      this.sendMessage(url, window.location.href);\n    }\n  }\n\n  cleanUp(listener) {\n    var _a;\n\n    window.removeEventListener('message', listener, false);\n    window.clearInterval(this.handle);\n\n    if (this.popUp) {\n      (_a = this.popUp.sessionStorage) === null || _a === void 0 ? void 0 : _a.removeItem(this.STORAGE_IDENTIFIER);\n      this.popUp.close();\n      this.popUp = null;\n    }\n  }\n\n  sendMessage(url, href) {\n    window.opener.postMessage(url, href);\n  }\n\n  getOptions(popupOptions) {\n    const popupDefaultOptions = {\n      width: 500,\n      height: 500,\n      left: 50,\n      top: 50\n    };\n    const options = Object.assign(Object.assign({}, popupDefaultOptions), popupOptions || {});\n    const left = window.screenLeft + (window.outerWidth - options.width) / 2;\n    const top = window.screenTop + (window.outerHeight - options.height) / 2;\n    options.left = left;\n    options.top = top;\n    return Object.entries(options).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`).join(',');\n  }\n\n  canAccessSessionStorage() {\n    return typeof navigator !== 'undefined' && navigator.cookieEnabled && typeof Storage !== 'undefined';\n  }\n\n}\n\nPopUpService.ɵfac = function PopUpService_Factory(t) {\n  return new (t || PopUpService)();\n};\n\nPopUpService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PopUpService,\n  factory: PopUpService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PopUpService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n\nclass CheckAuthService {\n  constructor(checkSessionService, currentUrlService, silentRenewService, userService, loggerService, configurationProvider, authStateService, callbackService, refreshSessionService, periodicallyTokenCheckService, popupService, autoLoginService, storagePersistenceService) {\n    this.checkSessionService = checkSessionService;\n    this.currentUrlService = currentUrlService;\n    this.silentRenewService = silentRenewService;\n    this.userService = userService;\n    this.loggerService = loggerService;\n    this.configurationProvider = configurationProvider;\n    this.authStateService = authStateService;\n    this.callbackService = callbackService;\n    this.refreshSessionService = refreshSessionService;\n    this.periodicallyTokenCheckService = periodicallyTokenCheckService;\n    this.popupService = popupService;\n    this.autoLoginService = autoLoginService;\n    this.storagePersistenceService = storagePersistenceService;\n  }\n\n  checkAuth(passedConfigId, url) {\n    if (this.currentUrlService.currentUrlHasStateParam()) {\n      const stateParamFromUrl = this.currentUrlService.getStateParamFromCurrentUrl();\n      const config = this.getConfigurationWithUrlState(stateParamFromUrl);\n\n      if (!config) {\n        return throwError(`could not find matching config for state ${stateParamFromUrl}`);\n      }\n\n      return this.checkAuthWithConfig(config, url);\n    }\n\n    if (!!passedConfigId) {\n      const config = this.configurationProvider.getOpenIDConfiguration(passedConfigId);\n      return this.checkAuthWithConfig(config, url);\n    }\n\n    const onlyExistingConfig = this.configurationProvider.getOpenIDConfiguration();\n    return this.checkAuthWithConfig(onlyExistingConfig, url);\n  }\n\n  checkAuthMultiple(passedConfigId, url) {\n    if (this.currentUrlService.currentUrlHasStateParam()) {\n      const stateParamFromUrl = this.currentUrlService.getStateParamFromCurrentUrl();\n      const config = this.getConfigurationWithUrlState(stateParamFromUrl);\n\n      if (!config) {\n        return throwError(`could not find matching config for state ${stateParamFromUrl}`);\n      }\n\n      return this.composeMultipleLoginResults(config, url);\n    }\n\n    if (!!passedConfigId) {\n      const config = this.configurationProvider.getOpenIDConfiguration(passedConfigId);\n\n      if (!config) {\n        return throwError(`could not find matching config for id ${passedConfigId}`);\n      }\n\n      return this.composeMultipleLoginResults(config, url);\n    }\n\n    const allConfigs = this.configurationProvider.getAllConfigurations();\n    const allChecks$ = allConfigs.map(x => this.checkAuthWithConfig(x, url));\n    return forkJoin(allChecks$);\n  }\n\n  checkAuthIncludingServer(configId) {\n    const config = this.configurationProvider.getOpenIDConfiguration(configId);\n    return this.checkAuthWithConfig(config).pipe(switchMap(loginResponse => {\n      const {\n        isAuthenticated\n      } = loginResponse;\n\n      if (isAuthenticated) {\n        return of(loginResponse);\n      }\n\n      return this.refreshSessionService.forceRefreshSession(configId).pipe(tap(loginResponseAfterRefreshSession => {\n        if (loginResponseAfterRefreshSession === null || loginResponseAfterRefreshSession === void 0 ? void 0 : loginResponseAfterRefreshSession.isAuthenticated) {\n          this.startCheckSessionAndValidation(configId);\n        }\n      }));\n    }));\n  }\n\n  checkAuthWithConfig(config, url) {\n    const {\n      configId,\n      authority\n    } = config;\n\n    if (!this.configurationProvider.hasAsLeastOneConfig()) {\n      const errorMessage = 'Please provide at least one configuration before setting up the module';\n      this.loggerService.logError(configId, errorMessage);\n      return of({\n        isAuthenticated: false,\n        errorMessage,\n        userData: null,\n        idToken: null,\n        accessToken: null,\n        configId\n      });\n    }\n\n    const currentUrl = url || this.currentUrlService.getCurrentUrl();\n    this.loggerService.logDebug(configId, `Working with config '${configId}' using ${authority}`);\n\n    if (this.popupService.isCurrentlyInPopup()) {\n      this.popupService.sendMessageToMainWindow(currentUrl);\n      return of(null);\n    }\n\n    const isCallback = this.callbackService.isCallback(currentUrl);\n    this.loggerService.logDebug(configId, 'currentUrl to check auth with: ', currentUrl);\n    const callback$ = isCallback ? this.callbackService.handleCallbackAndFireEvents(currentUrl, configId) : of(null);\n    return callback$.pipe(map(() => {\n      const isAuthenticated = this.authStateService.areAuthStorageTokensValid(configId);\n\n      if (isAuthenticated) {\n        this.startCheckSessionAndValidation(configId);\n\n        if (!isCallback) {\n          this.authStateService.setAuthenticatedAndFireEvent();\n          this.userService.publishUserDataIfExists(configId);\n        }\n      }\n\n      this.loggerService.logDebug(configId, 'checkAuth completed - firing events now. isAuthenticated: ' + isAuthenticated);\n      return {\n        isAuthenticated,\n        userData: this.userService.getUserDataFromStore(configId),\n        accessToken: this.authStateService.getAccessToken(configId),\n        idToken: this.authStateService.getIdToken(configId),\n        configId\n      };\n    }), tap(({\n      isAuthenticated\n    }) => {\n      if (isAuthenticated) {\n        this.autoLoginService.checkSavedRedirectRouteAndNavigate(configId);\n      }\n    }), catchError(errorMessage => {\n      this.loggerService.logError(configId, errorMessage);\n      return of({\n        isAuthenticated: false,\n        errorMessage,\n        userData: null,\n        idToken: null,\n        accessToken: null,\n        configId\n      });\n    }));\n  }\n\n  startCheckSessionAndValidation(configId) {\n    if (this.checkSessionService.isCheckSessionConfigured(configId)) {\n      this.checkSessionService.start(configId);\n    }\n\n    this.periodicallyTokenCheckService.startTokenValidationPeriodically();\n\n    if (this.silentRenewService.isSilentRenewConfigured(configId)) {\n      this.silentRenewService.getOrCreateIframe(configId);\n    }\n  }\n\n  getConfigurationWithUrlState(stateFromUrl) {\n    const allConfigs = this.configurationProvider.getAllConfigurations();\n\n    for (const config of allConfigs) {\n      const storedState = this.storagePersistenceService.read('authStateControl', config.configId);\n\n      if (storedState === stateFromUrl) {\n        return config;\n      }\n    }\n\n    return null;\n  }\n\n  composeMultipleLoginResults(activeConfig, url) {\n    const allOtherConfigs = this.configurationProvider.getAllConfigurations().filter(x => x.configId !== activeConfig.configId);\n    const currentConfigResult = this.checkAuthWithConfig(activeConfig, url);\n    const allOtherConfigResults = allOtherConfigs.map(config => {\n      const {\n        redirectUrl\n      } = config;\n      return this.checkAuthWithConfig(config, redirectUrl);\n    });\n    return forkJoin([currentConfigResult, ...allOtherConfigResults]);\n  }\n\n}\n\nCheckAuthService.ɵfac = function CheckAuthService_Factory(t) {\n  return new (t || CheckAuthService)(i0.ɵɵinject(CheckSessionService), i0.ɵɵinject(CurrentUrlService), i0.ɵɵinject(SilentRenewService), i0.ɵɵinject(UserService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(CallbackService), i0.ɵɵinject(RefreshSessionService), i0.ɵɵinject(PeriodicallyTokenCheckService), i0.ɵɵinject(PopUpService), i0.ɵɵinject(AutoLoginService), i0.ɵɵinject(StoragePersistenceService));\n};\n\nCheckAuthService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CheckAuthService,\n  factory: CheckAuthService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CheckAuthService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: CheckSessionService\n    }, {\n      type: CurrentUrlService\n    }, {\n      type: SilentRenewService\n    }, {\n      type: UserService\n    }, {\n      type: LoggerService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: AuthStateService\n    }, {\n      type: CallbackService\n    }, {\n      type: RefreshSessionService\n    }, {\n      type: PeriodicallyTokenCheckService\n    }, {\n      type: PopUpService\n    }, {\n      type: AutoLoginService\n    }, {\n      type: StoragePersistenceService\n    }];\n  }, null);\n})();\n\nconst DEFAULT_CONFIG = {\n  authority: 'https://please_set',\n  authWellknownEndpointUrl: '',\n  authWellknownEndpoints: null,\n  redirectUrl: 'https://please_set',\n  clientId: 'please_set',\n  responseType: 'code',\n  scope: 'openid email profile',\n  hdParam: '',\n  postLogoutRedirectUri: 'https://please_set',\n  startCheckSession: false,\n  silentRenew: false,\n  silentRenewUrl: 'https://please_set',\n  silentRenewTimeoutInSeconds: 20,\n  renewTimeBeforeTokenExpiresInSeconds: 0,\n  useRefreshToken: false,\n  usePushedAuthorisationRequests: false,\n  ignoreNonceAfterRefresh: false,\n  postLoginRoute: '/',\n  forbiddenRoute: '/forbidden',\n  unauthorizedRoute: '/unauthorized',\n  autoUserInfo: true,\n  autoCleanStateAfterAuthentication: true,\n  triggerAuthorizationResultEvent: false,\n  logLevel: LogLevel.Warn,\n  issValidationOff: false,\n  historyCleanupOff: false,\n  maxIdTokenIatOffsetAllowedInSeconds: 120,\n  disableIatOffsetValidation: false,\n  storage: null,\n  customParamsAuthRequest: {},\n  customParamsRefreshTokenRequest: {},\n  customParamsEndSessionRequest: {},\n  customParamsCodeRequest: {},\n  eagerLoadAuthWellKnownEndpoints: true,\n  disableRefreshIdTokenAuthTimeValidation: false,\n  enableIdTokenExpiredValidationInRenew: true,\n  tokenRefreshInSeconds: 4,\n  refreshTokenRetryInSeconds: 3,\n  ngswBypass: false\n};\nconst POSITIVE_VALIDATION_RESULT = {\n  result: true,\n  messages: [],\n  level: null\n};\n\nconst ensureAuthority = passedConfig => {\n  if (!passedConfig.authority) {\n    return {\n      result: false,\n      messages: ['The authority URL MUST be provided in the configuration! '],\n      level: 'error'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst ensureClientId = passedConfig => {\n  if (!passedConfig.clientId) {\n    return {\n      result: false,\n      messages: ['The clientId is required and missing from your config!'],\n      level: 'error'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst createIdentifierToCheck = passedConfig => {\n  if (!passedConfig) {\n    return null;\n  }\n\n  const {\n    authority,\n    clientId,\n    scope\n  } = passedConfig;\n  return `${authority}${clientId}${scope}`;\n};\n\nconst arrayHasDuplicates = array => new Set(array).size !== array.length;\n\nconst ensureNoDuplicatedConfigsRule = passedConfigs => {\n  const allIdentifiers = passedConfigs.map(x => createIdentifierToCheck(x));\n  const someAreNull = allIdentifiers.some(x => x === null);\n\n  if (someAreNull) {\n    return {\n      result: false,\n      messages: [`Please make sure you add an object with a 'config' property: ....({ config }) instead of ...(config)`],\n      level: 'error'\n    };\n  }\n\n  const hasDuplicates = arrayHasDuplicates(allIdentifiers);\n\n  if (hasDuplicates) {\n    return {\n      result: false,\n      messages: ['You added multiple configs with the same authority, clientId and scope'],\n      level: 'warning'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst ensureRedirectRule = passedConfig => {\n  if (!passedConfig.redirectUrl) {\n    return {\n      result: false,\n      messages: ['The redirectURL is required and missing from your config'],\n      level: 'error'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst ensureSilentRenewUrlWhenNoRefreshTokenUsed = passedConfig => {\n  const usesSilentRenew = passedConfig.silentRenew;\n  const usesRefreshToken = passedConfig.useRefreshToken;\n  const hasSilentRenewUrl = passedConfig.silentRenewUrl;\n\n  if (usesSilentRenew && !usesRefreshToken && !hasSilentRenewUrl) {\n    return {\n      result: false,\n      messages: ['Please provide a silent renew URL if using renew and not refresh tokens'],\n      level: 'error'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst useOfflineScopeWithSilentRenew = passedConfig => {\n  const hasRefreshToken = passedConfig.useRefreshToken;\n  const hasSilentRenew = passedConfig.silentRenew;\n  const scope = passedConfig.scope || '';\n  const hasOfflineScope = scope.split(' ').includes('offline_access');\n\n  if (hasRefreshToken && hasSilentRenew && !hasOfflineScope) {\n    return {\n      result: false,\n      messages: ['When using silent renew and refresh tokens please set the `offline_access` scope'],\n      level: 'warning'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst allRules = [ensureAuthority, useOfflineScopeWithSilentRenew, ensureRedirectRule, ensureClientId, ensureSilentRenewUrlWhenNoRefreshTokenUsed];\nconst allMultipleConfigRules = [ensureNoDuplicatedConfigsRule];\n\nclass ConfigValidationService {\n  constructor(loggerService) {\n    this.loggerService = loggerService;\n  }\n\n  validateConfigs(passedConfigs) {\n    return this.validateConfigsInternal(passedConfigs, allMultipleConfigRules);\n  }\n\n  validateConfig(passedConfig) {\n    return this.validateConfigInternal(passedConfig, allRules);\n  }\n\n  validateConfigsInternal(passedConfigs, allRulesToUse) {\n    const allValidationResults = allRulesToUse.map(rule => rule(passedConfigs));\n    let overallErrorCount = 0;\n    passedConfigs.forEach(passedConfig => {\n      const errorCount = this.processValidationResultsAndGetErrorCount(allValidationResults, passedConfig === null || passedConfig === void 0 ? void 0 : passedConfig.configId);\n      overallErrorCount += errorCount;\n    });\n    return overallErrorCount === 0;\n  }\n\n  validateConfigInternal(passedConfig, allRulesToUse) {\n    const allValidationResults = allRulesToUse.map(rule => rule(passedConfig));\n    const errorCount = this.processValidationResultsAndGetErrorCount(allValidationResults, passedConfig.configId);\n    return errorCount === 0;\n  }\n\n  processValidationResultsAndGetErrorCount(allValidationResults, configId) {\n    const allMessages = allValidationResults.filter(x => x.messages.length > 0);\n    const allErrorMessages = this.getAllMessagesOfType('error', allMessages);\n    const allWarnings = this.getAllMessagesOfType('warning', allMessages);\n    allErrorMessages.forEach(message => this.loggerService.logError(configId, message));\n    allWarnings.forEach(message => this.loggerService.logWarning(configId, message));\n    return allErrorMessages.length;\n  }\n\n  getAllMessagesOfType(type, results) {\n    const allMessages = results.filter(x => x.level === type).map(result => result.messages);\n    return allMessages.reduce((acc, val) => acc.concat(val), []);\n  }\n\n}\n\nConfigValidationService.ɵfac = function ConfigValidationService_Factory(t) {\n  return new (t || ConfigValidationService)(i0.ɵɵinject(LoggerService));\n};\n\nConfigValidationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ConfigValidationService,\n  factory: ConfigValidationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ConfigValidationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }];\n  }, null);\n})();\n\nclass PlatformProvider {\n  constructor(platformId) {\n    this.platformId = platformId;\n  }\n\n  get isBrowser() {\n    return isPlatformBrowser(this.platformId);\n  }\n\n}\n\nPlatformProvider.ɵfac = function PlatformProvider_Factory(t) {\n  return new (t || PlatformProvider)(i0.ɵɵinject(PLATFORM_ID));\n};\n\nPlatformProvider.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PlatformProvider,\n  factory: PlatformProvider.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PlatformProvider, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\n\nclass DefaultSessionStorageService {\n  read(key) {\n    return sessionStorage.getItem(key);\n  }\n\n  write(key, value) {\n    sessionStorage.setItem(key, value);\n  }\n\n  remove(key) {\n    sessionStorage.removeItem(key);\n  }\n\n  clear() {\n    sessionStorage.clear();\n  }\n\n}\n\nDefaultSessionStorageService.ɵfac = function DefaultSessionStorageService_Factory(t) {\n  return new (t || DefaultSessionStorageService)();\n};\n\nDefaultSessionStorageService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DefaultSessionStorageService,\n  factory: DefaultSessionStorageService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DefaultSessionStorageService, [{\n    type: Injectable\n  }], null, null);\n})();\n\nclass OidcConfigService {\n  constructor(loggerService, publicEventsService, configurationProvider, authWellKnownService, storagePersistenceService, configValidationService, platformProvider, defaultSessionStorageService) {\n    this.loggerService = loggerService;\n    this.publicEventsService = publicEventsService;\n    this.configurationProvider = configurationProvider;\n    this.authWellKnownService = authWellKnownService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.configValidationService = configValidationService;\n    this.platformProvider = platformProvider;\n    this.defaultSessionStorageService = defaultSessionStorageService;\n  }\n\n  withConfigs(passedConfigs) {\n    if (!this.configValidationService.validateConfigs(passedConfigs)) {\n      return Promise.resolve(null);\n    }\n\n    this.createUniqueIds(passedConfigs);\n    const allHandleConfigPromises = passedConfigs.map(x => this.handleConfig(x));\n    return Promise.all(allHandleConfigPromises);\n  }\n\n  createUniqueIds(passedConfigs) {\n    passedConfigs.forEach((config, index) => {\n      if (!config.configId) {\n        config.configId = `${index}-${config.clientId}`;\n      }\n    });\n  }\n\n  handleConfig(passedConfig) {\n    return new Promise((resolve, reject) => {\n      if (!this.configValidationService.validateConfig(passedConfig)) {\n        this.loggerService.logError(passedConfig.configId, 'Validation of config rejected with errors. Config is NOT set.');\n        resolve(null);\n        return;\n      }\n\n      if (!passedConfig.authWellknownEndpointUrl) {\n        passedConfig.authWellknownEndpointUrl = passedConfig.authority;\n      }\n\n      const usedConfig = this.prepareConfig(passedConfig);\n      this.configurationProvider.setConfig(usedConfig);\n      const alreadyExistingAuthWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', usedConfig.configId);\n\n      if (!!alreadyExistingAuthWellKnownEndpoints) {\n        usedConfig.authWellknownEndpoints = alreadyExistingAuthWellKnownEndpoints;\n        this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, usedConfig);\n        resolve(usedConfig);\n        return;\n      }\n\n      const passedAuthWellKnownEndpoints = usedConfig.authWellknownEndpoints;\n\n      if (!!passedAuthWellKnownEndpoints) {\n        this.authWellKnownService.storeWellKnownEndpoints(usedConfig.configId, passedAuthWellKnownEndpoints);\n        usedConfig.authWellknownEndpoints = passedAuthWellKnownEndpoints;\n        this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, usedConfig);\n        resolve(usedConfig);\n        return;\n      }\n\n      if (usedConfig.eagerLoadAuthWellKnownEndpoints) {\n        this.authWellKnownService.getAuthWellKnownEndPoints(usedConfig.authWellknownEndpointUrl, usedConfig.configId).pipe(catchError(error => {\n          this.loggerService.logError(usedConfig.configId, 'Getting auth well known endpoints failed on start', error);\n          return throwError(error);\n        }), tap(wellknownEndPoints => {\n          usedConfig.authWellknownEndpoints = wellknownEndPoints;\n          this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, usedConfig);\n        })).subscribe(() => resolve(usedConfig), () => reject());\n      } else {\n        this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, usedConfig);\n        resolve(usedConfig);\n      }\n    });\n  }\n\n  prepareConfig(configuration) {\n    const openIdConfigurationInternal = Object.assign(Object.assign({}, DEFAULT_CONFIG), configuration);\n    this.setSpecialCases(openIdConfigurationInternal);\n    this.setStorage(openIdConfigurationInternal);\n    return openIdConfigurationInternal;\n  }\n\n  setSpecialCases(currentConfig) {\n    if (!this.platformProvider.isBrowser) {\n      currentConfig.startCheckSession = false;\n      currentConfig.silentRenew = false;\n      currentConfig.useRefreshToken = false;\n      currentConfig.usePushedAuthorisationRequests = false;\n    }\n  }\n\n  setStorage(currentConfig) {\n    if (currentConfig.storage) {\n      return;\n    }\n\n    if (this.hasBrowserStorage()) {\n      currentConfig.storage = this.defaultSessionStorageService;\n    } else {\n      currentConfig.storage = null;\n    }\n  }\n\n  hasBrowserStorage() {\n    return typeof navigator !== 'undefined' && navigator.cookieEnabled && typeof Storage !== 'undefined';\n  }\n\n}\n\nOidcConfigService.ɵfac = function OidcConfigService_Factory(t) {\n  return new (t || OidcConfigService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(AuthWellKnownService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(ConfigValidationService), i0.ɵɵinject(PlatformProvider), i0.ɵɵinject(DefaultSessionStorageService));\n};\n\nOidcConfigService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: OidcConfigService,\n  factory: OidcConfigService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OidcConfigService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: PublicEventsService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: AuthWellKnownService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: ConfigValidationService\n    }, {\n      type: PlatformProvider\n    }, {\n      type: DefaultSessionStorageService\n    }];\n  }, null);\n})();\n\nclass OpenIdConfigLoader {}\n\nclass StsConfigLoader {}\n\nclass StsConfigStaticLoader {\n  constructor(passedConfigs) {\n    this.passedConfigs = passedConfigs;\n  }\n\n  loadConfigs() {\n    if (Array.isArray(this.passedConfigs)) {\n      const allInstantStaticPromises = this.passedConfigs.map(x => new Promise((resolve, _) => resolve(x)));\n      return allInstantStaticPromises;\n    }\n\n    const singleStaticPromise = new Promise((resolve, _) => resolve(this.passedConfigs));\n    return [singleStaticPromise];\n  }\n\n}\n\nclass StsConfigHttpLoader {\n  constructor(configs$) {\n    this.configs$ = configs$;\n  }\n\n  loadConfigs() {\n    return Array.isArray(this.configs$) ? this.configs$ : [this.configs$];\n  }\n\n}\n\nclass ClosestMatchingRouteService {\n  constructor(configProvider) {\n    this.configProvider = configProvider;\n  }\n\n  getConfigIdForClosestMatchingRoute(route) {\n    const allConfiguredRoutes = this.getAllConfiguredRoutes();\n\n    for (const routesWithConfig of allConfiguredRoutes) {\n      const allRoutesForConfig = routesWithConfig.routes;\n\n      for (const configuredRoute of allRoutesForConfig) {\n        if (route.startsWith(configuredRoute)) {\n          return {\n            matchingRoute: configuredRoute,\n            matchingConfigId: routesWithConfig.configId\n          };\n        }\n      }\n    }\n\n    return {\n      matchingRoute: null,\n      matchingConfigId: null\n    };\n  }\n\n  getAllConfiguredRoutes() {\n    const allConfigurations = this.configProvider.getAllConfigurations();\n    return allConfigurations.map(x => ({\n      routes: x.secureRoutes,\n      configId: x.configId\n    }));\n  }\n\n}\n\nClosestMatchingRouteService.ɵfac = function ClosestMatchingRouteService_Factory(t) {\n  return new (t || ClosestMatchingRouteService)(i0.ɵɵinject(ConfigurationProvider));\n};\n\nClosestMatchingRouteService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ClosestMatchingRouteService,\n  factory: ClosestMatchingRouteService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ClosestMatchingRouteService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ConfigurationProvider\n    }];\n  }, null);\n})();\n\nclass ResponseTypeValidationService {\n  constructor(loggerService, flowHelper) {\n    this.loggerService = loggerService;\n    this.flowHelper = flowHelper;\n  }\n\n  hasConfigValidResponseType(configId) {\n    if (this.flowHelper.isCurrentFlowAnyImplicitFlow(configId)) {\n      return true;\n    }\n\n    if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\n      return true;\n    }\n\n    this.loggerService.logWarning(configId, 'module configured incorrectly, invalid response_type. Check the responseType in the config');\n    return false;\n  }\n\n}\n\nResponseTypeValidationService.ɵfac = function ResponseTypeValidationService_Factory(t) {\n  return new (t || ResponseTypeValidationService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(FlowHelper));\n};\n\nResponseTypeValidationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ResponseTypeValidationService,\n  factory: ResponseTypeValidationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ResponseTypeValidationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: FlowHelper\n    }];\n  }, null);\n})();\n\nclass RedirectService {\n  constructor(doc) {\n    this.doc = doc;\n  }\n\n  redirectTo(url) {\n    this.doc.location.href = url;\n  }\n\n}\n\nRedirectService.ɵfac = function RedirectService_Factory(t) {\n  return new (t || RedirectService)(i0.ɵɵinject(DOCUMENT));\n};\n\nRedirectService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RedirectService,\n  factory: RedirectService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RedirectService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nclass ParService {\n  constructor(loggerService, urlService, dataService, storagePersistenceService) {\n    this.loggerService = loggerService;\n    this.urlService = urlService;\n    this.dataService = dataService;\n    this.storagePersistenceService = storagePersistenceService;\n  }\n\n  postParRequest(configId, customParams) {\n    let headers = new HttpHeaders();\n    headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n    const authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n    if (!authWellknownEndpoints) {\n      return throwError('Could not read PAR endpoint because authWellKnownEndPoints are not given');\n    }\n\n    const parEndpoint = authWellknownEndpoints.parEndpoint;\n\n    if (!parEndpoint) {\n      return throwError('Could not read PAR endpoint from authWellKnownEndpoints');\n    }\n\n    const data = this.urlService.createBodyForParCodeFlowRequest(configId, customParams);\n    return this.dataService.post(parEndpoint, data, configId, headers).pipe(retry(2), map(response => {\n      this.loggerService.logDebug(configId, 'par response: ', response);\n      return {\n        expiresIn: response.expires_in,\n        requestUri: response.request_uri\n      };\n    }), catchError(error => {\n      const errorMessage = `There was an error on ParService postParRequest`;\n      this.loggerService.logError(configId, errorMessage, error);\n      return throwError(errorMessage);\n    }));\n  }\n\n}\n\nParService.ɵfac = function ParService_Factory(t) {\n  return new (t || ParService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(UrlService), i0.ɵɵinject(DataService), i0.ɵɵinject(StoragePersistenceService));\n};\n\nParService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ParService,\n  factory: ParService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ParService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: UrlService\n    }, {\n      type: DataService\n    }, {\n      type: StoragePersistenceService\n    }];\n  }, null);\n})();\n\nclass ParLoginService {\n  constructor(loggerService, responseTypeValidationService, urlService, redirectService, configurationProvider, authWellKnownService, popupService, checkAuthService, parService) {\n    this.loggerService = loggerService;\n    this.responseTypeValidationService = responseTypeValidationService;\n    this.urlService = urlService;\n    this.redirectService = redirectService;\n    this.configurationProvider = configurationProvider;\n    this.authWellKnownService = authWellKnownService;\n    this.popupService = popupService;\n    this.checkAuthService = checkAuthService;\n    this.parService = parService;\n  }\n\n  loginPar(configId, authOptions) {\n    if (!this.responseTypeValidationService.hasConfigValidResponseType(configId)) {\n      this.loggerService.logError(configId, 'Invalid response type!');\n      return;\n    }\n\n    const {\n      authWellknownEndpointUrl\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!authWellknownEndpointUrl) {\n      this.loggerService.logError(configId, 'no authWellknownEndpoint given!');\n      return;\n    }\n\n    this.loggerService.logDebug(configId, 'BEGIN Authorize OIDC Flow, no auth data');\n    const {\n      urlHandler,\n      customParams\n    } = authOptions || {};\n    this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).pipe(switchMap(() => this.parService.postParRequest(configId, customParams))).subscribe(response => {\n      this.loggerService.logDebug(configId, 'par response: ', response);\n      const url = this.urlService.getAuthorizeParUrl(response.requestUri, configId);\n      this.loggerService.logDebug(configId, 'par request url: ', url);\n\n      if (!url) {\n        this.loggerService.logError(configId, `Could not create URL with param ${response.requestUri}: '${url}'`);\n        return;\n      }\n\n      if (urlHandler) {\n        urlHandler(url);\n      } else {\n        this.redirectService.redirectTo(url);\n      }\n    });\n  }\n\n  loginWithPopUpPar(configId, authOptions, popupOptions) {\n    if (!this.responseTypeValidationService.hasConfigValidResponseType(configId)) {\n      const errorMessage = 'Invalid response type!';\n      this.loggerService.logError(configId, errorMessage);\n      return throwError(errorMessage);\n    }\n\n    const {\n      authWellknownEndpointUrl\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!authWellknownEndpointUrl) {\n      const errorMessage = 'no authWellknownEndpoint given!';\n      this.loggerService.logError(configId, errorMessage);\n      return throwError(errorMessage);\n    }\n\n    this.loggerService.logDebug(configId, 'BEGIN Authorize OIDC Flow with popup, no auth data');\n    const {\n      customParams\n    } = authOptions || {};\n    return this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).pipe(switchMap(() => this.parService.postParRequest(configId, customParams)), switchMap(response => {\n      this.loggerService.logDebug(configId, 'par response: ', response);\n      const url = this.urlService.getAuthorizeParUrl(response.requestUri, configId);\n      this.loggerService.logDebug(configId, 'par request url: ', url);\n\n      if (!url) {\n        const errorMessage = `Could not create URL with param ${response.requestUri}: 'url'`;\n        this.loggerService.logError(configId, errorMessage);\n        return throwError(errorMessage);\n      }\n\n      this.popupService.openPopUp(url, popupOptions);\n      return this.popupService.result$.pipe(take(1), switchMap(result => {\n        const {\n          userClosed,\n          receivedUrl\n        } = result;\n\n        if (userClosed) {\n          return of({\n            isAuthenticated: false,\n            errorMessage: 'User closed popup',\n            userData: null,\n            idToken: null,\n            accessToken: null,\n            configId\n          });\n        }\n\n        return this.checkAuthService.checkAuth(configId, receivedUrl);\n      }));\n    }));\n  }\n\n}\n\nParLoginService.ɵfac = function ParLoginService_Factory(t) {\n  return new (t || ParLoginService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ResponseTypeValidationService), i0.ɵɵinject(UrlService), i0.ɵɵinject(RedirectService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(AuthWellKnownService), i0.ɵɵinject(PopUpService), i0.ɵɵinject(CheckAuthService), i0.ɵɵinject(ParService));\n};\n\nParLoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ParLoginService,\n  factory: ParLoginService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ParLoginService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: ResponseTypeValidationService\n    }, {\n      type: UrlService\n    }, {\n      type: RedirectService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: AuthWellKnownService\n    }, {\n      type: PopUpService\n    }, {\n      type: CheckAuthService\n    }, {\n      type: ParService\n    }];\n  }, null);\n})();\n\nclass PopUpLoginService {\n  constructor(loggerService, responseTypeValidationService, urlService, configurationProvider, authWellKnownService, popupService, checkAuthService) {\n    this.loggerService = loggerService;\n    this.responseTypeValidationService = responseTypeValidationService;\n    this.urlService = urlService;\n    this.configurationProvider = configurationProvider;\n    this.authWellKnownService = authWellKnownService;\n    this.popupService = popupService;\n    this.checkAuthService = checkAuthService;\n  }\n\n  loginWithPopUpStandard(configId, authOptions, popupOptions) {\n    if (!this.responseTypeValidationService.hasConfigValidResponseType(configId)) {\n      const errorMessage = 'Invalid response type!';\n      this.loggerService.logError(configId, errorMessage);\n      return throwError(errorMessage);\n    }\n\n    const {\n      authWellknownEndpointUrl\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!authWellknownEndpointUrl) {\n      const errorMessage = 'no authWellknownEndpoint given!';\n      this.loggerService.logError(configId, errorMessage);\n      return throwError(errorMessage);\n    }\n\n    this.loggerService.logDebug(configId, 'BEGIN Authorize OIDC Flow with popup, no auth data');\n    return this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).pipe(switchMap(() => {\n      const {\n        customParams\n      } = authOptions || {};\n      const authUrl = this.urlService.getAuthorizeUrl(configId, customParams);\n      this.popupService.openPopUp(authUrl, popupOptions);\n      return this.popupService.result$.pipe(take(1), switchMap(result => {\n        const {\n          userClosed,\n          receivedUrl\n        } = result;\n\n        if (userClosed) {\n          return of({\n            isAuthenticated: false,\n            errorMessage: 'User closed popup',\n            userData: null,\n            idToken: null,\n            accessToken: null,\n            configId\n          });\n        }\n\n        return this.checkAuthService.checkAuth(configId, receivedUrl);\n      }));\n    }));\n  }\n\n}\n\nPopUpLoginService.ɵfac = function PopUpLoginService_Factory(t) {\n  return new (t || PopUpLoginService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ResponseTypeValidationService), i0.ɵɵinject(UrlService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(AuthWellKnownService), i0.ɵɵinject(PopUpService), i0.ɵɵinject(CheckAuthService));\n};\n\nPopUpLoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PopUpLoginService,\n  factory: PopUpLoginService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PopUpLoginService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: ResponseTypeValidationService\n    }, {\n      type: UrlService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: AuthWellKnownService\n    }, {\n      type: PopUpService\n    }, {\n      type: CheckAuthService\n    }];\n  }, null);\n})();\n\nclass StandardLoginService {\n  constructor(loggerService, responseTypeValidationService, urlService, redirectService, configurationProvider, authWellKnownService) {\n    this.loggerService = loggerService;\n    this.responseTypeValidationService = responseTypeValidationService;\n    this.urlService = urlService;\n    this.redirectService = redirectService;\n    this.configurationProvider = configurationProvider;\n    this.authWellKnownService = authWellKnownService;\n  }\n\n  loginStandard(configId, authOptions) {\n    if (!this.responseTypeValidationService.hasConfigValidResponseType(configId)) {\n      this.loggerService.logError(configId, 'Invalid response type!');\n      return;\n    }\n\n    const {\n      authWellknownEndpointUrl\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!authWellknownEndpointUrl) {\n      this.loggerService.logError(configId, 'no authWellknownEndpoint given!');\n      return;\n    }\n\n    this.loggerService.logDebug(configId, 'BEGIN Authorize OIDC Flow, no auth data');\n    this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).subscribe(() => {\n      const {\n        urlHandler,\n        customParams\n      } = authOptions || {};\n      const url = this.urlService.getAuthorizeUrl(configId, customParams);\n\n      if (!url) {\n        this.loggerService.logError(configId, 'Could not create URL', url);\n        return;\n      }\n\n      if (urlHandler) {\n        urlHandler(url);\n      } else {\n        this.redirectService.redirectTo(url);\n      }\n    });\n  }\n\n}\n\nStandardLoginService.ɵfac = function StandardLoginService_Factory(t) {\n  return new (t || StandardLoginService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ResponseTypeValidationService), i0.ɵɵinject(UrlService), i0.ɵɵinject(RedirectService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(AuthWellKnownService));\n};\n\nStandardLoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StandardLoginService,\n  factory: StandardLoginService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StandardLoginService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: ResponseTypeValidationService\n    }, {\n      type: UrlService\n    }, {\n      type: RedirectService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: AuthWellKnownService\n    }];\n  }, null);\n})();\n\nclass LoginService {\n  constructor(configurationProvider, parLoginService, popUpLoginService, standardLoginService, storagePersistenceService) {\n    this.configurationProvider = configurationProvider;\n    this.parLoginService = parLoginService;\n    this.popUpLoginService = popUpLoginService;\n    this.standardLoginService = standardLoginService;\n    this.storagePersistenceService = storagePersistenceService;\n  }\n\n  login(configId, authOptions) {\n    if (authOptions === null || authOptions === void 0 ? void 0 : authOptions.customParams) {\n      this.storagePersistenceService.write('storageCustomParamsAuthRequest', authOptions.customParams, configId);\n    }\n\n    const {\n      usePushedAuthorisationRequests\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (usePushedAuthorisationRequests) {\n      return this.parLoginService.loginPar(configId, authOptions);\n    } else {\n      return this.standardLoginService.loginStandard(configId, authOptions);\n    }\n  }\n\n  loginWithPopUp(configId, authOptions, popupOptions) {\n    if (authOptions === null || authOptions === void 0 ? void 0 : authOptions.customParams) {\n      this.storagePersistenceService.write('storageCustomParamsAuthRequest', authOptions.customParams, configId);\n    }\n\n    const {\n      usePushedAuthorisationRequests\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (usePushedAuthorisationRequests) {\n      return this.parLoginService.loginWithPopUpPar(configId, authOptions, popupOptions);\n    } else {\n      return this.popUpLoginService.loginWithPopUpStandard(configId, authOptions, popupOptions);\n    }\n  }\n\n}\n\nLoginService.ɵfac = function LoginService_Factory(t) {\n  return new (t || LoginService)(i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(ParLoginService), i0.ɵɵinject(PopUpLoginService), i0.ɵɵinject(StandardLoginService), i0.ɵɵinject(StoragePersistenceService));\n};\n\nLoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: LoginService,\n  factory: LoginService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LoginService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ConfigurationProvider\n    }, {\n      type: ParLoginService\n    }, {\n      type: PopUpLoginService\n    }, {\n      type: StandardLoginService\n    }, {\n      type: StoragePersistenceService\n    }];\n  }, null);\n})();\n\nclass LogoffRevocationService {\n  constructor(dataService, storagePersistenceService, loggerService, urlService, checkSessionService, resetAuthDataService, redirectService, configurationProvider) {\n    this.dataService = dataService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.loggerService = loggerService;\n    this.urlService = urlService;\n    this.checkSessionService = checkSessionService;\n    this.resetAuthDataService = resetAuthDataService;\n    this.redirectService = redirectService;\n    this.configurationProvider = configurationProvider;\n  } // Logs out on the server and the local client.\n  // If the server state has changed, check session, then only a local logout.\n\n\n  logoff(configId, authOptions) {\n    const {\n      urlHandler,\n      customParams\n    } = authOptions || {};\n    this.loggerService.logDebug(configId, 'logoff, remove auth ');\n    const endSessionUrl = this.getEndSessionUrl(configId, customParams);\n    this.resetAuthDataService.resetAuthorizationData(configId);\n\n    if (!endSessionUrl) {\n      this.loggerService.logDebug(configId, 'only local login cleaned up, no end_session_endpoint');\n      return;\n    }\n\n    if (this.checkSessionService.serverStateChanged(configId)) {\n      this.loggerService.logDebug(configId, 'only local login cleaned up, server session has changed');\n    } else if (urlHandler) {\n      urlHandler(endSessionUrl);\n    } else {\n      this.redirectService.redirectTo(endSessionUrl);\n    }\n  }\n\n  logoffLocal(configId) {\n    this.resetAuthDataService.resetAuthorizationData(configId);\n    this.checkSessionService.stop();\n  }\n\n  logoffLocalMultiple() {\n    const allConfigs = this.configurationProvider.getAllConfigurations();\n    allConfigs.forEach(({\n      configId\n    }) => this.logoffLocal(configId));\n  } // The refresh token and and the access token are revoked on the server. If the refresh token does not exist\n  // only the access token is revoked. Then the logout run.\n\n\n  logoffAndRevokeTokens(configId, authOptions) {\n    const {\n      revocationEndpoint\n    } = this.storagePersistenceService.read('authWellKnownEndPoints', configId) || {};\n\n    if (!revocationEndpoint) {\n      this.loggerService.logDebug(configId, 'revocation endpoint not supported');\n      this.logoff(configId, authOptions);\n    }\n\n    if (this.storagePersistenceService.getRefreshToken(configId)) {\n      return this.revokeRefreshToken(configId).pipe(switchMap(result => this.revokeAccessToken(configId, result)), catchError(error => {\n        const errorMessage = `revoke token failed`;\n        this.loggerService.logError(configId, errorMessage, error);\n        return throwError(errorMessage);\n      }), tap(() => this.logoff(configId, authOptions)));\n    } else {\n      return this.revokeAccessToken(configId).pipe(catchError(error => {\n        const errorMessage = `revoke accessToken failed`;\n        this.loggerService.logError(configId, errorMessage, error);\n        return throwError(errorMessage);\n      }), tap(() => this.logoff(configId, authOptions)));\n    }\n  } // https://tools.ietf.org/html/rfc7009\n  // revokes an access token on the STS. If no token is provided, then the token from\n  // the storage is revoked. You can pass any token to revoke. This makes it possible to\n  // manage your own tokens. The is a public API.\n\n\n  revokeAccessToken(configId, accessToken) {\n    const accessTok = accessToken || this.storagePersistenceService.getAccessToken(configId);\n    const body = this.urlService.createRevocationEndpointBodyAccessToken(accessTok, configId);\n    return this.sendRevokeRequest(configId, body);\n  } // https://tools.ietf.org/html/rfc7009\n  // revokes an refresh token on the STS. This is only required in the code flow with refresh tokens.\n  // If no token is provided, then the token from the storage is revoked. You can pass any token to revoke.\n  // This makes it possible to manage your own tokens.\n\n\n  revokeRefreshToken(configId, refreshToken) {\n    const refreshTok = refreshToken || this.storagePersistenceService.getRefreshToken(configId);\n    const body = this.urlService.createRevocationEndpointBodyRefreshToken(refreshTok, configId);\n    return this.sendRevokeRequest(configId, body);\n  }\n\n  getEndSessionUrl(configId, customParams) {\n    const idToken = this.storagePersistenceService.getIdToken(configId);\n    const {\n      customParamsEndSessionRequest\n    } = this.configurationProvider.getOpenIDConfiguration();\n    const mergedParams = Object.assign(Object.assign({}, customParamsEndSessionRequest), customParams);\n    return this.urlService.createEndSessionUrl(idToken, configId, mergedParams);\n  }\n\n  sendRevokeRequest(configId, body) {\n    const url = this.urlService.getRevocationEndpointUrl(configId);\n    let headers = new HttpHeaders();\n    headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n    return this.dataService.post(url, body, configId, headers).pipe(retry(2), switchMap(response => {\n      this.loggerService.logDebug(configId, 'revocation endpoint post response: ', response);\n      return of(response);\n    }), catchError(error => {\n      const errorMessage = `Revocation request failed`;\n      this.loggerService.logError(configId, errorMessage, error);\n      return throwError(errorMessage);\n    }));\n  }\n\n}\n\nLogoffRevocationService.ɵfac = function LogoffRevocationService_Factory(t) {\n  return new (t || LogoffRevocationService)(i0.ɵɵinject(DataService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(UrlService), i0.ɵɵinject(CheckSessionService), i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(RedirectService), i0.ɵɵinject(ConfigurationProvider));\n};\n\nLogoffRevocationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: LogoffRevocationService,\n  factory: LogoffRevocationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LogoffRevocationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: DataService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: LoggerService\n    }, {\n      type: UrlService\n    }, {\n      type: CheckSessionService\n    }, {\n      type: ResetAuthDataService\n    }, {\n      type: RedirectService\n    }, {\n      type: ConfigurationProvider\n    }];\n  }, null);\n})();\n\nclass OidcSecurityService {\n  constructor(checkSessionService, checkAuthService, userService, tokenHelperService, configurationProvider, authStateService, flowsDataService, callbackService, logoffRevocationService, loginService, refreshSessionService, urlService) {\n    this.checkSessionService = checkSessionService;\n    this.checkAuthService = checkAuthService;\n    this.userService = userService;\n    this.tokenHelperService = tokenHelperService;\n    this.configurationProvider = configurationProvider;\n    this.authStateService = authStateService;\n    this.flowsDataService = flowsDataService;\n    this.callbackService = callbackService;\n    this.logoffRevocationService = logoffRevocationService;\n    this.loginService = loginService;\n    this.refreshSessionService = refreshSessionService;\n    this.urlService = urlService;\n  }\n  /**\r\n   * Provides information about the user after they have logged in.\r\n   *\r\n   * @returns Returns an object containing either the user data directly (single config) or\r\n   * the user data per config in case you are running with multiple configs\r\n   */\n\n\n  get userData$() {\n    return this.userService.userData$;\n  }\n  /**\r\n   * Emits each time an authorization event occurs.\r\n   *\r\n   * @returns Returns an object containing if you are authenticated or not.\r\n   * Single Config: true if config is authenticated, false if not.\r\n   * Multiple Configs: true is all configs are authenticated, false if only one of them is not\r\n   *\r\n   * The `allConfigsAuthenticated` property contains the auth information _per config_.\r\n   */\n\n\n  get isAuthenticated$() {\n    return this.authStateService.authenticated$;\n  }\n  /**\r\n   * Emits each time the server sends a CheckSession event and the value changed. This property will always return\r\n   * true.\r\n   */\n\n\n  get checkSessionChanged$() {\n    return this.checkSessionService.checkSessionChanged$;\n  }\n  /**\r\n   * Emits on a Security Token Service callback. The observable will never contain a value.\r\n   */\n\n\n  get stsCallback$() {\n    return this.callbackService.stsCallback$;\n  }\n  /**\r\n   * Returns the currently active OpenID configurations.\r\n   *\r\n   * @returns an array of OpenIdConfigurations.\r\n   */\n\n\n  getConfigurations() {\n    return this.configurationProvider.getAllConfigurations();\n  }\n  /**\r\n   * Returns a single active OpenIdConfiguration.\r\n   *\r\n   * @param configId The configId to identify the config. If not passed, the first one is being returned\r\n   */\n\n\n  getConfiguration(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration().configId;\n    return this.configurationProvider.getOpenIDConfiguration(configId);\n  }\n  /**\r\n   * Returns the userData for a configuration\r\n   *\r\n   * @param configId The configId to identify the config. If not passed, the first one is being used\r\n   */\n\n\n  getUserData(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration().configId;\n    return this.userService.getUserDataFromStore(configId);\n  }\n  /**\r\n   * Starts the complete setup flow for one configuration. Calling will start the entire authentication flow, and the returned observable\r\n   * will denote whether the user was successfully authenticated including the user data, the access token, the configId and\r\n   * an error message in case an error happened\r\n   *\r\n   * @param url The URL to perform the authorization on the behalf of.\r\n   * @param configId The configId to perform the authorization on the behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns An object `LoginResponse` containing all information about the login\r\n   */\n\n\n  checkAuth(url, configId) {\n    return this.checkAuthService.checkAuth(configId, url);\n  }\n  /**\r\n   * Starts the complete setup flow for multiple configurations.\r\n   * Calling will start the entire authentication flow, and the returned observable\r\n   * will denote whether the user was successfully authenticated including the user data, the access token, the configId and\r\n   * an error message in case an error happened in an array for each config which was provided\r\n   *\r\n   * @param url The URL to perform the authorization on the behalf of.\r\n   * @param configId The configId to perform the authorization on the behalf of. If not passed, all of the current\r\n   * configured ones will be used to check.\r\n   *\r\n   * @returns An array of `LoginResponse` objects containing all information about the logins\r\n   */\n\n\n  checkAuthMultiple(url, configId) {\n    return this.checkAuthService.checkAuthMultiple(configId, url);\n  }\n  /**\r\n   * Provides information about the current authenticated state\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A boolean whether the config is authenticated or not.\r\n   */\n\n\n  isAuthenticated(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.authStateService.isAuthenticated(configId);\n  }\n  /**\r\n   * Checks the server for an authenticated session using the iframe silent renew if not locally authenticated.\r\n   */\n\n\n  checkAuthIncludingServer(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.checkAuthService.checkAuthIncludingServer(configId);\n  }\n  /**\r\n   * Returns the access token for the login scenario.\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A string with the access token.\r\n   */\n\n\n  getAccessToken(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.authStateService.getAccessToken(configId);\n  }\n  /**\r\n   * Returns the ID token for the sign-in.\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A string with the id token.\r\n   */\n\n\n  getIdToken(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.authStateService.getIdToken(configId);\n  }\n  /**\r\n   * Returns the refresh token, if present, for the sign-in.\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A string with the refresh token.\r\n   */\n\n\n  getRefreshToken(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.authStateService.getRefreshToken(configId);\n  }\n  /**\r\n   * Returns the authentication result, if present, for the sign-in.\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A object with the authentication result\r\n   */\n\n\n  getAuthenticationResult(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.authStateService.getAuthenticationResult(configId);\n  }\n  /**\r\n   * Returns the payload from the ID token.\r\n   *\r\n   * @param encode Set to true if the payload is base64 encoded\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns The payload from the id token.\r\n   */\n\n\n  getPayloadFromIdToken(encode = false, configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    const token = this.authStateService.getIdToken(configId);\n    return this.tokenHelperService.getPayloadFromToken(token, encode, configId);\n  }\n  /**\r\n   * Sets a custom state for the authorize request.\r\n   *\r\n   * @param state The state to set.\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   */\n\n\n  setState(state, configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    this.flowsDataService.setAuthStateControl(state, configId);\n  }\n  /**\r\n   * Gets the state value used for the authorize request.\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns The state value used for the authorize request.\r\n   */\n\n\n  getState(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.flowsDataService.getAuthStateControl(configId);\n  }\n  /**\r\n   * Redirects the user to the Security Token Service to begin the authentication process.\r\n   *\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   * @param authOptions The custom options for the the authentication request.\r\n   */\n\n\n  authorize(configId, authOptions) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    this.loginService.login(configId, authOptions);\n  }\n  /**\r\n   * Opens the Security Token Service in a new window to begin the authentication process.\r\n   *\r\n   * @param authOptions The custom options for the authentication request.\r\n   * @param popupOptions The configuration for the popup window.\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns An `Observable<LoginResponse>` containing all information about the login\r\n   */\n\n\n  authorizeWithPopUp(authOptions, popupOptions, configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.loginService.loginWithPopUp(configId, authOptions, popupOptions);\n  }\n  /**\r\n   * Manually refreshes the session.\r\n   *\r\n   * @param customParams Custom parameters to pass to the refresh request.\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns An `Observable<LoginResponse>` containing all information about the login\r\n   */\n\n\n  forceRefreshSession(customParams, configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.refreshSessionService.userForceRefreshSession(configId, customParams);\n  }\n  /**\r\n   * Revokes the refresh token (if present) and the access token on the server and then performs the logoff operation.\r\n   * The refresh token and and the access token are revoked on the server. If the refresh token does not exist\r\n   * only the access token is revoked. Then the logout run.\r\n   *\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   * @param authOptions The custom options for the request.\r\n   *\r\n   * @returns An observable when the action is finished\r\n   */\n\n\n  logoffAndRevokeTokens(configId, authOptions) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.logoffRevocationService.logoffAndRevokeTokens(configId, authOptions);\n  }\n  /**\r\n   * Logs out on the server and the local client. If the server state has changed, confirmed via check session,\r\n   * then only a local logout is performed.\r\n   *\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   * @param authOptions with custom parameters and/or an custom url handler\r\n   */\n\n\n  logoff(configId, authOptions) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.logoffRevocationService.logoff(configId, authOptions);\n  }\n  /**\r\n   * Logs the user out of the application without logging them out of the server.\r\n   * Use this method if you have _one_ config enabled.\r\n   *\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   */\n\n\n  logoffLocal(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.logoffRevocationService.logoffLocal(configId);\n  }\n  /**\r\n   * Logs the user out of the application for all configs without logging them out of the server.\r\n   * Use this method if you have _multiple_ configs enabled.\r\n   */\n\n\n  logoffLocalMultiple() {\n    return this.logoffRevocationService.logoffLocalMultiple();\n  }\n  /**\r\n   * Revokes an access token on the Security Token Service. This is only required in the code flow with refresh tokens. If no token is\r\n   * provided, then the token from the storage is revoked. You can pass any token to revoke.\r\n   * https://tools.ietf.org/html/rfc7009\r\n   *\r\n   * @param accessToken The access token to revoke.\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns An observable when the action is finished\r\n   */\n\n\n  revokeAccessToken(accessToken, configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.logoffRevocationService.revokeAccessToken(configId, accessToken);\n  }\n  /**\r\n   * Revokes a refresh token on the Security Token Service. This is only required in the code flow with refresh tokens. If no token is\r\n   * provided, then the token from the storage is revoked. You can pass any token to revoke.\r\n   * https://tools.ietf.org/html/rfc7009\r\n   *\r\n   * @param refreshToken The access token to revoke.\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns An observable when the action is finished\r\n   */\n\n\n  revokeRefreshToken(refreshToken, configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.logoffRevocationService.revokeRefreshToken(configId, refreshToken);\n  }\n  /**\r\n   * Creates the end session URL which can be used to implement an alternate server logout.\r\n   *\r\n   * @param customParams\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A string with the end session url or null\r\n   */\n\n\n  getEndSessionUrl(customParams, configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.logoffRevocationService.getEndSessionUrl(configId, customParams);\n  }\n  /**\r\n   * Creates the authorize URL based on your flow\r\n   *\r\n   * @param customParams\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A string with the authorize URL or null\r\n   */\n\n\n  getAuthorizeUrl(customParams, configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.urlService.getAuthorizeUrl(configId, customParams);\n  }\n\n}\n\nOidcSecurityService.ɵfac = function OidcSecurityService_Factory(t) {\n  return new (t || OidcSecurityService)(i0.ɵɵinject(CheckSessionService), i0.ɵɵinject(CheckAuthService), i0.ɵɵinject(UserService), i0.ɵɵinject(TokenHelperService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(CallbackService), i0.ɵɵinject(LogoffRevocationService), i0.ɵɵinject(LoginService), i0.ɵɵinject(RefreshSessionService), i0.ɵɵinject(UrlService));\n};\n\nOidcSecurityService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: OidcSecurityService,\n  factory: OidcSecurityService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OidcSecurityService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: CheckSessionService\n    }, {\n      type: CheckAuthService\n    }, {\n      type: UserService\n    }, {\n      type: TokenHelperService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: AuthStateService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: CallbackService\n    }, {\n      type: LogoffRevocationService\n    }, {\n      type: LoginService\n    }, {\n      type: RefreshSessionService\n    }, {\n      type: UrlService\n    }];\n  }, null);\n})(); // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n\n\nfunction createStaticLoader(passedConfig) {\n  return new StsConfigStaticLoader(passedConfig.config);\n} // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n\n\nfunction configurationProviderFactory(oidcConfigService, loader) {\n  const allLoadPromises = Promise.all(loader.loadConfigs());\n\n  const fn = () => allLoadPromises.then(configs => oidcConfigService.withConfigs(configs));\n\n  return fn;\n}\n\nconst PASSED_CONFIG = new InjectionToken('PASSED_CONFIG');\n\nclass AuthModule {\n  static forRoot(passedConfig) {\n    return {\n      ngModule: AuthModule,\n      providers: [// Make the PASSED_CONFIG available through injection\n      {\n        provide: PASSED_CONFIG,\n        useValue: passedConfig\n      }, // Create the loader: Either the one getting passed or a static one\n      (passedConfig === null || passedConfig === void 0 ? void 0 : passedConfig.loader) || {\n        provide: StsConfigLoader,\n        useFactory: createStaticLoader,\n        deps: [PASSED_CONFIG]\n      }, // Load the config when the app starts\n      {\n        provide: APP_INITIALIZER,\n        multi: true,\n        deps: [OidcConfigService, StsConfigLoader, PASSED_CONFIG],\n        useFactory: configurationProviderFactory\n      }, OidcConfigService, PublicEventsService, FlowHelper, ConfigurationProvider, OidcSecurityService, TokenValidationService, PlatformProvider, CheckSessionService, FlowsDataService, FlowsService, SilentRenewService, LogoffRevocationService, UserService, RandomService, HttpBaseService, UrlService, AuthStateService, SigninKeyDataService, StoragePersistenceService, TokenHelperService, LoggerService, IFrameService, EqualityService, LoginService, ParService, AuthWellKnownDataService, AuthWellKnownService, DataService, StateValidationService, ConfigValidationService, CheckAuthService, ResetAuthDataService, ImplicitFlowCallbackService, HistoryJwtKeysCallbackHandlerService, ResponseTypeValidationService, UserCallbackHandlerService, StateValidationCallbackHandlerService, RefreshSessionCallbackHandlerService, RefreshTokenCallbackHandlerService, CodeFlowCallbackHandlerService, ImplicitFlowCallbackHandlerService, ParLoginService, PopUpLoginService, StandardLoginService, AutoLoginService, JsrsAsignReducedService, CurrentUrlService, ClosestMatchingRouteService, DefaultSessionStorageService, BrowserStorageService]\n    };\n  }\n\n}\n\nAuthModule.ɵfac = function AuthModule_Factory(t) {\n  return new (t || AuthModule)();\n};\n\nAuthModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: AuthModule\n});\nAuthModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[CommonModule, HttpClientModule]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule, HttpClientModule],\n      declarations: [],\n      exports: []\n    }]\n  }], null, null);\n})();\n\nclass AutoLoginAllRoutesGuard {\n  constructor(autoLoginService, checkAuthService, loginService, configurationProvider) {\n    this.autoLoginService = autoLoginService;\n    this.checkAuthService = checkAuthService;\n    this.loginService = loginService;\n    this.configurationProvider = configurationProvider;\n  }\n\n  canLoad(route, segments) {\n    const routeToRedirect = segments.join('/');\n    return this.checkAuth(routeToRedirect);\n  }\n\n  canActivate(route, state) {\n    return this.checkAuth(state.url);\n  }\n\n  canActivateChild(route, state) {\n    return this.checkAuth(state.url);\n  }\n\n  checkAuth(url) {\n    const configId = this.getId();\n    return this.checkAuthService.checkAuth().pipe(take(1), map(({\n      isAuthenticated\n    }) => {\n      if (isAuthenticated) {\n        this.autoLoginService.checkSavedRedirectRouteAndNavigate(configId);\n      }\n\n      if (!isAuthenticated) {\n        this.autoLoginService.saveRedirectRoute(configId, url);\n        this.loginService.login(configId);\n      }\n\n      return isAuthenticated;\n    }));\n  }\n\n  getId() {\n    return this.configurationProvider.getOpenIDConfiguration().configId;\n  }\n\n}\n\nAutoLoginAllRoutesGuard.ɵfac = function AutoLoginAllRoutesGuard_Factory(t) {\n  return new (t || AutoLoginAllRoutesGuard)(i0.ɵɵinject(AutoLoginService), i0.ɵɵinject(CheckAuthService), i0.ɵɵinject(LoginService), i0.ɵɵinject(ConfigurationProvider));\n};\n\nAutoLoginAllRoutesGuard.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AutoLoginAllRoutesGuard,\n  factory: AutoLoginAllRoutesGuard.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AutoLoginAllRoutesGuard, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: AutoLoginService\n    }, {\n      type: CheckAuthService\n    }, {\n      type: LoginService\n    }, {\n      type: ConfigurationProvider\n    }];\n  }, null);\n})();\n\nclass AutoLoginPartialRoutesGuard {\n  constructor(autoLoginService, authStateService, loginService, configurationProvider) {\n    this.autoLoginService = autoLoginService;\n    this.authStateService = authStateService;\n    this.loginService = loginService;\n    this.configurationProvider = configurationProvider;\n  }\n\n  canLoad(route, segments) {\n    const routeToRedirect = segments.join('/');\n    return this.checkAuth(routeToRedirect);\n  }\n\n  canActivate(route, state) {\n    return this.checkAuth(state.url);\n  }\n\n  canActivateChild(route, state) {\n    return this.checkAuth(state.url);\n  }\n\n  checkAuth(url) {\n    const configId = this.getId();\n    const isAuthenticated = this.authStateService.areAuthStorageTokensValid(configId);\n\n    if (isAuthenticated) {\n      this.autoLoginService.checkSavedRedirectRouteAndNavigate(configId);\n    }\n\n    if (!isAuthenticated) {\n      this.autoLoginService.saveRedirectRoute(configId, url);\n      this.loginService.login(configId);\n    }\n\n    return isAuthenticated;\n  }\n\n  getId() {\n    return this.configurationProvider.getOpenIDConfiguration().configId;\n  }\n\n}\n\nAutoLoginPartialRoutesGuard.ɵfac = function AutoLoginPartialRoutesGuard_Factory(t) {\n  return new (t || AutoLoginPartialRoutesGuard)(i0.ɵɵinject(AutoLoginService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(LoginService), i0.ɵɵinject(ConfigurationProvider));\n};\n\nAutoLoginPartialRoutesGuard.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AutoLoginPartialRoutesGuard,\n  factory: AutoLoginPartialRoutesGuard.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AutoLoginPartialRoutesGuard, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: AutoLoginService\n    }, {\n      type: AuthStateService\n    }, {\n      type: LoginService\n    }, {\n      type: ConfigurationProvider\n    }];\n  }, null);\n})();\n\nclass AuthInterceptor {\n  constructor(authStateService, configurationProvider, loggerService, closestMatchingRouteService) {\n    this.authStateService = authStateService;\n    this.configurationProvider = configurationProvider;\n    this.loggerService = loggerService;\n    this.closestMatchingRouteService = closestMatchingRouteService;\n  }\n\n  intercept(req, next) {\n    if (!this.configurationProvider.hasAsLeastOneConfig()) {\n      return next.handle(req);\n    }\n\n    const allConfigurations = this.configurationProvider.getAllConfigurations();\n    const allRoutesConfigured = allConfigurations.map(x => x.secureRoutes || []);\n    const allRoutesConfiguredFlat = [].concat.apply([], allRoutesConfigured);\n\n    if (allRoutesConfiguredFlat.length === 0) {\n      const {\n        configId\n      } = allConfigurations[0];\n      this.loggerService.logDebug(configId, `No routes to check configured`);\n      return next.handle(req);\n    }\n\n    const {\n      matchingConfigId,\n      matchingRoute\n    } = this.closestMatchingRouteService.getConfigIdForClosestMatchingRoute(req.url);\n\n    if (!matchingConfigId) {\n      const {\n        configId\n      } = allConfigurations[0];\n      this.loggerService.logDebug(configId, `Did not find any configured route for route ${req.url}`);\n      return next.handle(req);\n    }\n\n    this.loggerService.logDebug(matchingConfigId, `'${req.url}' matches configured route '${matchingRoute}'`);\n    const token = this.authStateService.getAccessToken(matchingConfigId);\n\n    if (!token) {\n      this.loggerService.logDebug(matchingConfigId, `Wanted to add token to ${req.url} but found no token: '${token}'`);\n      return next.handle(req);\n    }\n\n    this.loggerService.logDebug(matchingConfigId, `'${req.url}' matches configured route '${matchingRoute}', adding token`);\n    req = req.clone({\n      headers: req.headers.set('Authorization', 'Bearer ' + token)\n    });\n    return next.handle(req);\n  }\n\n}\n\nAuthInterceptor.ɵfac = function AuthInterceptor_Factory(t) {\n  return new (t || AuthInterceptor)(i0.ɵɵinject(AuthStateService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(LoggerService), i0.ɵɵinject(ClosestMatchingRouteService));\n};\n\nAuthInterceptor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AuthInterceptor,\n  factory: AuthInterceptor.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthInterceptor, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: AuthStateService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: LoggerService\n    }, {\n      type: ClosestMatchingRouteService\n    }];\n  }, null);\n})();\n/**\r\n * Implement this class-interface to create a custom storage.\r\n */\n\n\nclass AbstractSecurityStorage {}\n\nAbstractSecurityStorage.ɵfac = function AbstractSecurityStorage_Factory(t) {\n  return new (t || AbstractSecurityStorage)();\n};\n\nAbstractSecurityStorage.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AbstractSecurityStorage,\n  factory: AbstractSecurityStorage.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AbstractSecurityStorage, [{\n    type: Injectable\n  }], null, null);\n})(); // Public classes.\n\n/*\r\n * Public API Surface of angular-auth-oidc-client\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { AbstractSecurityStorage, AuthInterceptor, AuthModule, AutoLoginAllRoutesGuard, AutoLoginPartialRoutesGuard, EventTypes, LogLevel, LoggerService, OidcConfigService, OidcSecurityService, OpenIdConfigLoader, PASSED_CONFIG, PopUpService, PublicEventsService, StateValidationResult, StsConfigHttpLoader, StsConfigLoader, StsConfigStaticLoader, TokenHelperService, TokenValidationService, ValidationResult, configurationProviderFactory, createStaticLoader };","map":{"version":3,"sources":["C:/repos/git/damienbod/AzureADAuthRazorUiServiceApiCertificate/AngularAzureADMultipleApis/AngularAzureAD/node_modules/angular-auth-oidc-client/fesm2015/angular-auth-oidc-client.js"],"names":["DOCUMENT","isPlatformBrowser","CommonModule","i1","HttpHeaders","HttpParams","HttpErrorResponse","HttpResponse","HttpClientModule","i0","Injectable","Inject","PLATFORM_ID","InjectionToken","APP_INITIALIZER","NgModule","ReplaySubject","BehaviorSubject","throwError","of","timer","Observable","Subject","forkJoin","TimeoutError","distinctUntilChanged","switchMap","retryWhen","catchError","mergeMap","map","retry","tap","concatMap","take","timeout","KJUR","hextob64u","KEYUTIL","i2","HttpBaseService","constructor","http","get","url","params","post","body","ɵfac","HttpClient","ɵprov","type","ConfigurationProvider","configsInternal","hasAsLeastOneConfig","Object","keys","length","hasManyConfigs","setConfig","readyConfig","configId","getOpenIDConfiguration","value","entries","getAllConfigurations","values","NGSW_CUSTOM_PARAM","DataService","httpClient","configurationProvider","token","headers","prepareHeaders","prepareParams","headersParams","set","decodeURIComponent","ngswBypass","EventTypes","LogLevel","LoggerService","logError","message","args","logErrorWithConfig","logErrorWithoutConfig","logWarning","logWarningWithConfig","logWarningWithoutConfig","logDebug","logLevelIsSet","loggingIsTurnedOff","currentLogLevelIsEqualOrSmallerThan","Debug","console","log","warn","Warn","error","logLevelToCompare","logLevel","undefined","None","BrowserStorageService","configProvider","loggerService","read","key","hasStorage","storage","getStorage","storedConfig","JSON","parse","write","stringify","remove","clear","Storage","StoragePersistenceService","browserStorageService","resetStorageFlowData","resetAuthStateInStorage","getAccessToken","getIdToken","_a","id_token","getRefreshToken","refresh_token","getAuthenticationResult","PublicEventsService","notify","fireEvent","next","registerForEvents","asObservable","PARTS_OF_TOKEN","TokenHelperService","getTokenExpirationDate","dataIdToken","hasOwnProperty","Date","toUTCString","date","setUTCSeconds","exp","getHeaderFromToken","encoded","tokenIsValid","getPartOfToken","getPayloadFromToken","getSignatureFromToken","index","partOfToken","extractPartOfToken","result","urlBase64Decode","str","output","replace","Error","decoded","window","atob","Buffer","from","toString","split","c","charCodeAt","slice","join","err","includes","parts","JsrsAsignReducedService","generateCodeChallenge","codeVerifier","hash","crypto","Util","hashString","testData","generateAtHash","accessToken","sha","first128bits","substr","TokenValidationService","tokenHelperService","jsrsAsignReducedService","keyAlgorithms","hasIdTokenExpired","offsetSeconds","validateIdTokenExpNotExpired","decodedIdToken","tokenExpirationDate","tokenExpirationValue","valueOf","nowWithOffset","tokenNotExpired","millisToMinutesAndSeconds","toLocaleTimeString","validateAccessTokenNotExpired","accessTokenExpiresAt","accessTokenExpirationValue","validateRequiredIdToken","validated","validateIdTokenIatMaxOffset","maxOffsetAllowedInSeconds","disableIatOffsetValidation","dateTimeIatIdToken","iat","nowInUtc","diff","maxOffsetAllowedInMilliseconds","validateIdTokenNonce","localNonce","ignoreNonceAfterRefresh","isFromRefreshToken","nonce","refreshTokenNoncePlaceholder","validateIdTokenIss","authWellKnownEndpointsIssuer","iss","validateIdTokenAud","aud","Array","isArray","validateIdTokenAzpExistsIfMoreThanOneAud","azp","validateIdTokenAzpValid","clientId","validateStateFromHashCallback","state","localState","validateSignatureIdToken","idToken","jwtkeys","headerData","kid","alg","jwtKtyToUse","charAt","isValid","keyToValidate","kty","amountOfMatchingKeys","use","jws","JWS","verify","getKey","publicKey","validateIdTokenAtHash","atHash","idTokenAlg","testValue","millis","minutes","Math","floor","seconds","toFixed","DEFAULT_AUTHRESULT","isAuthenticated","allConfigsAuthenticated","AuthStateService","storagePersistenceService","publicEventsService","tokenValidationService","authenticatedInternal$","authenticated$","pipe","setAuthenticatedAndFireEvent","composeAuthenticatedResult","setUnauthenticatedAndFireEvent","configIdToReset","composeUnAuthenticatedResult","updateAndPublishAuthState","authenticationResult","NewAuthenticationResult","setAuthorizationData","authResult","persistAccessTokenExpirationTime","decodeURIComponentSafely","areAuthStorageTokensValid","hasIdTokenExpiredAndRenewCheckIsEnabled","hasAccessTokenExpiredIfExpiryExists","renewTimeBeforeTokenExpiresInSeconds","enableIdTokenExpiredValidationInRenew","tokenToCheck","idTokenExpired","IdTokenExpired","accessTokenExpiresIn","accessTokenHasNotExpired","hasExpired","TokenExpired","expires_in","accessTokenExpiryTime","checkAllConfigsIfTheyAreAuthenticated","configs","every","x","STORAGE_KEY","AutoLoginService","storageService","router","checkSavedRedirectRouteAndNavigate","savedRouteForRedirect","getStoredRedirectRoute","deleteStoredRedirectRoute","navigateByUrl","saveRedirectRoute","Router","UriEncoder","encodeKey","encodeURIComponent","encodeValue","decodeKey","decodeValue","RandomService","doc","createRandom","requiredLength","arr","Uint8Array","getCrypto","getRandomValues","toHex","randomString","dec","characters","Uint32Array","i","defaultView","msCrypto","decorators","FlowsDataService","randomService","createNonce","setNonce","getAuthStateControl","setAuthStateControl","authStateControl","getExistingOrCreateAuthStateControl","setSessionState","sessionState","getCodeVerifier","createCodeVerifier","isSilentRenewRunning","storageObject","getSilentRenewRunningStorageEntry","silentRenewTimeoutInSeconds","timeOutInMilliseconds","dateOfLaunchedProcessUtc","currentDateUtc","toISOString","elapsedTimeInMilliseconds","abs","isProbablyStuck","resetSilentRenewRunning","setSilentRenewRunning","storageEntry","FlowHelper","isCurrentFlowCodeFlow","currentFlowIs","isCurrentFlowAnyImplicitFlow","isCurrentFlowImplicitFlowWithAccessToken","isCurrentFlowImplicitFlowWithoutAccessToken","isCurrentFlowCodeFlowWithRefreshTokens","useRefreshToken","flowTypes","responseType","some","CALLBACK_PARAMS_TO_CHECK","AUTH0_ENDPOINT","UrlService","flowsDataService","flowHelper","getUrlParameter","urlToCheck","name","regex","RegExp","results","exec","isCallbackFromSts","currentUrl","getRefreshSessionSilentRenewUrl","customParams","createUrlCodeFlowWithSilentRenew","createUrlImplicitFlowWithSilentRenew","getAuthorizeParUrl","requestUri","authWellKnownEndPoints","authorizationEndpoint","urlParts","authorizationUrl","existingParams","createHttpParams","append","getAuthorizeUrl","createUrlCodeFlowAuthorize","createUrlImplicitFlowAuthorize","createEndSessionUrl","idTokenHint","customParamsEndSession","isAuth0Endpoint","composeAuth0Endpoint","endSessionEndpoint","authorizationEndSessionUrl","postLogoutRedirectUri","getPostLogoutRedirectUrl","appendCustomParams","assign","createRevocationEndpointBodyAccessToken","getClientId","createRevocationEndpointBodyRefreshToken","getRevocationEndpointUrl","revocationEndpoint","revocationEndpointUrl","createBodyForCodeFlowCodeRequest","code","customTokenParams","silentRenewUrl","getSilentRenewUrl","redirectUrl","getRedirectUrl","createBodyForCodeFlowRefreshTokensRequest","refreshToken","customParamsRefresh","createBodyForParCodeFlowRequest","customParamsRequest","codeChallenge","scope","hdParam","customParamsAuthRequest","createAuthorizeUrl","prompt","customRequestParams","mergedParams","overWriteParam","fromString","encoder","authority","endsWith","postLogoutRedirectUrl","CodeFlowCallbackHandlerService","urlService","dataService","codeFlowCallback","initialCallbackContext","isRenewProcess","jwtKeys","validationResult","existingIdToken","codeFlowCodeRequest","callbackContext","isStateCorrect","authWellknownEndpoints","tokenEndpoint","config","bodyForCodeFlow","customParamsCodeRequest","response","session_state","handleRefreshRetry","errorMessage","errors","ProgressEvent","refreshTokenRetryInSeconds","DEFAULT_USERRESULT","userData","allUserData","UserService","oidcDataService","eventService","userDataInternal$","userData$","getAndPersistUserDataInStore","existingUserDataFromStorage","getUserDataFromStore","haveUserData","setUserDataToStore","renewUserInfoAfterTokenRenew","getUserDataOidcFlowAndSave","sub","publishUserDataIfExists","fireUserDataEvent","resetUserDataInStore","idTokenSub","getIdentityUserData","data","validateUserDataSubIdToken","userInfoEndpoint","userDataSub","passedUserData","composeSingleOrMultipleUserDataObject","UserDataChanged","composeSingleUserDataResult","currentConfigIsToUpdate","alreadySavedUserData","ResetAuthDataService","authStateService","userService","resetAuthorizationData","ImplicitFlowCallbackHandlerService","resetAuthDataService","implicitFlowCallback","isRenewProcessData","location","reduce","resultData","item","shift","ValidationResult","SigninKeyDataService","getSigningKeys","jwksUri","e","handleErrorGetSigningKeys","errorResponse","errMsg","status","statusText","JWT_KEYS","HistoryJwtKeysCallbackHandlerService","signInKeyDataService","callbackHistoryAndResetJwtKeys","historyCleanUpTurnedOn","resetBrowserHistory","handleResultErrorFromCallback","storeSigningKeys","storedJwtKeys","readSigningKeys","SecureTokenServerError","LoginRequired","historyCleanupOff","history","replaceState","document","title","origin","pathname","UserCallbackHandlerService","callbackUser","autoUserInfo","publishAuthState","publishUnauthenticatedState","stateValidationResult","StateValidationResult","authResponseIsValid","NotSet","EqualityService","isStringEqualOrNonOrderedArrayEqual","value1","value2","isNullOrUndefined","oneValueIsStringAndTheOtherIsArray","bothValuesAreStrings","bothValuesAreArrays","arraysHaveEqualContent","areEqual","arraysStrictEqual","bothValuesAreObjects","toLowerCase","valueIsString","valueIsObject","String","arr1","arr2","v","val","StateValidationService","equalityService","getValidatedStateResult","validateState","toReturn","StatesDoNotMatch","handleUnsuccessfulValidation","access_token","issValidationOff","maxIdTokenIatOffsetAllowedInSeconds","SignatureFailed","authNonce","IncorrectNonce","RequiredPropertyMissing","MaxOffsetExpired","issuer","IssDoesNotMatchIssuer","NoAuthWellKnownEndPoints","IncorrectAud","IncorrectAzp","isIdTokenAfterRefreshTokenRequestValid","IncorrectIdTokenClaimsAfterRefresh","Ok","handleSuccessfulValidation","idTokenHeader","at_hash","IncorrectAtHash","newIdToken","disableRefreshIdTokenAuthTimeValidation","auth_time","autoCleanStateAfterAuthentication","StateValidationCallbackHandlerService","stateValidationService","callbackStateValidation","publishUnauthorizedState","RefreshSessionCallbackHandlerService","refreshSessionWithRefreshTokens","stateData","RefreshTokenCallbackHandlerService","refreshTokensRequestTokens","FlowsService","codeFlowCallbackHandlerService","implicitFlowCallbackHandlerService","historyJwtKeysCallbackHandlerService","userHandlerService","stateValidationCallbackHandlerService","refreshSessionCallbackHandlerService","refreshTokenCallbackHandlerService","processCodeFlowCallback","processSilentRenewCodeFlowCallback","firstContext","processImplicitFlowCallback","processRefreshToken","IntervalService","zone","runTokenValidationRunning","stopPeriodicTokenCheck","unsubscribe","startPeriodicTokenCheck","repeatAfterSeconds","millisecondsDelayBetweenTokenCheck","subscriber","intervalId","runOutsideAngular","setInterval","run","clearInterval","NgZone","providedIn","ImplicitFlowCallbackService","flowsService","intervalService","authenticatedImplicitFlowCallback","triggerAuthorizationResultEvent","postLoginRoute","unauthorizedRoute","IFrameService","getExistingIFrame","identifier","iFrameOnParent","getIFrameFromParentWindow","isIFrameElement","iFrameOnSelf","getIFrameFromWindow","addIFrameToWindowBody","sessionIframe","createElement","id","style","display","appendChild","iFrameElement","parent","getElementById","element","HTMLIFrameElement","IFRAME_FOR_CHECK_SESSION_IDENTIFIER","CheckSessionService","iFrameService","checkSessionReceived","lastIFrameRefresh","outstandingMessages","heartBeatInterval","iframeRefreshInterval","checkSessionChangedInternal$","checkSessionChanged$","isCheckSessionConfigured","startCheckSession","start","scheduledHeartBeatRunning","pollServerSession","stop","clearScheduledHeartBeat","serverStateChanged","getExistingIframe","init","now","existingIframe","getOrCreateIframe","checkSessionIframe","contentWindow","observer","onload","complete","pollServerSessionRecur","subscribe","iframeOrigin","URL","postMessage","setTimeout","clearTimeout","messageHandler","existingIFrame","startsWith","source","CheckSessionReceived","bindMessageEventToIframe","iframeMessageEvent","bind","addEventListener","frame","CurrentUrlService","getStateParamFromCurrentUrl","getCurrentUrl","parsedUrl","urlParams","URLSearchParams","search","stateFromUrl","currentUrlHasStateParam","IFRAME_FOR_SILENT_RENEW_IDENTIFIER","SilentRenewService","implicitFlowCallbackService","refreshSessionWithIFrameCompletedInternal$","refreshSessionWithIFrameCompleted$","isSilentRenewConfigured","silentRenew","codeFlowCallbackSilentRenewIframe","errorFromFlow","silentRenewEventHandler","detail","callback$","isCodeFlow","CodeFlowCallbackService","authenticatedCallbackWithCode","CallbackService","codeFlowCallbackService","stsCallbackInternal$","stsCallback$","isCallback","handleCallbackAndFireEvents","currentCallbackUrl","WELL_KNOWN_SUFFIX","AuthWellKnownDataService","getWellKnownEndPointsFromUrl","authWellknownEndpoint","getWellKnownDocument","wellKnownEndpoints","jwks_uri","authorization_endpoint","token_endpoint","userinfo_endpoint","end_session_endpoint","check_session_iframe","revocation_endpoint","introspectionEndpoint","introspection_endpoint","parEndpoint","pushed_authorization_request_endpoint","wellKnownEndpoint","AuthWellKnownService","getAuthWellKnownEndPoints","authWellknownEndpointUrl","alreadySavedWellKnownEndpoints","mappedWellKnownEndpoints","storeWellKnownEndpoints","ConfigLoadingFailed","RefreshSessionIframeService","silentRenewService","rendererFactory","renderer","createRenderer","refreshSessionWithIframe","sendAuthorizeRequestUsingSilentRenew","initSilentRenewRequest","onLoadHandler","removeEventListener","instanceId","random","initDestroyHandler","listen","renewDestroyHandler","dispatchEvent","CustomEvent","RendererFactory2","RefreshSessionRefreshTokenService","MAX_RETRY_ATTEMPTS","RefreshSessionService","authWellKnownService","refreshSessionIframeService","refreshSessionRefreshTokenService","userForceRefreshSession","extraCustomParams","persistCustomParams","forceRefreshSession","customParamsRefreshTokenRequest","startRefreshSession","timeOutTime","timeoutRetryStrategy","_","_b","shouldBeExecuted","errorAttempts","scalingDuration","currentAttempt","PeriodicallyTokenCheckService","startTokenValidationPeriodically","configsWithSilentRenewEnabled","getConfigsWithSilentRenewEnabled","refreshTimeInSeconds","getSmallestRefreshTimeFromConfigs","periodicallyCheck$","objectWithConfigIdsAndRefreshEvent","forEach","getRefreshEvent","objectWithConfigIds","shouldStartRefreshEvent","shouldStartPeriodicallyCheckForConfig","refreshEvent$","createRefreshEventForConfig","SilentRenewStarted","refreshEventWithErrorHandler$","prev","curr","tokenRefreshInSeconds","filter","userDataFromStore","idTokenStillValid","accessTokenHasExpired","PopUpService","STORAGE_IDENTIFIER","resultInternal$","result$","isCurrentlyInPopup","canAccessSessionStorage","popup","sessionStorage","getItem","opener","openPopUp","popupOptions","optionsToPass","getOptions","popUp","open","setItem","listener","event","userClosed","receivedUrl","cleanUp","handle","closed","sendMessageToMainWindow","sendMessage","href","removeItem","close","popupDefaultOptions","width","height","left","top","options","screenLeft","outerWidth","screenTop","outerHeight","navigator","cookieEnabled","CheckAuthService","checkSessionService","currentUrlService","callbackService","refreshSessionService","periodicallyTokenCheckService","popupService","autoLoginService","checkAuth","passedConfigId","stateParamFromUrl","getConfigurationWithUrlState","checkAuthWithConfig","onlyExistingConfig","checkAuthMultiple","composeMultipleLoginResults","allConfigs","allChecks$","checkAuthIncludingServer","loginResponse","loginResponseAfterRefreshSession","startCheckSessionAndValidation","storedState","activeConfig","allOtherConfigs","currentConfigResult","allOtherConfigResults","DEFAULT_CONFIG","usePushedAuthorisationRequests","forbiddenRoute","customParamsEndSessionRequest","eagerLoadAuthWellKnownEndpoints","POSITIVE_VALIDATION_RESULT","messages","level","ensureAuthority","passedConfig","ensureClientId","createIdentifierToCheck","arrayHasDuplicates","array","Set","size","ensureNoDuplicatedConfigsRule","passedConfigs","allIdentifiers","someAreNull","hasDuplicates","ensureRedirectRule","ensureSilentRenewUrlWhenNoRefreshTokenUsed","usesSilentRenew","usesRefreshToken","hasSilentRenewUrl","useOfflineScopeWithSilentRenew","hasRefreshToken","hasSilentRenew","hasOfflineScope","allRules","allMultipleConfigRules","ConfigValidationService","validateConfigs","validateConfigsInternal","validateConfig","validateConfigInternal","allRulesToUse","allValidationResults","rule","overallErrorCount","errorCount","processValidationResultsAndGetErrorCount","allMessages","allErrorMessages","getAllMessagesOfType","allWarnings","acc","concat","PlatformProvider","platformId","isBrowser","DefaultSessionStorageService","OidcConfigService","configValidationService","platformProvider","defaultSessionStorageService","withConfigs","Promise","resolve","createUniqueIds","allHandleConfigPromises","handleConfig","all","reject","usedConfig","prepareConfig","alreadyExistingAuthWellKnownEndpoints","ConfigLoaded","passedAuthWellKnownEndpoints","wellknownEndPoints","configuration","openIdConfigurationInternal","setSpecialCases","setStorage","currentConfig","hasBrowserStorage","OpenIdConfigLoader","StsConfigLoader","StsConfigStaticLoader","loadConfigs","allInstantStaticPromises","singleStaticPromise","StsConfigHttpLoader","configs$","ClosestMatchingRouteService","getConfigIdForClosestMatchingRoute","route","allConfiguredRoutes","getAllConfiguredRoutes","routesWithConfig","allRoutesForConfig","routes","configuredRoute","matchingRoute","matchingConfigId","allConfigurations","secureRoutes","ResponseTypeValidationService","hasConfigValidResponseType","RedirectService","redirectTo","ParService","postParRequest","expiresIn","request_uri","ParLoginService","responseTypeValidationService","redirectService","checkAuthService","parService","loginPar","authOptions","urlHandler","loginWithPopUpPar","PopUpLoginService","loginWithPopUpStandard","authUrl","StandardLoginService","loginStandard","LoginService","parLoginService","popUpLoginService","standardLoginService","login","loginWithPopUp","LogoffRevocationService","logoff","endSessionUrl","getEndSessionUrl","logoffLocal","logoffLocalMultiple","logoffAndRevokeTokens","revokeRefreshToken","revokeAccessToken","accessTok","sendRevokeRequest","refreshTok","OidcSecurityService","logoffRevocationService","loginService","isAuthenticated$","getConfigurations","getConfiguration","getUserData","getPayloadFromIdToken","encode","setState","getState","authorize","authorizeWithPopUp","createStaticLoader","configurationProviderFactory","oidcConfigService","loader","allLoadPromises","fn","then","PASSED_CONFIG","AuthModule","forRoot","ngModule","providers","provide","useValue","useFactory","deps","multi","ɵmod","ɵinj","imports","declarations","exports","AutoLoginAllRoutesGuard","canLoad","segments","routeToRedirect","canActivate","canActivateChild","getId","AutoLoginPartialRoutesGuard","AuthInterceptor","closestMatchingRouteService","intercept","req","allRoutesConfigured","allRoutesConfiguredFlat","apply","clone","AbstractSecurityStorage"],"mappings":"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","sourcesContent":["import { DOCUMENT, isPlatformBrowser, CommonModule } from '@angular/common';\nimport * as i1 from '@angular/common/http';\nimport { HttpHeaders, HttpParams, HttpErrorResponse, HttpResponse, HttpClientModule } from '@angular/common/http';\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject, PLATFORM_ID, InjectionToken, APP_INITIALIZER, NgModule } from '@angular/core';\nimport { ReplaySubject, BehaviorSubject, throwError, of, timer, Observable, Subject, forkJoin, TimeoutError } from 'rxjs';\nimport { distinctUntilChanged, switchMap, retryWhen, catchError, mergeMap, map, retry, tap, concatMap, take, timeout } from 'rxjs/operators';\nimport { KJUR, hextob64u, KEYUTIL } from 'jsrsasign-reduced';\nimport * as i2 from '@angular/router';\n\nclass HttpBaseService {\r\n    constructor(http) {\r\n        this.http = http;\r\n    }\r\n    get(url, params) {\r\n        return this.http.get(url, params);\r\n    }\r\n    post(url, body, params) {\r\n        return this.http.post(url, body, params);\r\n    }\r\n}\r\nHttpBaseService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: HttpBaseService, deps: [{ token: i1.HttpClient }], target: i0.ɵɵFactoryTarget.Injectable });\r\nHttpBaseService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: HttpBaseService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: HttpBaseService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: i1.HttpClient }]; } });\n\nclass ConfigurationProvider {\r\n    constructor() {\r\n        this.configsInternal = {};\r\n    }\r\n    hasAsLeastOneConfig() {\r\n        return Object.keys(this.configsInternal).length > 0;\r\n    }\r\n    hasManyConfigs() {\r\n        return Object.keys(this.configsInternal).length > 1;\r\n    }\r\n    setConfig(readyConfig) {\r\n        const { configId } = readyConfig;\r\n        this.configsInternal[configId] = readyConfig;\r\n    }\r\n    getOpenIDConfiguration(configId) {\r\n        if (!!configId) {\r\n            return this.configsInternal[configId] || null;\r\n        }\r\n        const [, value] = Object.entries(this.configsInternal)[0] || [[null, null]];\r\n        return value || null;\r\n    }\r\n    getAllConfigurations() {\r\n        return Object.values(this.configsInternal);\r\n    }\r\n}\r\nConfigurationProvider.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ConfigurationProvider, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nConfigurationProvider.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ConfigurationProvider });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ConfigurationProvider, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nconst NGSW_CUSTOM_PARAM = 'ngsw-bypass';\r\nclass DataService {\r\n    constructor(httpClient, configurationProvider) {\r\n        this.httpClient = httpClient;\r\n        this.configurationProvider = configurationProvider;\r\n    }\r\n    get(url, configId, token) {\r\n        const headers = this.prepareHeaders(token);\r\n        const params = this.prepareParams(configId);\r\n        return this.httpClient.get(url, {\r\n            headers,\r\n            params,\r\n        });\r\n    }\r\n    post(url, body, configId, headersParams) {\r\n        const headers = headersParams || this.prepareHeaders();\r\n        const params = this.prepareParams(configId);\r\n        return this.httpClient.post(url, body, { headers, params });\r\n    }\r\n    prepareHeaders(token) {\r\n        let headers = new HttpHeaders();\r\n        headers = headers.set('Accept', 'application/json');\r\n        if (!!token) {\r\n            headers = headers.set('Authorization', 'Bearer ' + decodeURIComponent(token));\r\n        }\r\n        return headers;\r\n    }\r\n    prepareParams(configId) {\r\n        let params = new HttpParams();\r\n        const { ngswBypass } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (ngswBypass) {\r\n            params = params.set(NGSW_CUSTOM_PARAM, '');\r\n        }\r\n        return params;\r\n    }\r\n}\r\nDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: DataService, deps: [{ token: HttpBaseService }, { token: ConfigurationProvider }], target: i0.ɵɵFactoryTarget.Injectable });\r\nDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: DataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: DataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: HttpBaseService }, { type: ConfigurationProvider }]; } });\n\n// eslint-disable-next-line no-shadow\r\nvar EventTypes;\r\n(function (EventTypes) {\r\n    /**\r\n     *  This only works in the AppModule Constructor\r\n     */\r\n    EventTypes[EventTypes[\"ConfigLoaded\"] = 0] = \"ConfigLoaded\";\r\n    EventTypes[EventTypes[\"ConfigLoadingFailed\"] = 1] = \"ConfigLoadingFailed\";\r\n    EventTypes[EventTypes[\"CheckSessionReceived\"] = 2] = \"CheckSessionReceived\";\r\n    EventTypes[EventTypes[\"UserDataChanged\"] = 3] = \"UserDataChanged\";\r\n    EventTypes[EventTypes[\"NewAuthenticationResult\"] = 4] = \"NewAuthenticationResult\";\r\n    EventTypes[EventTypes[\"TokenExpired\"] = 5] = \"TokenExpired\";\r\n    EventTypes[EventTypes[\"IdTokenExpired\"] = 6] = \"IdTokenExpired\";\r\n    EventTypes[EventTypes[\"SilentRenewStarted\"] = 7] = \"SilentRenewStarted\";\r\n})(EventTypes || (EventTypes = {}));\n\n// eslint-disable-next-line no-shadow\r\nvar LogLevel;\r\n(function (LogLevel) {\r\n    LogLevel[LogLevel[\"None\"] = 0] = \"None\";\r\n    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\r\n    LogLevel[LogLevel[\"Warn\"] = 2] = \"Warn\";\r\n    LogLevel[LogLevel[\"Error\"] = 3] = \"Error\";\r\n})(LogLevel || (LogLevel = {}));\n\nclass LoggerService {\r\n    constructor(configurationProvider) {\r\n        this.configurationProvider = configurationProvider;\r\n    }\r\n    logError(configId, message, ...args) {\r\n        if (!!configId) {\r\n            this.logErrorWithConfig(configId, message, ...args);\r\n        }\r\n        else {\r\n            this.logErrorWithoutConfig(message, ...args);\r\n        }\r\n    }\r\n    logWarning(configId, message, ...args) {\r\n        if (!!configId) {\r\n            this.logWarningWithConfig(configId, message, ...args);\r\n        }\r\n        else {\r\n            this.logWarningWithoutConfig(message, ...args);\r\n        }\r\n    }\r\n    logDebug(configId, message, ...args) {\r\n        if (!this.logLevelIsSet(configId)) {\r\n            return;\r\n        }\r\n        if (this.loggingIsTurnedOff(configId)) {\r\n            return;\r\n        }\r\n        if (!this.currentLogLevelIsEqualOrSmallerThan(configId, LogLevel.Debug)) {\r\n            return;\r\n        }\r\n        if (!!args && !!args.length) {\r\n            console.log(`[DEBUG] ${configId} - ${message}`, ...args);\r\n        }\r\n        else {\r\n            console.log(`[DEBUG] ${configId} - ${message}`);\r\n        }\r\n    }\r\n    logWarningWithoutConfig(message, ...args) {\r\n        if (!!args && !!args.length) {\r\n            console.warn(`[WARN] - ${message}`, ...args);\r\n        }\r\n        else {\r\n            console.warn(`[WARN] - ${message}`);\r\n        }\r\n    }\r\n    logWarningWithConfig(configId, message, ...args) {\r\n        if (!this.logLevelIsSet(configId)) {\r\n            return;\r\n        }\r\n        if (this.loggingIsTurnedOff(configId)) {\r\n            return;\r\n        }\r\n        if (!this.currentLogLevelIsEqualOrSmallerThan(configId, LogLevel.Warn)) {\r\n            return;\r\n        }\r\n        if (!!args && !!args.length) {\r\n            console.warn(`[WARN] ${configId} - ${message}`, ...args);\r\n        }\r\n        else {\r\n            console.warn(`[WARN] ${configId} - ${message}`);\r\n        }\r\n    }\r\n    logErrorWithConfig(configId, message, ...args) {\r\n        if (this.loggingIsTurnedOff(configId)) {\r\n            return;\r\n        }\r\n        if (!!args && !!args.length) {\r\n            console.error(`[ERROR] ${configId} - ${message}`, ...args);\r\n        }\r\n        else {\r\n            console.error(`[ERROR] ${configId} - ${message}`);\r\n        }\r\n    }\r\n    logErrorWithoutConfig(message, ...args) {\r\n        if (!!args && !!args.length) {\r\n            console.error(`[ERROR] - ${message}`, ...args);\r\n        }\r\n        else {\r\n            console.error(`[ERROR] - ${message}`);\r\n        }\r\n    }\r\n    currentLogLevelIsEqualOrSmallerThan(configId, logLevelToCompare) {\r\n        const { logLevel } = this.configurationProvider.getOpenIDConfiguration(configId) || {};\r\n        return logLevel <= logLevelToCompare;\r\n    }\r\n    logLevelIsSet(configId) {\r\n        const { logLevel } = this.configurationProvider.getOpenIDConfiguration(configId) || {};\r\n        if (logLevel === null) {\r\n            return false;\r\n        }\r\n        if (logLevel === undefined) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    loggingIsTurnedOff(configId) {\r\n        const { logLevel } = this.configurationProvider.getOpenIDConfiguration(configId) || {};\r\n        return logLevel === LogLevel.None;\r\n    }\r\n}\r\nLoggerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: LoggerService, deps: [{ token: ConfigurationProvider }], target: i0.ɵɵFactoryTarget.Injectable });\r\nLoggerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: LoggerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: LoggerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: ConfigurationProvider }]; } });\n\nclass BrowserStorageService {\r\n    constructor(configProvider, loggerService) {\r\n        this.configProvider = configProvider;\r\n        this.loggerService = loggerService;\r\n    }\r\n    read(key, configId) {\r\n        if (!this.hasStorage()) {\r\n            this.loggerService.logDebug(configId, `Wanted to read '${key}' but Storage was undefined`);\r\n            return null;\r\n        }\r\n        const storage = this.getStorage(configId);\r\n        if (!storage) {\r\n            this.loggerService.logDebug(configId, `Wanted to read config for '${configId}' but Storage was falsy`);\r\n            return null;\r\n        }\r\n        const storedConfig = storage.read(configId);\r\n        if (!storedConfig) {\r\n            return null;\r\n        }\r\n        return JSON.parse(storedConfig);\r\n    }\r\n    write(value, configId) {\r\n        if (!this.hasStorage()) {\r\n            this.loggerService.logDebug(configId, `Wanted to write '${value}' but Storage was falsy`);\r\n            return false;\r\n        }\r\n        const storage = this.getStorage(configId);\r\n        if (!storage) {\r\n            this.loggerService.logDebug(configId, `Wanted to write '${value}' but Storage was falsy`);\r\n            return false;\r\n        }\r\n        value = value || null;\r\n        storage.write(configId, JSON.stringify(value));\r\n        return true;\r\n    }\r\n    remove(key, configId) {\r\n        if (!this.hasStorage()) {\r\n            this.loggerService.logDebug(configId, `Wanted to remove '${key}' but Storage was falsy`);\r\n            return false;\r\n        }\r\n        const storage = this.getStorage(configId);\r\n        if (!storage) {\r\n            this.loggerService.logDebug(configId, `Wanted to write '${key}' but Storage was falsy`);\r\n            return false;\r\n        }\r\n        storage.remove(key);\r\n        return true;\r\n    }\r\n    // TODO THIS STORAGE WANTS AN ID BUT CLEARS EVERYTHING\r\n    clear(configId) {\r\n        if (!this.hasStorage()) {\r\n            this.loggerService.logDebug(configId, `Wanted to clear storage but Storage was falsy`);\r\n            return false;\r\n        }\r\n        const storage = this.getStorage(configId);\r\n        if (!storage) {\r\n            this.loggerService.logDebug(configId, `Wanted to clear storage but Storage was falsy`);\r\n            return false;\r\n        }\r\n        storage.clear();\r\n        return true;\r\n    }\r\n    getStorage(configId) {\r\n        const { storage } = this.configProvider.getOpenIDConfiguration(configId) || {};\r\n        return storage;\r\n    }\r\n    hasStorage() {\r\n        return typeof Storage !== 'undefined';\r\n    }\r\n}\r\nBrowserStorageService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: BrowserStorageService, deps: [{ token: ConfigurationProvider }, { token: LoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nBrowserStorageService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: BrowserStorageService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: BrowserStorageService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: ConfigurationProvider }, { type: LoggerService }]; } });\n\nclass StoragePersistenceService {\r\n    constructor(browserStorageService) {\r\n        this.browserStorageService = browserStorageService;\r\n    }\r\n    read(key, configId) {\r\n        const storedConfig = this.browserStorageService.read(key, configId) || {};\r\n        return storedConfig[key];\r\n    }\r\n    write(key, value, configId) {\r\n        const storedConfig = this.browserStorageService.read(key, configId) || {};\r\n        storedConfig[key] = value;\r\n        this.browserStorageService.write(storedConfig, configId);\r\n    }\r\n    remove(key, configId) {\r\n        const storedConfig = this.browserStorageService.read(key, configId) || {};\r\n        delete storedConfig[key];\r\n        this.browserStorageService.write(storedConfig, configId);\r\n    }\r\n    clear(configId) {\r\n        this.browserStorageService.clear(configId);\r\n    }\r\n    resetStorageFlowData(configId) {\r\n        this.remove('session_state', configId);\r\n        this.remove('storageSilentRenewRunning', configId);\r\n        this.remove('codeVerifier', configId);\r\n        this.remove('userData', configId);\r\n        this.remove('storageCustomParamsAuthRequest', configId);\r\n        this.remove('access_token_expires_at', configId);\r\n        this.remove('storageCustomParamsRefresh', configId);\r\n        this.remove('storageCustomParamsEndSession', configId);\r\n    }\r\n    resetAuthStateInStorage(configId) {\r\n        this.remove('authzData', configId);\r\n        this.remove('authnResult', configId);\r\n    }\r\n    getAccessToken(configId) {\r\n        return this.read('authzData', configId);\r\n    }\r\n    getIdToken(configId) {\r\n        var _a;\r\n        return (_a = this.read('authnResult', configId)) === null || _a === void 0 ? void 0 : _a.id_token;\r\n    }\r\n    getRefreshToken(configId) {\r\n        var _a;\r\n        return (_a = this.read('authnResult', configId)) === null || _a === void 0 ? void 0 : _a.refresh_token;\r\n    }\r\n    getAuthenticationResult(configId) {\r\n        return this.read('authnResult', configId);\r\n    }\r\n}\r\nStoragePersistenceService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: StoragePersistenceService, deps: [{ token: BrowserStorageService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nStoragePersistenceService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: StoragePersistenceService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: StoragePersistenceService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: BrowserStorageService }]; } });\n\nclass PublicEventsService {\r\n    constructor() {\r\n        this.notify = new ReplaySubject(1);\r\n    }\r\n    /**\r\n     * Fires a new event.\r\n     *\r\n     * @param type The event type.\r\n     * @param value The event value.\r\n     */\r\n    fireEvent(type, value) {\r\n        this.notify.next({ type, value });\r\n    }\r\n    /**\r\n     * Wires up the event notification observable.\r\n     */\r\n    registerForEvents() {\r\n        return this.notify.asObservable();\r\n    }\r\n}\r\nPublicEventsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PublicEventsService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nPublicEventsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PublicEventsService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PublicEventsService, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nconst PARTS_OF_TOKEN = 3;\r\nclass TokenHelperService {\r\n    constructor(loggerService) {\r\n        this.loggerService = loggerService;\r\n    }\r\n    getTokenExpirationDate(dataIdToken) {\r\n        if (!dataIdToken.hasOwnProperty('exp')) {\r\n            return new Date(new Date().toUTCString());\r\n        }\r\n        const date = new Date(0); // The 0 here is the key, which sets the date to the epoch\r\n        date.setUTCSeconds(dataIdToken.exp);\r\n        return date;\r\n    }\r\n    getHeaderFromToken(token, encoded, configId) {\r\n        if (!this.tokenIsValid(token, configId)) {\r\n            return {};\r\n        }\r\n        return this.getPartOfToken(token, 0, encoded);\r\n    }\r\n    getPayloadFromToken(token, encoded, configId) {\r\n        if (!this.tokenIsValid(token, configId)) {\r\n            return {};\r\n        }\r\n        return this.getPartOfToken(token, 1, encoded);\r\n    }\r\n    getSignatureFromToken(token, encoded, configId) {\r\n        if (!this.tokenIsValid(token, configId)) {\r\n            return {};\r\n        }\r\n        return this.getPartOfToken(token, 2, encoded);\r\n    }\r\n    getPartOfToken(token, index, encoded) {\r\n        const partOfToken = this.extractPartOfToken(token, index);\r\n        if (encoded) {\r\n            return partOfToken;\r\n        }\r\n        const result = this.urlBase64Decode(partOfToken);\r\n        return JSON.parse(result);\r\n    }\r\n    urlBase64Decode(str) {\r\n        let output = str.replace(/-/g, '+').replace(/_/g, '/');\r\n        switch (output.length % 4) {\r\n            case 0:\r\n                break;\r\n            case 2:\r\n                output += '==';\r\n                break;\r\n            case 3:\r\n                output += '=';\r\n                break;\r\n            default:\r\n                throw Error('Illegal base64url string!');\r\n        }\r\n        const decoded = typeof window !== 'undefined' ? window.atob(output) : Buffer.from(output, 'base64').toString('binary');\r\n        try {\r\n            // Going backwards: from byte stream, to percent-encoding, to original string.\r\n            return decodeURIComponent(decoded\r\n                .split('')\r\n                .map((c) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))\r\n                .join(''));\r\n        }\r\n        catch (err) {\r\n            return decoded;\r\n        }\r\n    }\r\n    tokenIsValid(token, configId) {\r\n        if (!token) {\r\n            this.loggerService.logError(configId, `token '${token}' is not valid --> token falsy`);\r\n            return false;\r\n        }\r\n        if (!token.includes('.')) {\r\n            this.loggerService.logError(configId, `token '${token}' is not valid --> no dots included`);\r\n            return false;\r\n        }\r\n        const parts = token.split('.');\r\n        if (parts.length !== PARTS_OF_TOKEN) {\r\n            this.loggerService.logError(configId, `token '${token}' is not valid --> token has to have exactly ${PARTS_OF_TOKEN - 1} dots`);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    extractPartOfToken(token, index) {\r\n        return token.split('.')[index];\r\n    }\r\n}\r\nTokenHelperService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: TokenHelperService, deps: [{ token: LoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nTokenHelperService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: TokenHelperService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: TokenHelperService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }]; } });\n\nclass JsrsAsignReducedService {\r\n    generateCodeChallenge(codeVerifier) {\r\n        const hash = KJUR.crypto.Util.hashString(codeVerifier, 'sha256');\r\n        const testData = hextob64u(hash);\r\n        return testData;\r\n    }\r\n    generateAtHash(accessToken, sha) {\r\n        const hash = KJUR.crypto.Util.hashString(accessToken, sha);\r\n        const first128bits = hash.substr(0, hash.length / 2);\r\n        const testData = hextob64u(first128bits);\r\n        return testData;\r\n    }\r\n}\r\nJsrsAsignReducedService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: JsrsAsignReducedService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nJsrsAsignReducedService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: JsrsAsignReducedService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: JsrsAsignReducedService, decorators: [{\r\n            type: Injectable\r\n        }] });\n\n// http://openid.net/specs/openid-connect-implicit-1_0.html\r\n// id_token\r\n// id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)\r\n// MUST exactly match the value of the iss (issuer) Claim.\r\n//\r\n// id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified\r\n// by the iss (issuer) Claim as an audience.The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience,\r\n// or if it contains additional audiences not trusted by the Client.\r\n//\r\n// id_token C3: If the ID Token contains multiple audiences, the Client SHOULD verify that an azp Claim is present.\r\n//\r\n// id_token C4: If an azp (authorized party) Claim is present, the Client SHOULD verify that its client_id is the Claim Value.\r\n//\r\n// id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the\r\n// alg Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.\r\n//\r\n// id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the OpenID Connect\r\n// Core 1.0\r\n// [OpenID.Core] specification.\r\n//\r\n// id_token C7: The current time MUST be before the time represented by the exp Claim (possibly allowing for some small leeway to account\r\n// for clock skew).\r\n//\r\n// id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,\r\n// limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.\r\n//\r\n// id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one that was sent\r\n// in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.The precise method for detecting replay attacks\r\n// is Client specific.\r\n//\r\n// id_token C10: If the acr Claim was requested, the Client SHOULD check that the asserted Claim Value is appropriate.\r\n// The meaning and processing of acr Claim Values is out of scope for this document.\r\n//\r\n// id_token C11: When a max_age request is made, the Client SHOULD check the auth_time Claim value and request re- authentication\r\n// if it determines too much time has elapsed since the last End- User authentication.\r\n// Access Token Validation\r\n// access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]\r\n// for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.\r\n// access_token C2: Take the left- most half of the hash and base64url- encode it.\r\n// access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash is present\r\n// in the ID Token.\r\nclass TokenValidationService {\r\n    constructor(tokenHelperService, loggerService, jsrsAsignReducedService) {\r\n        this.tokenHelperService = tokenHelperService;\r\n        this.loggerService = loggerService;\r\n        this.jsrsAsignReducedService = jsrsAsignReducedService;\r\n        this.keyAlgorithms = ['HS256', 'HS384', 'HS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'PS256', 'PS384', 'PS512'];\r\n    }\r\n    // id_token C7: The current time MUST be before the time represented by the exp Claim\r\n    // (possibly allowing for some small leeway to account for clock skew).\r\n    hasIdTokenExpired(token, configId, offsetSeconds) {\r\n        const decoded = this.tokenHelperService.getPayloadFromToken(token, false, configId);\r\n        return !this.validateIdTokenExpNotExpired(decoded, configId, offsetSeconds);\r\n    }\r\n    // id_token C7: The current time MUST be before the time represented by the exp Claim\r\n    // (possibly allowing for some small leeway to account for clock skew).\r\n    validateIdTokenExpNotExpired(decodedIdToken, configId, offsetSeconds) {\r\n        const tokenExpirationDate = this.tokenHelperService.getTokenExpirationDate(decodedIdToken);\r\n        offsetSeconds = offsetSeconds || 0;\r\n        if (!tokenExpirationDate) {\r\n            return false;\r\n        }\r\n        const tokenExpirationValue = tokenExpirationDate.valueOf();\r\n        const nowWithOffset = new Date(new Date().toUTCString()).valueOf() + offsetSeconds * 1000;\r\n        const tokenNotExpired = tokenExpirationValue > nowWithOffset;\r\n        this.loggerService.logDebug(configId, `Has idToken expired: ${!tokenNotExpired} --> expires in ${this.millisToMinutesAndSeconds(tokenExpirationValue - nowWithOffset)} , ${new Date(tokenExpirationValue).toLocaleTimeString()} > ${new Date(nowWithOffset).toLocaleTimeString()}`);\r\n        // Token not expired?\r\n        return tokenNotExpired;\r\n    }\r\n    validateAccessTokenNotExpired(accessTokenExpiresAt, configId, offsetSeconds) {\r\n        // value is optional, so if it does not exist, then it has not expired\r\n        if (!accessTokenExpiresAt) {\r\n            return true;\r\n        }\r\n        offsetSeconds = offsetSeconds || 0;\r\n        const accessTokenExpirationValue = accessTokenExpiresAt.valueOf();\r\n        const nowWithOffset = new Date(new Date().toUTCString()).valueOf() + offsetSeconds * 1000;\r\n        const tokenNotExpired = accessTokenExpirationValue > nowWithOffset;\r\n        this.loggerService.logDebug(configId, `Has accessToken expired: ${!tokenNotExpired} --> expires in ${this.millisToMinutesAndSeconds(accessTokenExpirationValue - nowWithOffset)} , ${new Date(accessTokenExpirationValue).toLocaleTimeString()} > ${new Date(nowWithOffset).toLocaleTimeString()}`);\r\n        // access token not expired?\r\n        return tokenNotExpired;\r\n    }\r\n    // iss\r\n    // REQUIRED. Issuer Identifier for the Issuer of the response.The iss value is a case-sensitive URL using the\r\n    // https scheme that contains scheme, host,\r\n    // and optionally, port number and path components and no query or fragment components.\r\n    //\r\n    // sub\r\n    // REQUIRED. Subject Identifier.Locally unique and never reassigned identifier within the Issuer for the End- User,\r\n    // which is intended to be consumed by the Client, e.g., 24400320 or AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4.\r\n    // It MUST NOT exceed 255 ASCII characters in length.The sub value is a case-sensitive string.\r\n    //\r\n    // aud\r\n    // REQUIRED. Audience(s) that this ID Token is intended for. It MUST contain the OAuth 2.0 client_id of the Relying Party as an\r\n    // audience value.\r\n    // It MAY also contain identifiers for other audiences.In the general case, the aud value is an array of case-sensitive strings.\r\n    // In the common special case when there is one audience, the aud value MAY be a single case-sensitive string.\r\n    //\r\n    // exp\r\n    // REQUIRED. Expiration time on or after which the ID Token MUST NOT be accepted for processing.\r\n    // The processing of this parameter requires that the current date/ time MUST be before the expiration date/ time listed in the value.\r\n    // Implementers MAY provide for some small leeway, usually no more than a few minutes, to account for clock skew.\r\n    // Its value is a JSON [RFC7159] number representing the number of seconds from 1970- 01 - 01T00: 00:00Z as measured in UTC until\r\n    // the date/ time.\r\n    // See RFC 3339 [RFC3339] for details regarding date/ times in general and UTC in particular.\r\n    //\r\n    // iat\r\n    // REQUIRED. Time at which the JWT was issued. Its value is a JSON number representing the number of seconds from\r\n    // 1970- 01 - 01T00: 00: 00Z as measured\r\n    // in UTC until the date/ time.\r\n    validateRequiredIdToken(dataIdToken, configId) {\r\n        let validated = true;\r\n        if (!dataIdToken.hasOwnProperty('iss')) {\r\n            validated = false;\r\n            this.loggerService.logWarning(configId, 'iss is missing, this is required in the id_token');\r\n        }\r\n        if (!dataIdToken.hasOwnProperty('sub')) {\r\n            validated = false;\r\n            this.loggerService.logWarning(configId, 'sub is missing, this is required in the id_token');\r\n        }\r\n        if (!dataIdToken.hasOwnProperty('aud')) {\r\n            validated = false;\r\n            this.loggerService.logWarning(configId, 'aud is missing, this is required in the id_token');\r\n        }\r\n        if (!dataIdToken.hasOwnProperty('exp')) {\r\n            validated = false;\r\n            this.loggerService.logWarning(configId, 'exp is missing, this is required in the id_token');\r\n        }\r\n        if (!dataIdToken.hasOwnProperty('iat')) {\r\n            validated = false;\r\n            this.loggerService.logWarning(configId, 'iat is missing, this is required in the id_token');\r\n        }\r\n        return validated;\r\n    }\r\n    // id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,\r\n    // limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.\r\n    validateIdTokenIatMaxOffset(dataIdToken, maxOffsetAllowedInSeconds, disableIatOffsetValidation, configId) {\r\n        if (disableIatOffsetValidation) {\r\n            return true;\r\n        }\r\n        if (!dataIdToken.hasOwnProperty('iat')) {\r\n            return false;\r\n        }\r\n        const dateTimeIatIdToken = new Date(0); // The 0 here is the key, which sets the date to the epoch\r\n        dateTimeIatIdToken.setUTCSeconds(dataIdToken.iat);\r\n        maxOffsetAllowedInSeconds = maxOffsetAllowedInSeconds || 0;\r\n        const nowInUtc = new Date(new Date().toUTCString());\r\n        const diff = nowInUtc.valueOf() - dateTimeIatIdToken.valueOf();\r\n        const maxOffsetAllowedInMilliseconds = maxOffsetAllowedInSeconds * 1000;\r\n        this.loggerService.logDebug(configId, `validate id token iat max offset ${diff} < ${maxOffsetAllowedInMilliseconds}`);\r\n        if (diff > 0) {\r\n            return diff < maxOffsetAllowedInMilliseconds;\r\n        }\r\n        return -diff < maxOffsetAllowedInMilliseconds;\r\n    }\r\n    // id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one\r\n    // that was sent in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.\r\n    // The precise method for detecting replay attacks is Client specific.\r\n    // However the nonce claim SHOULD not be present for the refresh_token grant type\r\n    // https://bitbucket.org/openid/connect/issues/1025/ambiguity-with-how-nonce-is-handled-on\r\n    // The current spec is ambiguous and KeyCloak does send it.\r\n    validateIdTokenNonce(dataIdToken, localNonce, ignoreNonceAfterRefresh, configId) {\r\n        const isFromRefreshToken = (dataIdToken.nonce === undefined || ignoreNonceAfterRefresh) && localNonce === TokenValidationService.refreshTokenNoncePlaceholder;\r\n        if (!isFromRefreshToken && dataIdToken.nonce !== localNonce) {\r\n            this.loggerService.logDebug(configId, 'Validate_id_token_nonce failed, dataIdToken.nonce: ' + dataIdToken.nonce + ' local_nonce:' + localNonce);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    // id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)\r\n    // MUST exactly match the value of the iss (issuer) Claim.\r\n    validateIdTokenIss(dataIdToken, authWellKnownEndpointsIssuer, configId) {\r\n        if (dataIdToken.iss !== authWellKnownEndpointsIssuer) {\r\n            this.loggerService.logDebug(configId, 'Validate_id_token_iss failed, dataIdToken.iss: ' +\r\n                dataIdToken.iss +\r\n                ' authWellKnownEndpoints issuer:' +\r\n                authWellKnownEndpointsIssuer);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    // id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified\r\n    // by the iss (issuer) Claim as an audience.\r\n    // The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience, or if it contains additional audiences\r\n    // not trusted by the Client.\r\n    validateIdTokenAud(dataIdToken, aud, configId) {\r\n        if (Array.isArray(dataIdToken.aud)) {\r\n            const result = dataIdToken.aud.includes(aud);\r\n            if (!result) {\r\n                this.loggerService.logDebug(configId, 'Validate_id_token_aud array failed, dataIdToken.aud: ' + dataIdToken.aud + ' client_id:' + aud);\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n        else if (dataIdToken.aud !== aud) {\r\n            this.loggerService.logDebug(configId, 'Validate_id_token_aud failed, dataIdToken.aud: ' + dataIdToken.aud + ' client_id:' + aud);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    validateIdTokenAzpExistsIfMoreThanOneAud(dataIdToken) {\r\n        if (!dataIdToken) {\r\n            return false;\r\n        }\r\n        if (Array.isArray(dataIdToken.aud) && dataIdToken.aud.length > 1 && !dataIdToken.azp) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    // If an azp (authorized party) Claim is present, the Client SHOULD verify that its client_id is the Claim Value.\r\n    validateIdTokenAzpValid(dataIdToken, clientId) {\r\n        if (!(dataIdToken === null || dataIdToken === void 0 ? void 0 : dataIdToken.azp)) {\r\n            return true;\r\n        }\r\n        if (dataIdToken.azp === clientId) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    validateStateFromHashCallback(state, localState, configId) {\r\n        if (state !== localState) {\r\n            this.loggerService.logDebug(configId, 'ValidateStateFromHashCallback failed, state: ' + state + ' local_state:' + localState);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    // id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the alg\r\n    // Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.\r\n    // id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the\r\n    // OpenID Connect Core 1.0 [OpenID.Core] specification.\r\n    validateSignatureIdToken(idToken, jwtkeys, configId) {\r\n        if (!jwtkeys || !jwtkeys.keys) {\r\n            return false;\r\n        }\r\n        const headerData = this.tokenHelperService.getHeaderFromToken(idToken, false, configId);\r\n        if (Object.keys(headerData).length === 0 && headerData.constructor === Object) {\r\n            this.loggerService.logWarning(configId, 'id token has no header data');\r\n            return false;\r\n        }\r\n        const kid = headerData.kid;\r\n        const alg = headerData.alg;\r\n        if (!this.keyAlgorithms.includes(alg)) {\r\n            this.loggerService.logWarning(configId, 'alg not supported', alg);\r\n            return false;\r\n        }\r\n        let jwtKtyToUse = 'RSA';\r\n        if (alg.charAt(0) === 'E') {\r\n            jwtKtyToUse = 'EC';\r\n        }\r\n        let isValid = false;\r\n        // No kid in the Jose header\r\n        if (!kid) {\r\n            let keyToValidate;\r\n            // If only one key, use it\r\n            if (jwtkeys.keys.length === 1 && jwtkeys.keys[0].kty === jwtKtyToUse) {\r\n                keyToValidate = jwtkeys.keys[0];\r\n            }\r\n            else {\r\n                // More than one key\r\n                // Make sure there's exactly 1 key candidate\r\n                // kty \"RSA\" and \"EC\" uses \"sig\"\r\n                let amountOfMatchingKeys = 0;\r\n                for (const key of jwtkeys.keys) {\r\n                    if (key.kty === jwtKtyToUse && key.use === 'sig') {\r\n                        amountOfMatchingKeys++;\r\n                        keyToValidate = key;\r\n                    }\r\n                }\r\n                if (amountOfMatchingKeys > 1) {\r\n                    this.loggerService.logWarning(configId, 'no ID Token kid claim in JOSE header and multiple supplied in jwks_uri');\r\n                    return false;\r\n                }\r\n            }\r\n            if (!keyToValidate) {\r\n                this.loggerService.logWarning(configId, 'no keys found, incorrect Signature, validation failed for id_token');\r\n                return false;\r\n            }\r\n            isValid = KJUR.jws.JWS.verify(idToken, KEYUTIL.getKey(keyToValidate), [alg]);\r\n            if (!isValid) {\r\n                this.loggerService.logWarning(configId, 'incorrect Signature, validation failed for id_token');\r\n            }\r\n            return isValid;\r\n        }\r\n        else {\r\n            // kid in the Jose header of id_token\r\n            for (const key of jwtkeys.keys) {\r\n                if (key.kid === kid) {\r\n                    const publicKey = KEYUTIL.getKey(key);\r\n                    isValid = KJUR.jws.JWS.verify(idToken, publicKey, [alg]);\r\n                    if (!isValid) {\r\n                        this.loggerService.logWarning(configId, 'incorrect Signature, validation failed for id_token');\r\n                    }\r\n                    return isValid;\r\n                }\r\n            }\r\n        }\r\n        return isValid;\r\n    }\r\n    // Accepts ID Token without 'kid' claim in JOSE header if only one JWK supplied in 'jwks_url'\r\n    //// private validate_no_kid_in_header_only_one_allowed_in_jwtkeys(header_data: any, jwtkeys: any): boolean {\r\n    ////    this.oidcSecurityCommon.logDebug('amount of jwtkeys.keys: ' + jwtkeys.keys.length);\r\n    ////    if (!header_data.hasOwnProperty('kid')) {\r\n    ////        // no kid defined in Jose header\r\n    ////        if (jwtkeys.keys.length != 1) {\r\n    ////            this.oidcSecurityCommon.logDebug('jwtkeys.keys.length != 1 and no kid in header');\r\n    ////            return false;\r\n    ////        }\r\n    ////    }\r\n    ////    return true;\r\n    //// }\r\n    // Access Token Validation\r\n    // access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]\r\n    // for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.\r\n    // access_token C2: Take the left- most half of the hash and base64url- encode it.\r\n    // access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash\r\n    // is present in the ID Token.\r\n    validateIdTokenAtHash(accessToken, atHash, idTokenAlg, configId) {\r\n        this.loggerService.logDebug(configId, 'at_hash from the server:' + atHash);\r\n        // 'sha256' 'sha384' 'sha512'\r\n        let sha = 'sha256';\r\n        if (idTokenAlg.includes('384')) {\r\n            sha = 'sha384';\r\n        }\r\n        else if (idTokenAlg.includes('512')) {\r\n            sha = 'sha512';\r\n        }\r\n        const testData = this.jsrsAsignReducedService.generateAtHash('' + accessToken, sha);\r\n        this.loggerService.logDebug(configId, 'at_hash client validation not decoded:' + testData);\r\n        if (testData === atHash) {\r\n            return true; // isValid;\r\n        }\r\n        else {\r\n            const testValue = this.jsrsAsignReducedService.generateAtHash('' + decodeURIComponent(accessToken), sha);\r\n            this.loggerService.logDebug(configId, '-gen access--' + testValue);\r\n            if (testValue === atHash) {\r\n                return true; // isValid\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    millisToMinutesAndSeconds(millis) {\r\n        const minutes = Math.floor(millis / 60000);\r\n        const seconds = ((millis % 60000) / 1000).toFixed(0);\r\n        return minutes + ':' + (+seconds < 10 ? '0' : '') + seconds;\r\n    }\r\n}\r\nTokenValidationService.refreshTokenNoncePlaceholder = '--RefreshToken--';\r\nTokenValidationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: TokenValidationService, deps: [{ token: TokenHelperService }, { token: LoggerService }, { token: JsrsAsignReducedService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nTokenValidationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: TokenValidationService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: TokenValidationService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: TokenHelperService }, { type: LoggerService }, { type: JsrsAsignReducedService }]; } });\n\nconst DEFAULT_AUTHRESULT = { isAuthenticated: false, allConfigsAuthenticated: [] };\r\nclass AuthStateService {\r\n    constructor(storagePersistenceService, loggerService, publicEventsService, configurationProvider, tokenValidationService) {\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.loggerService = loggerService;\r\n        this.publicEventsService = publicEventsService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.tokenValidationService = tokenValidationService;\r\n        this.authenticatedInternal$ = new BehaviorSubject(DEFAULT_AUTHRESULT);\r\n    }\r\n    get authenticated$() {\r\n        return this.authenticatedInternal$.asObservable().pipe(distinctUntilChanged());\r\n    }\r\n    setAuthenticatedAndFireEvent() {\r\n        const result = this.composeAuthenticatedResult();\r\n        this.authenticatedInternal$.next(result);\r\n    }\r\n    setUnauthenticatedAndFireEvent(configIdToReset) {\r\n        this.storagePersistenceService.resetAuthStateInStorage(configIdToReset);\r\n        const result = this.composeUnAuthenticatedResult();\r\n        this.authenticatedInternal$.next(result);\r\n    }\r\n    updateAndPublishAuthState(authenticationResult) {\r\n        this.publicEventsService.fireEvent(EventTypes.NewAuthenticationResult, authenticationResult);\r\n    }\r\n    setAuthorizationData(accessToken, authResult, configId) {\r\n        this.loggerService.logDebug(configId, `storing the accessToken '${accessToken}'`);\r\n        this.storagePersistenceService.write('authzData', accessToken, configId);\r\n        this.persistAccessTokenExpirationTime(authResult, configId);\r\n        this.setAuthenticatedAndFireEvent();\r\n    }\r\n    getAccessToken(configId) {\r\n        if (!this.isAuthenticated(configId)) {\r\n            return null;\r\n        }\r\n        const token = this.storagePersistenceService.getAccessToken(configId);\r\n        return this.decodeURIComponentSafely(token);\r\n    }\r\n    getIdToken(configId) {\r\n        if (!this.isAuthenticated(configId)) {\r\n            return null;\r\n        }\r\n        const token = this.storagePersistenceService.getIdToken(configId);\r\n        return this.decodeURIComponentSafely(token);\r\n    }\r\n    getRefreshToken(configId) {\r\n        if (!this.isAuthenticated(configId)) {\r\n            return null;\r\n        }\r\n        const token = this.storagePersistenceService.getRefreshToken(configId);\r\n        return this.decodeURIComponentSafely(token);\r\n    }\r\n    getAuthenticationResult(configId) {\r\n        if (!this.isAuthenticated(configId)) {\r\n            return null;\r\n        }\r\n        return this.storagePersistenceService.getAuthenticationResult(configId);\r\n    }\r\n    areAuthStorageTokensValid(configId) {\r\n        if (!this.isAuthenticated(configId)) {\r\n            return false;\r\n        }\r\n        if (this.hasIdTokenExpiredAndRenewCheckIsEnabled(configId)) {\r\n            this.loggerService.logDebug(configId, 'persisted idToken is expired');\r\n            return false;\r\n        }\r\n        if (this.hasAccessTokenExpiredIfExpiryExists(configId)) {\r\n            this.loggerService.logDebug(configId, 'persisted accessToken is expired');\r\n            return false;\r\n        }\r\n        this.loggerService.logDebug(configId, 'persisted idToken and accessToken are valid');\r\n        return true;\r\n    }\r\n    hasIdTokenExpiredAndRenewCheckIsEnabled(configId) {\r\n        const { renewTimeBeforeTokenExpiresInSeconds, enableIdTokenExpiredValidationInRenew } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!enableIdTokenExpiredValidationInRenew) {\r\n            return false;\r\n        }\r\n        const tokenToCheck = this.storagePersistenceService.getIdToken(configId);\r\n        const idTokenExpired = this.tokenValidationService.hasIdTokenExpired(tokenToCheck, configId, renewTimeBeforeTokenExpiresInSeconds);\r\n        if (idTokenExpired) {\r\n            this.publicEventsService.fireEvent(EventTypes.IdTokenExpired, idTokenExpired);\r\n        }\r\n        return idTokenExpired;\r\n    }\r\n    hasAccessTokenExpiredIfExpiryExists(configId) {\r\n        const { renewTimeBeforeTokenExpiresInSeconds } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        const accessTokenExpiresIn = this.storagePersistenceService.read('access_token_expires_at', configId);\r\n        const accessTokenHasNotExpired = this.tokenValidationService.validateAccessTokenNotExpired(accessTokenExpiresIn, configId, renewTimeBeforeTokenExpiresInSeconds);\r\n        const hasExpired = !accessTokenHasNotExpired;\r\n        if (hasExpired) {\r\n            this.publicEventsService.fireEvent(EventTypes.TokenExpired, hasExpired);\r\n        }\r\n        return hasExpired;\r\n    }\r\n    isAuthenticated(configId) {\r\n        return !!this.storagePersistenceService.getAccessToken(configId) && !!this.storagePersistenceService.getIdToken(configId);\r\n    }\r\n    decodeURIComponentSafely(token) {\r\n        if (token) {\r\n            return decodeURIComponent(token);\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    }\r\n    persistAccessTokenExpirationTime(authResult, configId) {\r\n        if (authResult === null || authResult === void 0 ? void 0 : authResult.expires_in) {\r\n            const accessTokenExpiryTime = new Date(new Date().toUTCString()).valueOf() + authResult.expires_in * 1000;\r\n            this.storagePersistenceService.write('access_token_expires_at', accessTokenExpiryTime, configId);\r\n        }\r\n    }\r\n    composeAuthenticatedResult() {\r\n        if (!this.configurationProvider.hasManyConfigs()) {\r\n            const { configId } = this.configurationProvider.getOpenIDConfiguration();\r\n            return { isAuthenticated: true, allConfigsAuthenticated: [{ configId, isAuthenticated: true }] };\r\n        }\r\n        return this.checkAllConfigsIfTheyAreAuthenticated();\r\n    }\r\n    composeUnAuthenticatedResult() {\r\n        if (!this.configurationProvider.hasManyConfigs()) {\r\n            const { configId } = this.configurationProvider.getOpenIDConfiguration();\r\n            return { isAuthenticated: false, allConfigsAuthenticated: [{ configId, isAuthenticated: false }] };\r\n        }\r\n        return this.checkAllConfigsIfTheyAreAuthenticated();\r\n    }\r\n    checkAllConfigsIfTheyAreAuthenticated() {\r\n        const configs = this.configurationProvider.getAllConfigurations();\r\n        const allConfigsAuthenticated = configs.map(({ configId }) => ({\r\n            configId,\r\n            isAuthenticated: this.isAuthenticated(configId),\r\n        }));\r\n        const isAuthenticated = allConfigsAuthenticated.every((x) => !!x.isAuthenticated);\r\n        return { allConfigsAuthenticated, isAuthenticated };\r\n    }\r\n}\r\nAuthStateService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthStateService, deps: [{ token: StoragePersistenceService }, { token: LoggerService }, { token: PublicEventsService }, { token: ConfigurationProvider }, { token: TokenValidationService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAuthStateService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthStateService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthStateService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: LoggerService }, { type: PublicEventsService }, { type: ConfigurationProvider }, { type: TokenValidationService }]; } });\n\nconst STORAGE_KEY = 'redirect';\r\nclass AutoLoginService {\r\n    constructor(storageService, router) {\r\n        this.storageService = storageService;\r\n        this.router = router;\r\n    }\r\n    checkSavedRedirectRouteAndNavigate(configId) {\r\n        const savedRouteForRedirect = this.getStoredRedirectRoute(configId);\r\n        if (savedRouteForRedirect) {\r\n            this.deleteStoredRedirectRoute(configId);\r\n            this.router.navigateByUrl(savedRouteForRedirect);\r\n        }\r\n    }\r\n    /**\r\n     * Saves the redirect URL to storage.\r\n     *\r\n     * @param url The redirect URL to save.\r\n     */\r\n    saveRedirectRoute(configId, url) {\r\n        this.storageService.write(STORAGE_KEY, url, configId);\r\n    }\r\n    /**\r\n     * Gets the stored redirect URL from storage.\r\n     */\r\n    getStoredRedirectRoute(configId) {\r\n        return this.storageService.read(STORAGE_KEY, configId);\r\n    }\r\n    /**\r\n     * Removes the redirect URL from storage.\r\n     */\r\n    deleteStoredRedirectRoute(configId) {\r\n        this.storageService.remove(STORAGE_KEY, configId);\r\n    }\r\n}\r\nAutoLoginService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AutoLoginService, deps: [{ token: StoragePersistenceService }, { token: i2.Router }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAutoLoginService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AutoLoginService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AutoLoginService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: i2.Router }]; } });\n\nclass UriEncoder {\r\n    encodeKey(key) {\r\n        return encodeURIComponent(key);\r\n    }\r\n    encodeValue(value) {\r\n        return encodeURIComponent(value);\r\n    }\r\n    decodeKey(key) {\r\n        return decodeURIComponent(key);\r\n    }\r\n    decodeValue(value) {\r\n        return decodeURIComponent(value);\r\n    }\r\n}\n\nclass RandomService {\r\n    constructor(doc, loggerService) {\r\n        this.doc = doc;\r\n        this.loggerService = loggerService;\r\n    }\r\n    createRandom(requiredLength, configId) {\r\n        if (requiredLength <= 0) {\r\n            return '';\r\n        }\r\n        if (requiredLength > 0 && requiredLength < 7) {\r\n            this.loggerService.logWarning(configId, `RandomService called with ${requiredLength} but 7 chars is the minimum, returning 10 chars`);\r\n            requiredLength = 10;\r\n        }\r\n        const length = requiredLength - 6;\r\n        const arr = new Uint8Array(Math.floor((length || length) / 2));\r\n        if (this.getCrypto()) {\r\n            this.getCrypto().getRandomValues(arr);\r\n        }\r\n        return Array.from(arr, this.toHex).join('') + this.randomString(7);\r\n    }\r\n    toHex(dec) {\r\n        return ('0' + dec.toString(16)).substr(-2);\r\n    }\r\n    randomString(length) {\r\n        let result = '';\r\n        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\r\n        const values = new Uint32Array(length);\r\n        if (this.getCrypto()) {\r\n            this.getCrypto().getRandomValues(values);\r\n            for (let i = 0; i < length; i++) {\r\n                result += characters[values[i] % characters.length];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    getCrypto() {\r\n        // support for IE,  (window.crypto || window.msCrypto)\r\n        return this.doc.defaultView.crypto || this.doc.defaultView.msCrypto;\r\n    }\r\n}\r\nRandomService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RandomService, deps: [{ token: DOCUMENT }, { token: LoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRandomService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RandomService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RandomService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }, { type: LoggerService }]; } });\n\nclass FlowsDataService {\r\n    constructor(storagePersistenceService, randomService, configurationProvider, loggerService) {\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.randomService = randomService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.loggerService = loggerService;\r\n    }\r\n    createNonce(configId) {\r\n        const nonce = this.randomService.createRandom(40, configId);\r\n        this.loggerService.logDebug(configId, 'Nonce created. nonce:' + nonce);\r\n        this.setNonce(nonce, configId);\r\n        return nonce;\r\n    }\r\n    setNonce(nonce, configId) {\r\n        this.storagePersistenceService.write('authNonce', nonce, configId);\r\n    }\r\n    getAuthStateControl(configId) {\r\n        return this.storagePersistenceService.read('authStateControl', configId);\r\n    }\r\n    setAuthStateControl(authStateControl, configId) {\r\n        this.storagePersistenceService.write('authStateControl', authStateControl, configId);\r\n    }\r\n    getExistingOrCreateAuthStateControl(configId) {\r\n        let state = this.storagePersistenceService.read('authStateControl', configId);\r\n        if (!state) {\r\n            state = this.randomService.createRandom(40, configId);\r\n            this.storagePersistenceService.write('authStateControl', state, configId);\r\n        }\r\n        return state;\r\n    }\r\n    setSessionState(sessionState, configId) {\r\n        this.storagePersistenceService.write('session_state', sessionState, configId);\r\n    }\r\n    resetStorageFlowData(configId) {\r\n        this.storagePersistenceService.resetStorageFlowData(configId);\r\n    }\r\n    getCodeVerifier(configId) {\r\n        return this.storagePersistenceService.read('codeVerifier', configId);\r\n    }\r\n    createCodeVerifier(configId) {\r\n        const codeVerifier = this.randomService.createRandom(67, configId);\r\n        this.storagePersistenceService.write('codeVerifier', codeVerifier, configId);\r\n        return codeVerifier;\r\n    }\r\n    isSilentRenewRunning(configId) {\r\n        const storageObject = this.getSilentRenewRunningStorageEntry(configId);\r\n        if (!storageObject) {\r\n            return false;\r\n        }\r\n        const { silentRenewTimeoutInSeconds } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        const timeOutInMilliseconds = silentRenewTimeoutInSeconds * 1000;\r\n        const dateOfLaunchedProcessUtc = Date.parse(storageObject.dateOfLaunchedProcessUtc);\r\n        const currentDateUtc = Date.parse(new Date().toISOString());\r\n        const elapsedTimeInMilliseconds = Math.abs(currentDateUtc - dateOfLaunchedProcessUtc);\r\n        const isProbablyStuck = elapsedTimeInMilliseconds > timeOutInMilliseconds;\r\n        if (isProbablyStuck) {\r\n            this.loggerService.logDebug(configId, 'silent renew process is probably stuck, state will be reset.', configId);\r\n            this.resetSilentRenewRunning(configId);\r\n            return false;\r\n        }\r\n        return storageObject.state === 'running';\r\n    }\r\n    setSilentRenewRunning(configId) {\r\n        const storageObject = {\r\n            state: 'running',\r\n            dateOfLaunchedProcessUtc: new Date().toISOString(),\r\n        };\r\n        this.storagePersistenceService.write('storageSilentRenewRunning', JSON.stringify(storageObject), configId);\r\n    }\r\n    resetSilentRenewRunning(configId) {\r\n        this.storagePersistenceService.write('storageSilentRenewRunning', '', configId);\r\n    }\r\n    getSilentRenewRunningStorageEntry(configId) {\r\n        const storageEntry = this.storagePersistenceService.read('storageSilentRenewRunning', configId);\r\n        if (!storageEntry) {\r\n            return null;\r\n        }\r\n        return JSON.parse(storageEntry);\r\n    }\r\n}\r\nFlowsDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: FlowsDataService, deps: [{ token: StoragePersistenceService }, { token: RandomService }, { token: ConfigurationProvider }, { token: LoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nFlowsDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: FlowsDataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: FlowsDataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: RandomService }, { type: ConfigurationProvider }, { type: LoggerService }]; } });\n\nclass FlowHelper {\r\n    constructor(configurationProvider) {\r\n        this.configurationProvider = configurationProvider;\r\n    }\r\n    isCurrentFlowCodeFlow(configId) {\r\n        return this.currentFlowIs('code', configId);\r\n    }\r\n    isCurrentFlowAnyImplicitFlow(configId) {\r\n        return this.isCurrentFlowImplicitFlowWithAccessToken(configId) || this.isCurrentFlowImplicitFlowWithoutAccessToken(configId);\r\n    }\r\n    isCurrentFlowCodeFlowWithRefreshTokens(configId) {\r\n        const { useRefreshToken } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (this.isCurrentFlowCodeFlow(configId) && useRefreshToken) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    isCurrentFlowImplicitFlowWithAccessToken(configId) {\r\n        return this.currentFlowIs('id_token token', configId);\r\n    }\r\n    currentFlowIs(flowTypes, configId) {\r\n        const { responseType } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (Array.isArray(flowTypes)) {\r\n            return flowTypes.some((x) => responseType === x);\r\n        }\r\n        return responseType === flowTypes;\r\n    }\r\n    isCurrentFlowImplicitFlowWithoutAccessToken(configId) {\r\n        return this.currentFlowIs('id_token', configId);\r\n    }\r\n}\r\nFlowHelper.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: FlowHelper, deps: [{ token: ConfigurationProvider }], target: i0.ɵɵFactoryTarget.Injectable });\r\nFlowHelper.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: FlowHelper });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: FlowHelper, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: ConfigurationProvider }]; } });\n\nconst CALLBACK_PARAMS_TO_CHECK = ['code', 'state', 'token', 'id_token'];\r\nconst AUTH0_ENDPOINT = 'auth0.com';\r\nclass UrlService {\r\n    constructor(configurationProvider, loggerService, flowsDataService, flowHelper, storagePersistenceService, jsrsAsignReducedService) {\r\n        this.configurationProvider = configurationProvider;\r\n        this.loggerService = loggerService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.flowHelper = flowHelper;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.jsrsAsignReducedService = jsrsAsignReducedService;\r\n    }\r\n    getUrlParameter(urlToCheck, name) {\r\n        if (!urlToCheck) {\r\n            return '';\r\n        }\r\n        if (!name) {\r\n            return '';\r\n        }\r\n        name = name.replace(/[\\[]/, '\\\\[').replace(/[\\]]/, '\\\\]');\r\n        const regex = new RegExp('[\\\\?&]' + name + '=([^&#]*)');\r\n        const results = regex.exec(urlToCheck);\r\n        return results === null ? '' : decodeURIComponent(results[1]);\r\n    }\r\n    isCallbackFromSts(currentUrl) {\r\n        return CALLBACK_PARAMS_TO_CHECK.some((x) => !!this.getUrlParameter(currentUrl, x));\r\n    }\r\n    getRefreshSessionSilentRenewUrl(configId, customParams) {\r\n        if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\r\n            return this.createUrlCodeFlowWithSilentRenew(configId, customParams);\r\n        }\r\n        return this.createUrlImplicitFlowWithSilentRenew(configId, customParams) || '';\r\n    }\r\n    getAuthorizeParUrl(requestUri, configId) {\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        if (!authWellKnownEndPoints) {\r\n            this.loggerService.logError(configId, 'authWellKnownEndpoints is undefined');\r\n            return null;\r\n        }\r\n        const authorizationEndpoint = authWellKnownEndPoints.authorizationEndpoint;\r\n        if (!authorizationEndpoint) {\r\n            this.loggerService.logError(configId, `Can not create an authorize URL when authorizationEndpoint is '${authorizationEndpoint}'`);\r\n            return null;\r\n        }\r\n        const { clientId } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!clientId) {\r\n            this.loggerService.logError(configId, `getAuthorizeParUrl could not add clientId because it was: `, clientId);\r\n            return null;\r\n        }\r\n        const urlParts = authorizationEndpoint.split('?');\r\n        const authorizationUrl = urlParts[0];\r\n        const existingParams = urlParts[1];\r\n        let params = this.createHttpParams(existingParams);\r\n        params = params.set('request_uri', requestUri);\r\n        params = params.append('client_id', clientId);\r\n        return `${authorizationUrl}?${params}`;\r\n    }\r\n    getAuthorizeUrl(configId, customParams) {\r\n        if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\r\n            return this.createUrlCodeFlowAuthorize(configId, customParams);\r\n        }\r\n        return this.createUrlImplicitFlowAuthorize(configId, customParams) || '';\r\n    }\r\n    createEndSessionUrl(idTokenHint, configId, customParamsEndSession) {\r\n        // Auth0 needs a special logout url\r\n        // See https://auth0.com/docs/api/authentication#logout\r\n        if (this.isAuth0Endpoint(configId)) {\r\n            return this.composeAuth0Endpoint(configId);\r\n        }\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        const endSessionEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.endSessionEndpoint;\r\n        if (!endSessionEndpoint) {\r\n            return null;\r\n        }\r\n        const urlParts = endSessionEndpoint.split('?');\r\n        const authorizationEndSessionUrl = urlParts[0];\r\n        const existingParams = urlParts[1];\r\n        let params = this.createHttpParams(existingParams);\r\n        params = params.set('id_token_hint', idTokenHint);\r\n        const postLogoutRedirectUri = this.getPostLogoutRedirectUrl(configId);\r\n        if (postLogoutRedirectUri) {\r\n            params = params.append('post_logout_redirect_uri', postLogoutRedirectUri);\r\n        }\r\n        if (customParamsEndSession) {\r\n            params = this.appendCustomParams(Object.assign({}, customParamsEndSession), params);\r\n        }\r\n        return `${authorizationEndSessionUrl}?${params}`;\r\n    }\r\n    createRevocationEndpointBodyAccessToken(token, configId) {\r\n        const clientId = this.getClientId(configId);\r\n        if (!clientId) {\r\n            return null;\r\n        }\r\n        let params = this.createHttpParams();\r\n        params = params.set('client_id', clientId);\r\n        params = params.set('token', token);\r\n        params = params.set('token_type_hint', 'access_token');\r\n        return params.toString();\r\n    }\r\n    createRevocationEndpointBodyRefreshToken(token, configId) {\r\n        const clientId = this.getClientId(configId);\r\n        if (!clientId) {\r\n            return null;\r\n        }\r\n        let params = this.createHttpParams();\r\n        params = params.set('client_id', clientId);\r\n        params = params.set('token', token);\r\n        params = params.set('token_type_hint', 'refresh_token');\r\n        return params.toString();\r\n    }\r\n    getRevocationEndpointUrl(configId) {\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        const revocationEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.revocationEndpoint;\r\n        if (!revocationEndpoint) {\r\n            return null;\r\n        }\r\n        const urlParts = revocationEndpoint.split('?');\r\n        const revocationEndpointUrl = urlParts[0];\r\n        return revocationEndpointUrl;\r\n    }\r\n    createBodyForCodeFlowCodeRequest(code, configId, customTokenParams) {\r\n        const codeVerifier = this.flowsDataService.getCodeVerifier(configId);\r\n        if (!codeVerifier) {\r\n            this.loggerService.logError(configId, `CodeVerifier is not set `, codeVerifier);\r\n            return null;\r\n        }\r\n        const clientId = this.getClientId(configId);\r\n        if (!clientId) {\r\n            return null;\r\n        }\r\n        let params = this.createHttpParams();\r\n        params = params.set('grant_type', 'authorization_code');\r\n        params = params.set('client_id', clientId);\r\n        params = params.set('code_verifier', codeVerifier);\r\n        params = params.set('code', code);\r\n        if (customTokenParams) {\r\n            params = this.appendCustomParams(Object.assign({}, customTokenParams), params);\r\n        }\r\n        const silentRenewUrl = this.getSilentRenewUrl(configId);\r\n        if (this.flowsDataService.isSilentRenewRunning(configId) && silentRenewUrl) {\r\n            params = params.set('redirect_uri', silentRenewUrl);\r\n            return params.toString();\r\n        }\r\n        const redirectUrl = this.getRedirectUrl(configId);\r\n        if (!redirectUrl) {\r\n            return null;\r\n        }\r\n        params = params.set('redirect_uri', redirectUrl);\r\n        return params.toString();\r\n    }\r\n    createBodyForCodeFlowRefreshTokensRequest(refreshToken, configId, customParamsRefresh) {\r\n        const clientId = this.getClientId(configId);\r\n        if (!clientId) {\r\n            return null;\r\n        }\r\n        let params = this.createHttpParams();\r\n        params = params.set('grant_type', 'refresh_token');\r\n        params = params.set('client_id', clientId);\r\n        params = params.set('refresh_token', refreshToken);\r\n        if (customParamsRefresh) {\r\n            params = this.appendCustomParams(Object.assign({}, customParamsRefresh), params);\r\n        }\r\n        return params.toString();\r\n    }\r\n    createBodyForParCodeFlowRequest(configId, customParamsRequest) {\r\n        const redirectUrl = this.getRedirectUrl(configId);\r\n        if (!redirectUrl) {\r\n            return null;\r\n        }\r\n        const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\r\n        const nonce = this.flowsDataService.createNonce(configId);\r\n        this.loggerService.logDebug(configId, 'Authorize created. adding myautostate: ' + state);\r\n        // code_challenge with \"S256\"\r\n        const codeVerifier = this.flowsDataService.createCodeVerifier(configId);\r\n        const codeChallenge = this.jsrsAsignReducedService.generateCodeChallenge(codeVerifier);\r\n        const { clientId, responseType, scope, hdParam, customParamsAuthRequest } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        let params = this.createHttpParams('');\r\n        params = params.set('client_id', clientId);\r\n        params = params.append('redirect_uri', redirectUrl);\r\n        params = params.append('response_type', responseType);\r\n        params = params.append('scope', scope);\r\n        params = params.append('nonce', nonce);\r\n        params = params.append('state', state);\r\n        params = params.append('code_challenge', codeChallenge);\r\n        params = params.append('code_challenge_method', 'S256');\r\n        if (hdParam) {\r\n            params = params.append('hd', hdParam);\r\n        }\r\n        if (customParamsAuthRequest) {\r\n            params = this.appendCustomParams(Object.assign({}, customParamsAuthRequest), params);\r\n        }\r\n        if (customParamsRequest) {\r\n            params = this.appendCustomParams(Object.assign({}, customParamsRequest), params);\r\n        }\r\n        return params.toString();\r\n    }\r\n    createAuthorizeUrl(codeChallenge, redirectUrl, nonce, state, configId, prompt, customRequestParams) {\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        const authorizationEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.authorizationEndpoint;\r\n        if (!authorizationEndpoint) {\r\n            this.loggerService.logError(configId, `Can not create an authorize URL when authorizationEndpoint is '${authorizationEndpoint}'`);\r\n            return null;\r\n        }\r\n        const { clientId, responseType, scope, hdParam, customParamsAuthRequest } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!clientId) {\r\n            this.loggerService.logError(configId, `createAuthorizeUrl could not add clientId because it was: `, clientId);\r\n            return null;\r\n        }\r\n        if (!responseType) {\r\n            this.loggerService.logError(configId, `createAuthorizeUrl could not add responseType because it was: `, responseType);\r\n            return null;\r\n        }\r\n        if (!scope) {\r\n            this.loggerService.logError(configId, `createAuthorizeUrl could not add scope because it was: `, scope);\r\n            return null;\r\n        }\r\n        const urlParts = authorizationEndpoint.split('?');\r\n        const authorizationUrl = urlParts[0];\r\n        const existingParams = urlParts[1];\r\n        let params = this.createHttpParams(existingParams);\r\n        params = params.set('client_id', clientId);\r\n        params = params.append('redirect_uri', redirectUrl);\r\n        params = params.append('response_type', responseType);\r\n        params = params.append('scope', scope);\r\n        params = params.append('nonce', nonce);\r\n        params = params.append('state', state);\r\n        if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\r\n            params = params.append('code_challenge', codeChallenge);\r\n            params = params.append('code_challenge_method', 'S256');\r\n        }\r\n        const mergedParams = Object.assign(Object.assign({}, customParamsAuthRequest), customRequestParams);\r\n        if (Object.keys(mergedParams).length > 0) {\r\n            params = this.appendCustomParams(Object.assign({}, mergedParams), params);\r\n        }\r\n        if (prompt) {\r\n            params = this.overWriteParam(params, 'prompt', prompt);\r\n        }\r\n        if (hdParam) {\r\n            params = params.append('hd', hdParam);\r\n        }\r\n        return `${authorizationUrl}?${params}`;\r\n    }\r\n    createUrlImplicitFlowWithSilentRenew(configId, customParams) {\r\n        const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\r\n        const nonce = this.flowsDataService.createNonce(configId);\r\n        const silentRenewUrl = this.getSilentRenewUrl(configId);\r\n        if (!silentRenewUrl) {\r\n            return null;\r\n        }\r\n        this.loggerService.logDebug(configId, 'RefreshSession created. adding myautostate: ', state);\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        if (authWellKnownEndPoints) {\r\n            return this.createAuthorizeUrl('', silentRenewUrl, nonce, state, configId, 'none', customParams);\r\n        }\r\n        this.loggerService.logError(configId, 'authWellKnownEndpoints is undefined');\r\n        return null;\r\n    }\r\n    createUrlCodeFlowWithSilentRenew(configId, customParams) {\r\n        const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\r\n        const nonce = this.flowsDataService.createNonce(configId);\r\n        this.loggerService.logDebug(configId, 'RefreshSession created. adding myautostate: ' + state);\r\n        // code_challenge with \"S256\"\r\n        const codeVerifier = this.flowsDataService.createCodeVerifier(configId);\r\n        const codeChallenge = this.jsrsAsignReducedService.generateCodeChallenge(codeVerifier);\r\n        const silentRenewUrl = this.getSilentRenewUrl(configId);\r\n        if (!silentRenewUrl) {\r\n            return null;\r\n        }\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        if (authWellKnownEndPoints) {\r\n            return this.createAuthorizeUrl(codeChallenge, silentRenewUrl, nonce, state, configId, 'none', customParams);\r\n        }\r\n        this.loggerService.logWarning(configId, 'authWellKnownEndpoints is undefined');\r\n        return null;\r\n    }\r\n    createUrlImplicitFlowAuthorize(configId, customParams) {\r\n        const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\r\n        const nonce = this.flowsDataService.createNonce(configId);\r\n        this.loggerService.logDebug(configId, 'Authorize created. adding myautostate: ' + state);\r\n        const redirectUrl = this.getRedirectUrl(configId);\r\n        if (!redirectUrl) {\r\n            return null;\r\n        }\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        if (authWellKnownEndPoints) {\r\n            return this.createAuthorizeUrl('', redirectUrl, nonce, state, configId, null, customParams);\r\n        }\r\n        this.loggerService.logError(configId, 'authWellKnownEndpoints is undefined');\r\n        return null;\r\n    }\r\n    createUrlCodeFlowAuthorize(configId, customParams) {\r\n        const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\r\n        const nonce = this.flowsDataService.createNonce(configId);\r\n        this.loggerService.logDebug(configId, 'Authorize created. adding myautostate: ' + state);\r\n        const redirectUrl = this.getRedirectUrl(configId);\r\n        if (!redirectUrl) {\r\n            return null;\r\n        }\r\n        // code_challenge with \"S256\"\r\n        const codeVerifier = this.flowsDataService.createCodeVerifier(configId);\r\n        const codeChallenge = this.jsrsAsignReducedService.generateCodeChallenge(codeVerifier);\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        if (authWellKnownEndPoints) {\r\n            return this.createAuthorizeUrl(codeChallenge, redirectUrl, nonce, state, configId, null, customParams);\r\n        }\r\n        this.loggerService.logError(configId, 'authWellKnownEndpoints is undefined');\r\n        return null;\r\n    }\r\n    getRedirectUrl(configId) {\r\n        const { redirectUrl } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!redirectUrl) {\r\n            this.loggerService.logError(configId, `could not get redirectUrl, was: `, redirectUrl);\r\n            null;\r\n        }\r\n        return redirectUrl;\r\n    }\r\n    getSilentRenewUrl(configId) {\r\n        const { silentRenewUrl } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!silentRenewUrl) {\r\n            this.loggerService.logError(configId, `could not get silentRenewUrl, was: `, silentRenewUrl);\r\n            return null;\r\n        }\r\n        return silentRenewUrl;\r\n    }\r\n    getPostLogoutRedirectUrl(configId) {\r\n        const { postLogoutRedirectUri } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!postLogoutRedirectUri) {\r\n            this.loggerService.logError(configId, `could not get postLogoutRedirectUri, was: `, postLogoutRedirectUri);\r\n            return null;\r\n        }\r\n        return postLogoutRedirectUri;\r\n    }\r\n    getClientId(configId) {\r\n        const { clientId } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!clientId) {\r\n            this.loggerService.logError(configId, `could not get clientId, was: `, clientId);\r\n            return null;\r\n        }\r\n        return clientId;\r\n    }\r\n    appendCustomParams(customParams, params) {\r\n        for (const [key, value] of Object.entries(Object.assign({}, customParams))) {\r\n            params = params.append(key, value.toString());\r\n        }\r\n        return params;\r\n    }\r\n    overWriteParam(params, key, value) {\r\n        return params.set(key, value);\r\n    }\r\n    createHttpParams(existingParams) {\r\n        existingParams = existingParams !== null && existingParams !== void 0 ? existingParams : '';\r\n        const params = new HttpParams({\r\n            fromString: existingParams,\r\n            encoder: new UriEncoder(),\r\n        });\r\n        return params;\r\n    }\r\n    isAuth0Endpoint(configId) {\r\n        const { authority } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!authority) {\r\n            return false;\r\n        }\r\n        return authority.endsWith(AUTH0_ENDPOINT);\r\n    }\r\n    composeAuth0Endpoint(configId) {\r\n        // format: https://YOUR_DOMAIN/v2/logout?client_id=YOUR_CLIENT_ID&returnTo=LOGOUT_URL\r\n        const { authority, clientId } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        const postLogoutRedirectUrl = this.getPostLogoutRedirectUrl(configId);\r\n        return `${authority}/v2/logout?client_id=${clientId}&returnTo=${postLogoutRedirectUrl}`;\r\n    }\r\n}\r\nUrlService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: UrlService, deps: [{ token: ConfigurationProvider }, { token: LoggerService }, { token: FlowsDataService }, { token: FlowHelper }, { token: StoragePersistenceService }, { token: JsrsAsignReducedService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nUrlService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: UrlService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: UrlService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: ConfigurationProvider }, { type: LoggerService }, { type: FlowsDataService }, { type: FlowHelper }, { type: StoragePersistenceService }, { type: JsrsAsignReducedService }]; } });\n\nclass CodeFlowCallbackHandlerService {\r\n    constructor(urlService, loggerService, tokenValidationService, flowsDataService, configurationProvider, storagePersistenceService, dataService) {\r\n        this.urlService = urlService;\r\n        this.loggerService = loggerService;\r\n        this.tokenValidationService = tokenValidationService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.dataService = dataService;\r\n    }\r\n    // STEP 1 Code Flow\r\n    codeFlowCallback(urlToCheck, configId) {\r\n        const code = this.urlService.getUrlParameter(urlToCheck, 'code');\r\n        const state = this.urlService.getUrlParameter(urlToCheck, 'state');\r\n        const sessionState = this.urlService.getUrlParameter(urlToCheck, 'session_state');\r\n        if (!state) {\r\n            this.loggerService.logDebug(configId, 'no state in url');\r\n            return throwError('no state in url');\r\n        }\r\n        if (!code) {\r\n            this.loggerService.logDebug(configId, 'no code in url');\r\n            return throwError('no code in url');\r\n        }\r\n        this.loggerService.logDebug(configId, 'running validation for callback', urlToCheck);\r\n        const initialCallbackContext = {\r\n            code,\r\n            refreshToken: null,\r\n            state,\r\n            sessionState,\r\n            authResult: null,\r\n            isRenewProcess: false,\r\n            jwtKeys: null,\r\n            validationResult: null,\r\n            existingIdToken: null,\r\n        };\r\n        return of(initialCallbackContext);\r\n    }\r\n    // STEP 2 Code Flow //  Code Flow Silent Renew starts here\r\n    codeFlowCodeRequest(callbackContext, configId) {\r\n        const authStateControl = this.flowsDataService.getAuthStateControl(configId);\r\n        const isStateCorrect = this.tokenValidationService.validateStateFromHashCallback(callbackContext.state, authStateControl, configId);\r\n        if (!isStateCorrect) {\r\n            return throwError('codeFlowCodeRequest incorrect state');\r\n        }\r\n        const authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        const tokenEndpoint = authWellknownEndpoints === null || authWellknownEndpoints === void 0 ? void 0 : authWellknownEndpoints.tokenEndpoint;\r\n        if (!tokenEndpoint) {\r\n            return throwError('Token Endpoint not defined');\r\n        }\r\n        let headers = new HttpHeaders();\r\n        headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\r\n        const config = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        const bodyForCodeFlow = this.urlService.createBodyForCodeFlowCodeRequest(callbackContext.code, configId, config === null || config === void 0 ? void 0 : config.customParamsCodeRequest);\r\n        return this.dataService.post(tokenEndpoint, bodyForCodeFlow, configId, headers).pipe(switchMap((response) => {\r\n            let authResult = new Object();\r\n            authResult = response;\r\n            authResult.state = callbackContext.state;\r\n            authResult.session_state = callbackContext.sessionState;\r\n            callbackContext.authResult = authResult;\r\n            return of(callbackContext);\r\n        }), retryWhen((error) => this.handleRefreshRetry(error, configId)), catchError((error) => {\r\n            const { authority } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n            const errorMessage = `OidcService code request ${authority}`;\r\n            this.loggerService.logError(configId, errorMessage, error);\r\n            return throwError(errorMessage);\r\n        }));\r\n    }\r\n    handleRefreshRetry(errors, configId) {\r\n        return errors.pipe(mergeMap((error) => {\r\n            // retry token refresh if there is no internet connection\r\n            if (error && error instanceof HttpErrorResponse && error.error instanceof ProgressEvent && error.error.type === 'error') {\r\n                const { authority, refreshTokenRetryInSeconds } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n                const errorMessage = `OidcService code request ${authority} - no internet connection`;\r\n                this.loggerService.logWarning(configId, errorMessage, error);\r\n                return timer(refreshTokenRetryInSeconds * 1000);\r\n            }\r\n            return throwError(error);\r\n        }));\r\n    }\r\n}\r\nCodeFlowCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CodeFlowCallbackHandlerService, deps: [{ token: UrlService }, { token: LoggerService }, { token: TokenValidationService }, { token: FlowsDataService }, { token: ConfigurationProvider }, { token: StoragePersistenceService }, { token: DataService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCodeFlowCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CodeFlowCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CodeFlowCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: UrlService }, { type: LoggerService }, { type: TokenValidationService }, { type: FlowsDataService }, { type: ConfigurationProvider }, { type: StoragePersistenceService }, { type: DataService }]; } });\n\nconst DEFAULT_USERRESULT = { userData: null, allUserData: [] };\r\nclass UserService {\r\n    constructor(oidcDataService, storagePersistenceService, eventService, loggerService, tokenHelperService, flowHelper, configurationProvider) {\r\n        this.oidcDataService = oidcDataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.eventService = eventService;\r\n        this.loggerService = loggerService;\r\n        this.tokenHelperService = tokenHelperService;\r\n        this.flowHelper = flowHelper;\r\n        this.configurationProvider = configurationProvider;\r\n        this.userDataInternal$ = new BehaviorSubject(DEFAULT_USERRESULT);\r\n    }\r\n    get userData$() {\r\n        return this.userDataInternal$.asObservable();\r\n    }\r\n    getAndPersistUserDataInStore(configId, isRenewProcess = false, idToken, decodedIdToken) {\r\n        idToken = idToken || this.storagePersistenceService.getIdToken(configId);\r\n        decodedIdToken = decodedIdToken || this.tokenHelperService.getPayloadFromToken(idToken, false, configId);\r\n        const existingUserDataFromStorage = this.getUserDataFromStore(configId);\r\n        const haveUserData = !!existingUserDataFromStorage;\r\n        const isCurrentFlowImplicitFlowWithAccessToken = this.flowHelper.isCurrentFlowImplicitFlowWithAccessToken(configId);\r\n        const isCurrentFlowCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(configId);\r\n        const accessToken = this.storagePersistenceService.getAccessToken(configId);\r\n        if (!(isCurrentFlowImplicitFlowWithAccessToken || isCurrentFlowCodeFlow)) {\r\n            this.loggerService.logDebug(configId, `authCallback idToken flow with accessToken ${accessToken}`);\r\n            this.setUserDataToStore(decodedIdToken, configId);\r\n            return of(decodedIdToken);\r\n        }\r\n        const { renewUserInfoAfterTokenRenew } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!isRenewProcess || renewUserInfoAfterTokenRenew || !haveUserData) {\r\n            return this.getUserDataOidcFlowAndSave(decodedIdToken.sub, configId).pipe(switchMap((userData) => {\r\n                this.loggerService.logDebug(configId, 'Received user data: ', userData);\r\n                if (!!userData) {\r\n                    this.loggerService.logDebug(configId, 'accessToken: ', accessToken);\r\n                    return of(userData);\r\n                }\r\n                else {\r\n                    return throwError('Received no user data, request failed');\r\n                }\r\n            }));\r\n        }\r\n        return of(existingUserDataFromStorage);\r\n    }\r\n    getUserDataFromStore(configId) {\r\n        return this.storagePersistenceService.read('userData', configId) || null;\r\n    }\r\n    publishUserDataIfExists(configId) {\r\n        const userData = this.getUserDataFromStore(configId);\r\n        if (userData) {\r\n            this.fireUserDataEvent(configId, userData);\r\n        }\r\n    }\r\n    setUserDataToStore(userData, configId) {\r\n        this.storagePersistenceService.write('userData', userData, configId);\r\n        this.fireUserDataEvent(configId, userData);\r\n    }\r\n    resetUserDataInStore(configId) {\r\n        this.storagePersistenceService.remove('userData', configId);\r\n        this.fireUserDataEvent(configId, null);\r\n    }\r\n    getUserDataOidcFlowAndSave(idTokenSub, configId) {\r\n        return this.getIdentityUserData(configId).pipe(map((data) => {\r\n            if (this.validateUserDataSubIdToken(idTokenSub, data === null || data === void 0 ? void 0 : data.sub)) {\r\n                this.setUserDataToStore(data, configId);\r\n                return data;\r\n            }\r\n            else {\r\n                // something went wrong, user data sub does not match that from id_token\r\n                this.loggerService.logWarning(configId, `User data sub does not match sub in id_token, resetting`);\r\n                this.resetUserDataInStore(configId);\r\n                return null;\r\n            }\r\n        }));\r\n    }\r\n    getIdentityUserData(configId) {\r\n        const token = this.storagePersistenceService.getAccessToken(configId);\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        if (!authWellKnownEndPoints) {\r\n            this.loggerService.logWarning(configId, 'init check session: authWellKnownEndpoints is undefined');\r\n            return throwError('authWellKnownEndpoints is undefined');\r\n        }\r\n        const userInfoEndpoint = authWellKnownEndPoints.userInfoEndpoint;\r\n        if (!userInfoEndpoint) {\r\n            this.loggerService.logError(configId, 'init check session: authWellKnownEndpoints.userinfo_endpoint is undefined; set auto_userinfo = false in config');\r\n            return throwError('authWellKnownEndpoints.userinfo_endpoint is undefined');\r\n        }\r\n        return this.oidcDataService.get(userInfoEndpoint, configId, token).pipe(retry(2));\r\n    }\r\n    validateUserDataSubIdToken(idTokenSub, userDataSub) {\r\n        if (!idTokenSub) {\r\n            return false;\r\n        }\r\n        if (!userDataSub) {\r\n            return false;\r\n        }\r\n        if (idTokenSub !== userDataSub) {\r\n            this.loggerService.logDebug('validateUserDataSubIdToken failed', idTokenSub, userDataSub);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    fireUserDataEvent(configId, passedUserData) {\r\n        const userData = this.composeSingleOrMultipleUserDataObject(configId, passedUserData);\r\n        this.userDataInternal$.next(userData);\r\n        this.eventService.fireEvent(EventTypes.UserDataChanged, { configId, userData: passedUserData });\r\n    }\r\n    composeSingleOrMultipleUserDataObject(configId, passedUserData) {\r\n        const hasManyConfigs = this.configurationProvider.hasManyConfigs();\r\n        if (!hasManyConfigs) {\r\n            return this.composeSingleUserDataResult(configId, passedUserData);\r\n        }\r\n        const configs = this.configurationProvider.getAllConfigurations();\r\n        const allUserData = configs.map((config) => {\r\n            if (this.currentConfigIsToUpdate(configId, config)) {\r\n                return { configId: config.configId, userData: passedUserData };\r\n            }\r\n            const alreadySavedUserData = this.storagePersistenceService.read('userData', config.configId) || null;\r\n            return { configId: config.configId, userData: alreadySavedUserData };\r\n        });\r\n        return {\r\n            userData: null,\r\n            allUserData,\r\n        };\r\n    }\r\n    composeSingleUserDataResult(configId, userData) {\r\n        return {\r\n            userData,\r\n            allUserData: [{ configId, userData }],\r\n        };\r\n    }\r\n    currentConfigIsToUpdate(configId, config) {\r\n        return config.configId === configId;\r\n    }\r\n}\r\nUserService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: UserService, deps: [{ token: DataService }, { token: StoragePersistenceService }, { token: PublicEventsService }, { token: LoggerService }, { token: TokenHelperService }, { token: FlowHelper }, { token: ConfigurationProvider }], target: i0.ɵɵFactoryTarget.Injectable });\r\nUserService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: UserService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: UserService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: DataService }, { type: StoragePersistenceService }, { type: PublicEventsService }, { type: LoggerService }, { type: TokenHelperService }, { type: FlowHelper }, { type: ConfigurationProvider }]; } });\n\nclass ResetAuthDataService {\r\n    constructor(authStateService, flowsDataService, userService) {\r\n        this.authStateService = authStateService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.userService = userService;\r\n    }\r\n    resetAuthorizationData(configId) {\r\n        this.userService.resetUserDataInStore(configId);\r\n        this.flowsDataService.resetStorageFlowData(configId);\r\n        this.authStateService.setUnauthenticatedAndFireEvent(configId);\r\n    }\r\n}\r\nResetAuthDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ResetAuthDataService, deps: [{ token: AuthStateService }, { token: FlowsDataService }, { token: UserService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nResetAuthDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ResetAuthDataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ResetAuthDataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: AuthStateService }, { type: FlowsDataService }, { type: UserService }]; } });\n\nclass ImplicitFlowCallbackHandlerService {\r\n    constructor(resetAuthDataService, loggerService, flowsDataService, doc) {\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.loggerService = loggerService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.doc = doc;\r\n    }\r\n    // STEP 1 Code Flow\r\n    // STEP 1 Implicit Flow\r\n    implicitFlowCallback(configId, hash) {\r\n        const isRenewProcessData = this.flowsDataService.isSilentRenewRunning(configId);\r\n        this.loggerService.logDebug(configId, 'BEGIN callback, no auth data');\r\n        if (!isRenewProcessData) {\r\n            this.resetAuthDataService.resetAuthorizationData(configId);\r\n        }\r\n        hash = hash || this.doc.location.hash.substr(1);\r\n        const authResult = hash.split('&').reduce((resultData, item) => {\r\n            const parts = item.split('=');\r\n            resultData[parts.shift()] = parts.join('=');\r\n            return resultData;\r\n        }, {});\r\n        const callbackContext = {\r\n            code: null,\r\n            refreshToken: null,\r\n            state: null,\r\n            sessionState: null,\r\n            authResult,\r\n            isRenewProcess: isRenewProcessData,\r\n            jwtKeys: null,\r\n            validationResult: null,\r\n            existingIdToken: null,\r\n        };\r\n        return of(callbackContext);\r\n    }\r\n}\r\nImplicitFlowCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ImplicitFlowCallbackHandlerService, deps: [{ token: ResetAuthDataService }, { token: LoggerService }, { token: FlowsDataService }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nImplicitFlowCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ImplicitFlowCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ImplicitFlowCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: ResetAuthDataService }, { type: LoggerService }, { type: FlowsDataService }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }]; } });\n\n/* eslint-disable no-shadow */\r\nvar ValidationResult;\r\n(function (ValidationResult) {\r\n    ValidationResult[\"NotSet\"] = \"NotSet\";\r\n    ValidationResult[\"StatesDoNotMatch\"] = \"StatesDoNotMatch\";\r\n    ValidationResult[\"SignatureFailed\"] = \"SignatureFailed\";\r\n    ValidationResult[\"IncorrectNonce\"] = \"IncorrectNonce\";\r\n    ValidationResult[\"RequiredPropertyMissing\"] = \"RequiredPropertyMissing\";\r\n    ValidationResult[\"MaxOffsetExpired\"] = \"MaxOffsetExpired\";\r\n    ValidationResult[\"IssDoesNotMatchIssuer\"] = \"IssDoesNotMatchIssuer\";\r\n    ValidationResult[\"NoAuthWellKnownEndPoints\"] = \"NoAuthWellKnownEndPoints\";\r\n    ValidationResult[\"IncorrectAud\"] = \"IncorrectAud\";\r\n    ValidationResult[\"IncorrectIdTokenClaimsAfterRefresh\"] = \"IncorrectIdTokenClaimsAfterRefresh\";\r\n    ValidationResult[\"IncorrectAzp\"] = \"IncorrectAzp\";\r\n    ValidationResult[\"TokenExpired\"] = \"TokenExpired\";\r\n    ValidationResult[\"IncorrectAtHash\"] = \"IncorrectAtHash\";\r\n    ValidationResult[\"Ok\"] = \"Ok\";\r\n    ValidationResult[\"LoginRequired\"] = \"LoginRequired\";\r\n    ValidationResult[\"SecureTokenServerError\"] = \"SecureTokenServerError\";\r\n})(ValidationResult || (ValidationResult = {}));\n\nclass SigninKeyDataService {\r\n    constructor(storagePersistenceService, loggerService, dataService) {\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.loggerService = loggerService;\r\n        this.dataService = dataService;\r\n    }\r\n    getSigningKeys(configId) {\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        const jwksUri = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.jwksUri;\r\n        if (!jwksUri) {\r\n            const error = `getSigningKeys: authWellKnownEndpoints.jwksUri is: '${jwksUri}'`;\r\n            this.loggerService.logWarning(configId, error);\r\n            return throwError(error);\r\n        }\r\n        this.loggerService.logDebug(configId, 'Getting signinkeys from ', jwksUri);\r\n        return this.dataService.get(jwksUri, configId).pipe(retry(2), catchError((e) => this.handleErrorGetSigningKeys(e, configId)));\r\n    }\r\n    handleErrorGetSigningKeys(errorResponse, configId) {\r\n        let errMsg = '';\r\n        if (errorResponse instanceof HttpResponse) {\r\n            const body = errorResponse.body || {};\r\n            const err = JSON.stringify(body);\r\n            const { status, statusText } = errorResponse;\r\n            errMsg = `${status || ''} - ${statusText || ''} ${err || ''}`;\r\n        }\r\n        else {\r\n            const { message } = errorResponse;\r\n            errMsg = !!message ? message : `${errorResponse}`;\r\n        }\r\n        this.loggerService.logError(configId, errMsg);\r\n        return throwError(errMsg);\r\n    }\r\n}\r\nSigninKeyDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: SigninKeyDataService, deps: [{ token: StoragePersistenceService }, { token: LoggerService }, { token: DataService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nSigninKeyDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: SigninKeyDataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: SigninKeyDataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: LoggerService }, { type: DataService }]; } });\n\nconst JWT_KEYS = 'jwtKeys';\r\nclass HistoryJwtKeysCallbackHandlerService {\r\n    constructor(loggerService, configurationProvider, authStateService, flowsDataService, signInKeyDataService, storagePersistenceService, resetAuthDataService) {\r\n        this.loggerService = loggerService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.authStateService = authStateService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.signInKeyDataService = signInKeyDataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n    }\r\n    // STEP 3 Code Flow, STEP 2 Implicit Flow, STEP 3 Refresh Token\r\n    callbackHistoryAndResetJwtKeys(callbackContext, configId) {\r\n        this.storagePersistenceService.write('authnResult', callbackContext.authResult, configId);\r\n        if (this.historyCleanUpTurnedOn(configId) && !callbackContext.isRenewProcess) {\r\n            this.resetBrowserHistory();\r\n        }\r\n        else {\r\n            this.loggerService.logDebug(configId, 'history clean up inactive');\r\n        }\r\n        if (callbackContext.authResult.error) {\r\n            const errorMessage = `AuthCallback AuthResult came with error: ${callbackContext.authResult.error}`;\r\n            this.loggerService.logDebug(configId, errorMessage);\r\n            this.resetAuthDataService.resetAuthorizationData(configId);\r\n            this.flowsDataService.setNonce('', configId);\r\n            this.handleResultErrorFromCallback(callbackContext.authResult, callbackContext.isRenewProcess);\r\n            return throwError(errorMessage);\r\n        }\r\n        this.loggerService.logDebug(configId, `AuthResult '${JSON.stringify(callbackContext.authResult, null, 2)}'.\n      AuthCallback created, begin token validation`);\r\n        return this.signInKeyDataService.getSigningKeys(configId).pipe(tap((jwtKeys) => this.storeSigningKeys(jwtKeys, configId)), catchError((err) => {\r\n            // fallback: try to load jwtKeys from storage\r\n            const storedJwtKeys = this.readSigningKeys(configId);\r\n            if (!!storedJwtKeys) {\r\n                this.loggerService.logWarning(configId, `Failed to retrieve signing keys, fallback to stored keys`);\r\n                return of(storedJwtKeys);\r\n            }\r\n            return throwError(err);\r\n        }), switchMap((jwtKeys) => {\r\n            if (jwtKeys) {\r\n                callbackContext.jwtKeys = jwtKeys;\r\n                return of(callbackContext);\r\n            }\r\n            const errorMessage = `Failed to retrieve signing key`;\r\n            this.loggerService.logWarning(configId, errorMessage);\r\n            return throwError(errorMessage);\r\n        }), catchError((err) => {\r\n            const errorMessage = `Failed to retrieve signing key with error: ${err}`;\r\n            this.loggerService.logWarning(configId, errorMessage);\r\n            return throwError(errorMessage);\r\n        }));\r\n    }\r\n    handleResultErrorFromCallback(result, isRenewProcess) {\r\n        let validationResult = ValidationResult.SecureTokenServerError;\r\n        if (result.error === 'login_required') {\r\n            validationResult = ValidationResult.LoginRequired;\r\n        }\r\n        this.authStateService.updateAndPublishAuthState({\r\n            isAuthenticated: false,\r\n            validationResult,\r\n            isRenewProcess,\r\n        });\r\n    }\r\n    historyCleanUpTurnedOn(configId) {\r\n        const { historyCleanupOff } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        return !historyCleanupOff;\r\n    }\r\n    resetBrowserHistory() {\r\n        window.history.replaceState({}, window.document.title, window.location.origin + window.location.pathname);\r\n    }\r\n    storeSigningKeys(jwtKeys, configId) {\r\n        this.storagePersistenceService.write(JWT_KEYS, jwtKeys, configId);\r\n    }\r\n    readSigningKeys(configId) {\r\n        return this.storagePersistenceService.read(JWT_KEYS, configId);\r\n    }\r\n}\r\nHistoryJwtKeysCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: HistoryJwtKeysCallbackHandlerService, deps: [{ token: LoggerService }, { token: ConfigurationProvider }, { token: AuthStateService }, { token: FlowsDataService }, { token: SigninKeyDataService }, { token: StoragePersistenceService }, { token: ResetAuthDataService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nHistoryJwtKeysCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: HistoryJwtKeysCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: HistoryJwtKeysCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: ConfigurationProvider }, { type: AuthStateService }, { type: FlowsDataService }, { type: SigninKeyDataService }, { type: StoragePersistenceService }, { type: ResetAuthDataService }]; } });\n\nclass UserCallbackHandlerService {\r\n    constructor(loggerService, configurationProvider, authStateService, flowsDataService, userService, resetAuthDataService) {\r\n        this.loggerService = loggerService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.authStateService = authStateService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.userService = userService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n    }\r\n    // STEP 5 userData\r\n    callbackUser(callbackContext, configId) {\r\n        const { isRenewProcess, validationResult, authResult, refreshToken } = callbackContext;\r\n        const { autoUserInfo, renewUserInfoAfterTokenRenew } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!autoUserInfo) {\r\n            if (!isRenewProcess || renewUserInfoAfterTokenRenew) {\r\n                // userData is set to the id_token decoded, auto get user data set to false\r\n                if (validationResult.decodedIdToken) {\r\n                    this.userService.setUserDataToStore(validationResult.decodedIdToken, configId);\r\n                }\r\n            }\r\n            if (!isRenewProcess && !refreshToken) {\r\n                this.flowsDataService.setSessionState(authResult.session_state, configId);\r\n            }\r\n            this.publishAuthState(validationResult, isRenewProcess);\r\n            return of(callbackContext);\r\n        }\r\n        return this.userService\r\n            .getAndPersistUserDataInStore(configId, isRenewProcess, validationResult.idToken, validationResult.decodedIdToken)\r\n            .pipe(switchMap((userData) => {\r\n            if (!!userData) {\r\n                if (!refreshToken) {\r\n                    this.flowsDataService.setSessionState(authResult.session_state, configId);\r\n                }\r\n                this.publishAuthState(validationResult, isRenewProcess);\r\n                return of(callbackContext);\r\n            }\r\n            else {\r\n                this.resetAuthDataService.resetAuthorizationData(configId);\r\n                this.publishUnauthenticatedState(validationResult, isRenewProcess);\r\n                const errorMessage = `Called for userData but they were ${userData}`;\r\n                this.loggerService.logWarning(configId, errorMessage);\r\n                return throwError(errorMessage);\r\n            }\r\n        }), catchError((err) => {\r\n            const errorMessage = `Failed to retrieve user info with error:  ${err}`;\r\n            this.loggerService.logWarning(configId, errorMessage);\r\n            return throwError(errorMessage);\r\n        }));\r\n    }\r\n    publishAuthState(stateValidationResult, isRenewProcess) {\r\n        this.authStateService.updateAndPublishAuthState({\r\n            isAuthenticated: true,\r\n            validationResult: stateValidationResult.state,\r\n            isRenewProcess,\r\n        });\r\n    }\r\n    publishUnauthenticatedState(stateValidationResult, isRenewProcess) {\r\n        this.authStateService.updateAndPublishAuthState({\r\n            isAuthenticated: false,\r\n            validationResult: stateValidationResult.state,\r\n            isRenewProcess,\r\n        });\r\n    }\r\n}\r\nUserCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: UserCallbackHandlerService, deps: [{ token: LoggerService }, { token: ConfigurationProvider }, { token: AuthStateService }, { token: FlowsDataService }, { token: UserService }, { token: ResetAuthDataService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nUserCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: UserCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: UserCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: ConfigurationProvider }, { type: AuthStateService }, { type: FlowsDataService }, { type: UserService }, { type: ResetAuthDataService }]; } });\n\nclass StateValidationResult {\r\n    constructor(accessToken = '', idToken = '', authResponseIsValid = false, decodedIdToken = {}, state = ValidationResult.NotSet) {\r\n        this.accessToken = accessToken;\r\n        this.idToken = idToken;\r\n        this.authResponseIsValid = authResponseIsValid;\r\n        this.decodedIdToken = decodedIdToken;\r\n        this.state = state;\r\n    }\r\n}\n\nclass EqualityService {\r\n    isStringEqualOrNonOrderedArrayEqual(value1, value2) {\r\n        if (this.isNullOrUndefined(value1)) {\r\n            return false;\r\n        }\r\n        if (this.isNullOrUndefined(value2)) {\r\n            return false;\r\n        }\r\n        if (this.oneValueIsStringAndTheOtherIsArray(value1, value2)) {\r\n            return false;\r\n        }\r\n        if (this.bothValuesAreStrings(value1, value2)) {\r\n            return value1 === value2;\r\n        }\r\n        if (this.bothValuesAreArrays(value1, value2)) {\r\n            return this.arraysHaveEqualContent(value1, value2);\r\n        }\r\n        return false;\r\n    }\r\n    areEqual(value1, value2) {\r\n        if (!value1 || !value2) {\r\n            return false;\r\n        }\r\n        if (this.bothValuesAreArrays(value1, value2)) {\r\n            return this.arraysStrictEqual(value1, value2);\r\n        }\r\n        if (this.bothValuesAreStrings(value1, value2)) {\r\n            return value1 === value2;\r\n        }\r\n        if (this.bothValuesAreObjects(value1, value2)) {\r\n            return JSON.stringify(value1).toLowerCase() === JSON.stringify(value2).toLowerCase();\r\n        }\r\n        if (this.oneValueIsStringAndTheOtherIsArray(value1, value2)) {\r\n            if (Array.isArray(value1) && this.valueIsString(value2)) {\r\n                return value1[0] === value2;\r\n            }\r\n            if (Array.isArray(value2) && this.valueIsString(value1)) {\r\n                return value2[0] === value1;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    oneValueIsStringAndTheOtherIsArray(value1, value2) {\r\n        return (Array.isArray(value1) && this.valueIsString(value2)) || (Array.isArray(value2) && this.valueIsString(value1));\r\n    }\r\n    bothValuesAreObjects(value1, value2) {\r\n        return this.valueIsObject(value1) && this.valueIsObject(value2);\r\n    }\r\n    bothValuesAreStrings(value1, value2) {\r\n        return this.valueIsString(value1) && this.valueIsString(value2);\r\n    }\r\n    bothValuesAreArrays(value1, value2) {\r\n        return Array.isArray(value1) && Array.isArray(value2);\r\n    }\r\n    valueIsString(value) {\r\n        return typeof value === 'string' || value instanceof String;\r\n    }\r\n    valueIsObject(value) {\r\n        return typeof value === 'object';\r\n    }\r\n    arraysStrictEqual(arr1, arr2) {\r\n        if (arr1.length !== arr2.length) {\r\n            return false;\r\n        }\r\n        for (let i = arr1.length; i--;) {\r\n            if (arr1[i] !== arr2[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    arraysHaveEqualContent(arr1, arr2) {\r\n        if (arr1.length !== arr2.length) {\r\n            return false;\r\n        }\r\n        return arr1.some((v) => arr2.includes(v));\r\n    }\r\n    isNullOrUndefined(val) {\r\n        return val === null || val === undefined;\r\n    }\r\n}\r\nEqualityService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: EqualityService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nEqualityService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: EqualityService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: EqualityService, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nclass StateValidationService {\r\n    constructor(storagePersistenceService, tokenValidationService, tokenHelperService, loggerService, configurationProvider, equalityService, flowHelper) {\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.tokenValidationService = tokenValidationService;\r\n        this.tokenHelperService = tokenHelperService;\r\n        this.loggerService = loggerService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.equalityService = equalityService;\r\n        this.flowHelper = flowHelper;\r\n    }\r\n    getValidatedStateResult(callbackContext, configId) {\r\n        if (!callbackContext) {\r\n            return new StateValidationResult('', '', false, {});\r\n        }\r\n        if (callbackContext.authResult.error) {\r\n            return new StateValidationResult('', '', false, {});\r\n        }\r\n        return this.validateState(callbackContext, configId);\r\n    }\r\n    validateState(callbackContext, configId) {\r\n        const toReturn = new StateValidationResult();\r\n        const authStateControl = this.storagePersistenceService.read('authStateControl', configId);\r\n        if (!this.tokenValidationService.validateStateFromHashCallback(callbackContext.authResult.state, authStateControl, configId)) {\r\n            this.loggerService.logWarning(configId, 'authCallback incorrect state');\r\n            toReturn.state = ValidationResult.StatesDoNotMatch;\r\n            this.handleUnsuccessfulValidation(configId);\r\n            return toReturn;\r\n        }\r\n        const isCurrentFlowImplicitFlowWithAccessToken = this.flowHelper.isCurrentFlowImplicitFlowWithAccessToken(configId);\r\n        const isCurrentFlowCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(configId);\r\n        if (isCurrentFlowImplicitFlowWithAccessToken || isCurrentFlowCodeFlow) {\r\n            toReturn.accessToken = callbackContext.authResult.access_token;\r\n        }\r\n        if (callbackContext.authResult.id_token) {\r\n            const { clientId, issValidationOff, maxIdTokenIatOffsetAllowedInSeconds, disableIatOffsetValidation, ignoreNonceAfterRefresh } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n            toReturn.idToken = callbackContext.authResult.id_token;\r\n            toReturn.decodedIdToken = this.tokenHelperService.getPayloadFromToken(toReturn.idToken, false, configId);\r\n            if (!this.tokenValidationService.validateSignatureIdToken(toReturn.idToken, callbackContext.jwtKeys, configId)) {\r\n                this.loggerService.logDebug(configId, 'authCallback Signature validation failed id_token');\r\n                toReturn.state = ValidationResult.SignatureFailed;\r\n                this.handleUnsuccessfulValidation(configId);\r\n                return toReturn;\r\n            }\r\n            const authNonce = this.storagePersistenceService.read('authNonce', configId);\r\n            if (!this.tokenValidationService.validateIdTokenNonce(toReturn.decodedIdToken, authNonce, ignoreNonceAfterRefresh, configId)) {\r\n                this.loggerService.logWarning(configId, 'authCallback incorrect nonce, did you call the checkAuth() method multiple times?');\r\n                toReturn.state = ValidationResult.IncorrectNonce;\r\n                this.handleUnsuccessfulValidation(configId);\r\n                return toReturn;\r\n            }\r\n            if (!this.tokenValidationService.validateRequiredIdToken(toReturn.decodedIdToken, configId)) {\r\n                this.loggerService.logDebug(configId, 'authCallback Validation, one of the REQUIRED properties missing from id_token');\r\n                toReturn.state = ValidationResult.RequiredPropertyMissing;\r\n                this.handleUnsuccessfulValidation(configId);\r\n                return toReturn;\r\n            }\r\n            if (!this.tokenValidationService.validateIdTokenIatMaxOffset(toReturn.decodedIdToken, maxIdTokenIatOffsetAllowedInSeconds, disableIatOffsetValidation, configId)) {\r\n                this.loggerService.logWarning(configId, 'authCallback Validation, iat rejected id_token was issued too far away from the current time');\r\n                toReturn.state = ValidationResult.MaxOffsetExpired;\r\n                this.handleUnsuccessfulValidation(configId);\r\n                return toReturn;\r\n            }\r\n            const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n            if (authWellKnownEndPoints) {\r\n                if (issValidationOff) {\r\n                    this.loggerService.logDebug(configId, 'iss validation is turned off, this is not recommended!');\r\n                }\r\n                else if (!issValidationOff &&\r\n                    !this.tokenValidationService.validateIdTokenIss(toReturn.decodedIdToken, authWellKnownEndPoints.issuer, configId)) {\r\n                    this.loggerService.logWarning(configId, 'authCallback incorrect iss does not match authWellKnownEndpoints issuer');\r\n                    toReturn.state = ValidationResult.IssDoesNotMatchIssuer;\r\n                    this.handleUnsuccessfulValidation(configId);\r\n                    return toReturn;\r\n                }\r\n            }\r\n            else {\r\n                this.loggerService.logWarning(configId, 'authWellKnownEndpoints is undefined');\r\n                toReturn.state = ValidationResult.NoAuthWellKnownEndPoints;\r\n                this.handleUnsuccessfulValidation(configId);\r\n                return toReturn;\r\n            }\r\n            if (!this.tokenValidationService.validateIdTokenAud(toReturn.decodedIdToken, clientId, configId)) {\r\n                this.loggerService.logWarning(configId, 'authCallback incorrect aud');\r\n                toReturn.state = ValidationResult.IncorrectAud;\r\n                this.handleUnsuccessfulValidation(configId);\r\n                return toReturn;\r\n            }\r\n            if (!this.tokenValidationService.validateIdTokenAzpExistsIfMoreThanOneAud(toReturn.decodedIdToken)) {\r\n                this.loggerService.logWarning(configId, 'authCallback missing azp');\r\n                toReturn.state = ValidationResult.IncorrectAzp;\r\n                this.handleUnsuccessfulValidation(configId);\r\n                return toReturn;\r\n            }\r\n            if (!this.tokenValidationService.validateIdTokenAzpValid(toReturn.decodedIdToken, clientId)) {\r\n                this.loggerService.logWarning(configId, 'authCallback incorrect azp');\r\n                toReturn.state = ValidationResult.IncorrectAzp;\r\n                this.handleUnsuccessfulValidation(configId);\r\n                return toReturn;\r\n            }\r\n            if (!this.isIdTokenAfterRefreshTokenRequestValid(callbackContext, toReturn.decodedIdToken, configId)) {\r\n                this.loggerService.logWarning(configId, 'authCallback pre, post id_token claims do not match in refresh');\r\n                toReturn.state = ValidationResult.IncorrectIdTokenClaimsAfterRefresh;\r\n                this.handleUnsuccessfulValidation(configId);\r\n                return toReturn;\r\n            }\r\n            if (!this.tokenValidationService.validateIdTokenExpNotExpired(toReturn.decodedIdToken, configId)) {\r\n                this.loggerService.logWarning(configId, 'authCallback id token expired');\r\n                toReturn.state = ValidationResult.TokenExpired;\r\n                this.handleUnsuccessfulValidation(configId);\r\n                return toReturn;\r\n            }\r\n        }\r\n        else {\r\n            this.loggerService.logDebug(configId, 'No id_token found, skipping id_token validation');\r\n        }\r\n        // flow id_token\r\n        if (!isCurrentFlowImplicitFlowWithAccessToken && !isCurrentFlowCodeFlow) {\r\n            toReturn.authResponseIsValid = true;\r\n            toReturn.state = ValidationResult.Ok;\r\n            this.handleSuccessfulValidation(configId);\r\n            this.handleUnsuccessfulValidation(configId);\r\n            return toReturn;\r\n        }\r\n        // only do check if id_token returned, no always the case when using refresh tokens\r\n        if (callbackContext.authResult.id_token) {\r\n            const idTokenHeader = this.tokenHelperService.getHeaderFromToken(toReturn.idToken, false, configId);\r\n            // The at_hash is optional for the code flow\r\n            if (isCurrentFlowCodeFlow && !toReturn.decodedIdToken.at_hash) {\r\n                this.loggerService.logDebug(configId, 'Code Flow active, and no at_hash in the id_token, skipping check!');\r\n            }\r\n            else if (!this.tokenValidationService.validateIdTokenAtHash(toReturn.accessToken, toReturn.decodedIdToken.at_hash, idTokenHeader.alg, // 'RSA256'\r\n            configId) ||\r\n                !toReturn.accessToken) {\r\n                this.loggerService.logWarning(configId, 'authCallback incorrect at_hash');\r\n                toReturn.state = ValidationResult.IncorrectAtHash;\r\n                this.handleUnsuccessfulValidation(configId);\r\n                return toReturn;\r\n            }\r\n        }\r\n        toReturn.authResponseIsValid = true;\r\n        toReturn.state = ValidationResult.Ok;\r\n        this.handleSuccessfulValidation(configId);\r\n        return toReturn;\r\n    }\r\n    isIdTokenAfterRefreshTokenRequestValid(callbackContext, newIdToken, configId) {\r\n        const { useRefreshToken, disableRefreshIdTokenAuthTimeValidation } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!useRefreshToken) {\r\n            return true;\r\n        }\r\n        if (!callbackContext.existingIdToken) {\r\n            return true;\r\n        }\r\n        const decodedIdToken = this.tokenHelperService.getPayloadFromToken(callbackContext.existingIdToken, false, configId);\r\n        // Upon successful validation of the Refresh Token, the response body is the Token Response of Section 3.1.3.3\r\n        // except that it might not contain an id_token.\r\n        // If an ID Token is returned as a result of a token refresh request, the following requirements apply:\r\n        // its iss Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\r\n        if (decodedIdToken.iss !== newIdToken.iss) {\r\n            this.loggerService.logDebug(configId, `iss do not match: ${decodedIdToken.iss} ${newIdToken.iss}`);\r\n            return false;\r\n        }\r\n        // its azp Claim Value MUST be the same as in the ID Token issued when the original authentication occurred;\r\n        //   if no azp Claim was present in the original ID Token, one MUST NOT be present in the new ID Token, and\r\n        // otherwise, the same rules apply as apply when issuing an ID Token at the time of the original authentication.\r\n        if (decodedIdToken.azp !== newIdToken.azp) {\r\n            this.loggerService.logDebug(configId, `azp do not match: ${decodedIdToken.azp} ${newIdToken.azp}`);\r\n            return false;\r\n        }\r\n        // its sub Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\r\n        if (decodedIdToken.sub !== newIdToken.sub) {\r\n            this.loggerService.logDebug(configId, `sub do not match: ${decodedIdToken.sub} ${newIdToken.sub}`);\r\n            return false;\r\n        }\r\n        // its aud Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\r\n        if (!this.equalityService.isStringEqualOrNonOrderedArrayEqual(decodedIdToken === null || decodedIdToken === void 0 ? void 0 : decodedIdToken.aud, newIdToken === null || newIdToken === void 0 ? void 0 : newIdToken.aud)) {\r\n            this.loggerService.logDebug(configId, `aud in new id_token is not valid: '${decodedIdToken === null || decodedIdToken === void 0 ? void 0 : decodedIdToken.aud}' '${newIdToken.aud}'`);\r\n            return false;\r\n        }\r\n        if (disableRefreshIdTokenAuthTimeValidation) {\r\n            return true;\r\n        }\r\n        // its iat Claim MUST represent the time that the new ID Token is issued,\r\n        // if the ID Token contains an auth_time Claim, its value MUST represent the time of the original authentication\r\n        // - not the time that the new ID token is issued,\r\n        if (decodedIdToken.auth_time !== newIdToken.auth_time) {\r\n            this.loggerService.logDebug(configId, `auth_time do not match: ${decodedIdToken.auth_time} ${newIdToken.auth_time}`);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    handleSuccessfulValidation(configId) {\r\n        const { autoCleanStateAfterAuthentication } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        this.storagePersistenceService.write('authNonce', null, configId);\r\n        if (autoCleanStateAfterAuthentication) {\r\n            this.storagePersistenceService.write('authStateControl', '', configId);\r\n        }\r\n        this.loggerService.logDebug(configId, 'authCallback token(s) validated, continue');\r\n    }\r\n    handleUnsuccessfulValidation(configId) {\r\n        const { autoCleanStateAfterAuthentication } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        this.storagePersistenceService.write('authNonce', null, configId);\r\n        if (autoCleanStateAfterAuthentication) {\r\n            this.storagePersistenceService.write('authStateControl', '', configId);\r\n        }\r\n        this.loggerService.logDebug(configId, 'authCallback token(s) invalid');\r\n    }\r\n}\r\nStateValidationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: StateValidationService, deps: [{ token: StoragePersistenceService }, { token: TokenValidationService }, { token: TokenHelperService }, { token: LoggerService }, { token: ConfigurationProvider }, { token: EqualityService }, { token: FlowHelper }], target: i0.ɵɵFactoryTarget.Injectable });\r\nStateValidationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: StateValidationService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: StateValidationService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: TokenValidationService }, { type: TokenHelperService }, { type: LoggerService }, { type: ConfigurationProvider }, { type: EqualityService }, { type: FlowHelper }]; } });\n\nclass StateValidationCallbackHandlerService {\r\n    constructor(loggerService, stateValidationService, authStateService, resetAuthDataService, doc) {\r\n        this.loggerService = loggerService;\r\n        this.stateValidationService = stateValidationService;\r\n        this.authStateService = authStateService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.doc = doc;\r\n    }\r\n    // STEP 4 All flows\r\n    callbackStateValidation(callbackContext, configId) {\r\n        const validationResult = this.stateValidationService.getValidatedStateResult(callbackContext, configId);\r\n        callbackContext.validationResult = validationResult;\r\n        if (validationResult.authResponseIsValid) {\r\n            this.authStateService.setAuthorizationData(validationResult.accessToken, callbackContext.authResult, configId);\r\n            return of(callbackContext);\r\n        }\r\n        else {\r\n            const errorMessage = `authorizedCallback, token(s) validation failed, resetting. Hash: ${this.doc.location.hash}`;\r\n            this.loggerService.logWarning(configId, errorMessage);\r\n            this.resetAuthDataService.resetAuthorizationData(configId);\r\n            this.publishUnauthorizedState(callbackContext.validationResult, callbackContext.isRenewProcess);\r\n            return throwError(errorMessage);\r\n        }\r\n    }\r\n    publishUnauthorizedState(stateValidationResult, isRenewProcess) {\r\n        this.authStateService.updateAndPublishAuthState({\r\n            isAuthenticated: false,\r\n            validationResult: stateValidationResult.state,\r\n            isRenewProcess,\r\n        });\r\n    }\r\n}\r\nStateValidationCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: StateValidationCallbackHandlerService, deps: [{ token: LoggerService }, { token: StateValidationService }, { token: AuthStateService }, { token: ResetAuthDataService }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nStateValidationCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: StateValidationCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: StateValidationCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: StateValidationService }, { type: AuthStateService }, { type: ResetAuthDataService }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }]; } });\n\nclass RefreshSessionCallbackHandlerService {\r\n    constructor(loggerService, authStateService, flowsDataService) {\r\n        this.loggerService = loggerService;\r\n        this.authStateService = authStateService;\r\n        this.flowsDataService = flowsDataService;\r\n    }\r\n    // STEP 1 Refresh session\r\n    refreshSessionWithRefreshTokens(configId) {\r\n        const stateData = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\r\n        this.loggerService.logDebug(configId, 'RefreshSession created. Adding myautostate: ' + stateData);\r\n        const refreshToken = this.authStateService.getRefreshToken(configId);\r\n        const idToken = this.authStateService.getIdToken(configId);\r\n        if (refreshToken) {\r\n            const callbackContext = {\r\n                code: null,\r\n                refreshToken,\r\n                state: stateData,\r\n                sessionState: null,\r\n                authResult: null,\r\n                isRenewProcess: true,\r\n                jwtKeys: null,\r\n                validationResult: null,\r\n                existingIdToken: idToken,\r\n            };\r\n            this.loggerService.logDebug(configId, 'found refresh code, obtaining new credentials with refresh code');\r\n            // Nonce is not used with refresh tokens; but Key cloak may send it anyway\r\n            this.flowsDataService.setNonce(TokenValidationService.refreshTokenNoncePlaceholder, configId);\r\n            return of(callbackContext);\r\n        }\r\n        else {\r\n            const errorMessage = 'no refresh token found, please login';\r\n            this.loggerService.logError(configId, errorMessage);\r\n            return throwError(errorMessage);\r\n        }\r\n    }\r\n}\r\nRefreshSessionCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshSessionCallbackHandlerService, deps: [{ token: LoggerService }, { token: AuthStateService }, { token: FlowsDataService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRefreshSessionCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshSessionCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshSessionCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: AuthStateService }, { type: FlowsDataService }]; } });\n\nclass RefreshTokenCallbackHandlerService {\r\n    constructor(urlService, loggerService, configurationProvider, dataService, storagePersistenceService) {\r\n        this.urlService = urlService;\r\n        this.loggerService = loggerService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.dataService = dataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n    }\r\n    // STEP 2 Refresh Token\r\n    refreshTokensRequestTokens(callbackContext, configId, customParamsRefresh) {\r\n        let headers = new HttpHeaders();\r\n        headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\r\n        const authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        const tokenEndpoint = authWellknownEndpoints === null || authWellknownEndpoints === void 0 ? void 0 : authWellknownEndpoints.tokenEndpoint;\r\n        if (!tokenEndpoint) {\r\n            return throwError('Token Endpoint not defined');\r\n        }\r\n        const data = this.urlService.createBodyForCodeFlowRefreshTokensRequest(callbackContext.refreshToken, configId, customParamsRefresh);\r\n        return this.dataService.post(tokenEndpoint, data, configId, headers).pipe(switchMap((response) => {\r\n            this.loggerService.logDebug(configId, 'token refresh response: ', response);\r\n            let authResult = new Object();\r\n            authResult = response;\r\n            authResult.state = callbackContext.state;\r\n            callbackContext.authResult = authResult;\r\n            return of(callbackContext);\r\n        }), retryWhen((error) => this.handleRefreshRetry(error, configId)), catchError((error) => {\r\n            const { authority } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n            const errorMessage = `OidcService code request ${authority}`;\r\n            this.loggerService.logError(configId, errorMessage, error);\r\n            return throwError(errorMessage);\r\n        }));\r\n    }\r\n    handleRefreshRetry(errors, configId) {\r\n        return errors.pipe(mergeMap((error) => {\r\n            // retry token refresh if there is no internet connection\r\n            if (error && error instanceof HttpErrorResponse && error.error instanceof ProgressEvent && error.error.type === 'error') {\r\n                const { authority, refreshTokenRetryInSeconds } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n                const errorMessage = `OidcService code request ${authority} - no internet connection`;\r\n                this.loggerService.logWarning(configId, errorMessage, error);\r\n                return timer(refreshTokenRetryInSeconds * 1000);\r\n            }\r\n            return throwError(error);\r\n        }));\r\n    }\r\n}\r\nRefreshTokenCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshTokenCallbackHandlerService, deps: [{ token: UrlService }, { token: LoggerService }, { token: ConfigurationProvider }, { token: DataService }, { token: StoragePersistenceService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRefreshTokenCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshTokenCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshTokenCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: UrlService }, { type: LoggerService }, { type: ConfigurationProvider }, { type: DataService }, { type: StoragePersistenceService }]; } });\n\nclass FlowsService {\r\n    constructor(codeFlowCallbackHandlerService, implicitFlowCallbackHandlerService, historyJwtKeysCallbackHandlerService, userHandlerService, stateValidationCallbackHandlerService, refreshSessionCallbackHandlerService, refreshTokenCallbackHandlerService) {\r\n        this.codeFlowCallbackHandlerService = codeFlowCallbackHandlerService;\r\n        this.implicitFlowCallbackHandlerService = implicitFlowCallbackHandlerService;\r\n        this.historyJwtKeysCallbackHandlerService = historyJwtKeysCallbackHandlerService;\r\n        this.userHandlerService = userHandlerService;\r\n        this.stateValidationCallbackHandlerService = stateValidationCallbackHandlerService;\r\n        this.refreshSessionCallbackHandlerService = refreshSessionCallbackHandlerService;\r\n        this.refreshTokenCallbackHandlerService = refreshTokenCallbackHandlerService;\r\n    }\r\n    processCodeFlowCallback(urlToCheck, configId) {\r\n        return this.codeFlowCallbackHandlerService.codeFlowCallback(urlToCheck, configId).pipe(concatMap((callbackContext) => this.codeFlowCallbackHandlerService.codeFlowCodeRequest(callbackContext, configId)), concatMap((callbackContext) => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, configId)), concatMap((callbackContext) => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, configId)), concatMap((callbackContext) => this.userHandlerService.callbackUser(callbackContext, configId)));\r\n    }\r\n    processSilentRenewCodeFlowCallback(firstContext, configId) {\r\n        return this.codeFlowCallbackHandlerService.codeFlowCodeRequest(firstContext, configId).pipe(concatMap((callbackContext) => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, configId)), concatMap((callbackContext) => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, configId)), concatMap((callbackContext) => this.userHandlerService.callbackUser(callbackContext, configId)));\r\n    }\r\n    processImplicitFlowCallback(configId, hash) {\r\n        return this.implicitFlowCallbackHandlerService.implicitFlowCallback(configId, hash).pipe(concatMap((callbackContext) => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, configId)), concatMap((callbackContext) => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, configId)), concatMap((callbackContext) => this.userHandlerService.callbackUser(callbackContext, configId)));\r\n    }\r\n    processRefreshToken(configId, customParamsRefresh) {\r\n        return this.refreshSessionCallbackHandlerService.refreshSessionWithRefreshTokens(configId).pipe(concatMap((callbackContext) => this.refreshTokenCallbackHandlerService.refreshTokensRequestTokens(callbackContext, configId, customParamsRefresh)), concatMap((callbackContext) => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, configId)), concatMap((callbackContext) => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, configId)), concatMap((callbackContext) => this.userHandlerService.callbackUser(callbackContext, configId)));\r\n    }\r\n}\r\nFlowsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: FlowsService, deps: [{ token: CodeFlowCallbackHandlerService }, { token: ImplicitFlowCallbackHandlerService }, { token: HistoryJwtKeysCallbackHandlerService }, { token: UserCallbackHandlerService }, { token: StateValidationCallbackHandlerService }, { token: RefreshSessionCallbackHandlerService }, { token: RefreshTokenCallbackHandlerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nFlowsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: FlowsService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: FlowsService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: CodeFlowCallbackHandlerService }, { type: ImplicitFlowCallbackHandlerService }, { type: HistoryJwtKeysCallbackHandlerService }, { type: UserCallbackHandlerService }, { type: StateValidationCallbackHandlerService }, { type: RefreshSessionCallbackHandlerService }, { type: RefreshTokenCallbackHandlerService }]; } });\n\nclass IntervalService {\r\n    constructor(zone) {\r\n        this.zone = zone;\r\n        this.runTokenValidationRunning = null;\r\n    }\r\n    stopPeriodicTokenCheck() {\r\n        if (this.runTokenValidationRunning) {\r\n            this.runTokenValidationRunning.unsubscribe();\r\n            this.runTokenValidationRunning = null;\r\n        }\r\n    }\r\n    startPeriodicTokenCheck(repeatAfterSeconds) {\r\n        const millisecondsDelayBetweenTokenCheck = repeatAfterSeconds * 1000;\r\n        return new Observable((subscriber) => {\r\n            let intervalId;\r\n            this.zone.runOutsideAngular(() => {\r\n                intervalId = setInterval(() => this.zone.run(() => subscriber.next()), millisecondsDelayBetweenTokenCheck);\r\n            });\r\n            return () => {\r\n                clearInterval(intervalId);\r\n            };\r\n        });\r\n    }\r\n}\r\nIntervalService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: IntervalService, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });\r\nIntervalService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: IntervalService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: IntervalService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: i0.NgZone }]; } });\n\nclass ImplicitFlowCallbackService {\r\n    constructor(flowsService, configurationProvider, router, flowsDataService, intervalService) {\r\n        this.flowsService = flowsService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.router = router;\r\n        this.flowsDataService = flowsDataService;\r\n        this.intervalService = intervalService;\r\n    }\r\n    authenticatedImplicitFlowCallback(configId, hash) {\r\n        const isRenewProcess = this.flowsDataService.isSilentRenewRunning(configId);\r\n        const { triggerAuthorizationResultEvent, postLoginRoute, unauthorizedRoute } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        return this.flowsService.processImplicitFlowCallback(configId, hash).pipe(tap((callbackContext) => {\r\n            if (!triggerAuthorizationResultEvent && !callbackContext.isRenewProcess) {\r\n                this.router.navigateByUrl(postLoginRoute);\r\n            }\r\n        }), catchError((error) => {\r\n            this.flowsDataService.resetSilentRenewRunning(configId);\r\n            this.intervalService.stopPeriodicTokenCheck();\r\n            if (!triggerAuthorizationResultEvent && !isRenewProcess) {\r\n                this.router.navigateByUrl(unauthorizedRoute);\r\n            }\r\n            return throwError(error);\r\n        }));\r\n    }\r\n}\r\nImplicitFlowCallbackService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ImplicitFlowCallbackService, deps: [{ token: FlowsService }, { token: ConfigurationProvider }, { token: i2.Router }, { token: FlowsDataService }, { token: IntervalService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nImplicitFlowCallbackService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ImplicitFlowCallbackService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ImplicitFlowCallbackService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: FlowsService }, { type: ConfigurationProvider }, { type: i2.Router }, { type: FlowsDataService }, { type: IntervalService }]; } });\n\nclass IFrameService {\r\n    constructor(doc, loggerService) {\r\n        this.doc = doc;\r\n        this.loggerService = loggerService;\r\n    }\r\n    getExistingIFrame(identifier) {\r\n        const iFrameOnParent = this.getIFrameFromParentWindow(identifier);\r\n        if (this.isIFrameElement(iFrameOnParent)) {\r\n            return iFrameOnParent;\r\n        }\r\n        const iFrameOnSelf = this.getIFrameFromWindow(identifier);\r\n        if (this.isIFrameElement(iFrameOnSelf)) {\r\n            return iFrameOnSelf;\r\n        }\r\n        return null;\r\n    }\r\n    addIFrameToWindowBody(identifier, configId) {\r\n        const sessionIframe = this.doc.createElement('iframe');\r\n        sessionIframe.id = identifier;\r\n        sessionIframe.title = identifier;\r\n        this.loggerService.logDebug(configId, sessionIframe);\r\n        sessionIframe.style.display = 'none';\r\n        this.doc.body.appendChild(sessionIframe);\r\n        return sessionIframe;\r\n    }\r\n    getIFrameFromParentWindow(identifier) {\r\n        try {\r\n            const iFrameElement = this.doc.defaultView.parent.document.getElementById(identifier);\r\n            if (this.isIFrameElement(iFrameElement)) {\r\n                return iFrameElement;\r\n            }\r\n            return null;\r\n        }\r\n        catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n    getIFrameFromWindow(identifier) {\r\n        const iFrameElement = this.doc.getElementById(identifier);\r\n        if (this.isIFrameElement(iFrameElement)) {\r\n            return iFrameElement;\r\n        }\r\n        return null;\r\n    }\r\n    isIFrameElement(element) {\r\n        return !!element && element instanceof HTMLIFrameElement;\r\n    }\r\n}\r\nIFrameService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: IFrameService, deps: [{ token: DOCUMENT }, { token: LoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nIFrameService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: IFrameService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: IFrameService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }, { type: LoggerService }]; } });\n\nconst IFRAME_FOR_CHECK_SESSION_IDENTIFIER = 'myiFrameForCheckSession';\r\n// http://openid.net/specs/openid-connect-session-1_0-ID4.html\r\nclass CheckSessionService {\r\n    constructor(storagePersistenceService, loggerService, iFrameService, eventService, configurationProvider, zone) {\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.loggerService = loggerService;\r\n        this.iFrameService = iFrameService;\r\n        this.eventService = eventService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.zone = zone;\r\n        this.checkSessionReceived = false;\r\n        this.lastIFrameRefresh = 0;\r\n        this.outstandingMessages = 0;\r\n        this.heartBeatInterval = 3000;\r\n        this.iframeRefreshInterval = 60000;\r\n        this.checkSessionChangedInternal$ = new BehaviorSubject(false);\r\n    }\r\n    get checkSessionChanged$() {\r\n        return this.checkSessionChangedInternal$.asObservable();\r\n    }\r\n    isCheckSessionConfigured(configId) {\r\n        const { startCheckSession } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        return startCheckSession;\r\n    }\r\n    start(configId) {\r\n        if (!!this.scheduledHeartBeatRunning) {\r\n            return;\r\n        }\r\n        const { clientId } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        this.pollServerSession(clientId, configId);\r\n    }\r\n    stop() {\r\n        if (!this.scheduledHeartBeatRunning) {\r\n            return;\r\n        }\r\n        this.clearScheduledHeartBeat();\r\n        this.checkSessionReceived = false;\r\n    }\r\n    serverStateChanged(configId) {\r\n        const { startCheckSession } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        return startCheckSession && this.checkSessionReceived;\r\n    }\r\n    getExistingIframe() {\r\n        return this.iFrameService.getExistingIFrame(IFRAME_FOR_CHECK_SESSION_IDENTIFIER);\r\n    }\r\n    init(configId) {\r\n        if (this.lastIFrameRefresh + this.iframeRefreshInterval > Date.now()) {\r\n            return of(undefined);\r\n        }\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        if (!authWellKnownEndPoints) {\r\n            this.loggerService.logWarning(configId, 'CheckSession - init check session: authWellKnownEndpoints is undefined. Returning.');\r\n            return of();\r\n        }\r\n        const existingIframe = this.getOrCreateIframe(configId);\r\n        const checkSessionIframe = authWellKnownEndPoints.checkSessionIframe;\r\n        if (checkSessionIframe) {\r\n            existingIframe.contentWindow.location.replace(checkSessionIframe);\r\n        }\r\n        else {\r\n            this.loggerService.logWarning(configId, 'CheckSession - init check session: checkSessionIframe is not configured to run');\r\n        }\r\n        return new Observable((observer) => {\r\n            existingIframe.onload = () => {\r\n                this.lastIFrameRefresh = Date.now();\r\n                observer.next();\r\n                observer.complete();\r\n            };\r\n        });\r\n    }\r\n    pollServerSession(clientId, configId) {\r\n        this.outstandingMessages = 0;\r\n        const pollServerSessionRecur = () => {\r\n            this.init(configId)\r\n                .pipe(take(1))\r\n                .subscribe(() => {\r\n                var _a;\r\n                const existingIframe = this.getExistingIframe();\r\n                if (existingIframe && clientId) {\r\n                    this.loggerService.logDebug(configId, `CheckSession - clientId : '${clientId}' - existingIframe: '${existingIframe}'`);\r\n                    const sessionState = this.storagePersistenceService.read('session_state', configId);\r\n                    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n                    if (sessionState && (authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.checkSessionIframe)) {\r\n                        const iframeOrigin = (_a = new URL(authWellKnownEndPoints.checkSessionIframe)) === null || _a === void 0 ? void 0 : _a.origin;\r\n                        this.outstandingMessages++;\r\n                        existingIframe.contentWindow.postMessage(clientId + ' ' + sessionState, iframeOrigin);\r\n                    }\r\n                    else {\r\n                        this.loggerService.logDebug(configId, `CheckSession - session_state is '${sessionState}' - AuthWellKnownEndPoints is '${JSON.stringify(authWellKnownEndPoints, null, 2)}'`);\r\n                        this.checkSessionChangedInternal$.next(true);\r\n                    }\r\n                }\r\n                else {\r\n                    this.loggerService.logWarning(configId, `CheckSession - OidcSecurityCheckSession pollServerSession checkSession IFrame does not exist:\n               clientId : '${clientId}' - existingIframe: '${existingIframe}'`);\r\n                }\r\n                // after sending three messages with no response, fail.\r\n                if (this.outstandingMessages > 3) {\r\n                    this.loggerService.logError(configId, `CheckSession - OidcSecurityCheckSession not receiving check session response messages.\n                            Outstanding messages: '${this.outstandingMessages}'. Server unreachable?`);\r\n                }\r\n                this.zone.runOutsideAngular(() => {\r\n                    this.scheduledHeartBeatRunning = setTimeout(() => this.zone.run(pollServerSessionRecur), this.heartBeatInterval);\r\n                });\r\n            });\r\n        };\r\n        pollServerSessionRecur();\r\n    }\r\n    clearScheduledHeartBeat() {\r\n        clearTimeout(this.scheduledHeartBeatRunning);\r\n        this.scheduledHeartBeatRunning = null;\r\n    }\r\n    messageHandler(configId, e) {\r\n        var _a;\r\n        const existingIFrame = this.getExistingIframe();\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        const startsWith = !!((_a = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.checkSessionIframe) === null || _a === void 0 ? void 0 : _a.startsWith(e.origin));\r\n        this.outstandingMessages = 0;\r\n        if (existingIFrame && startsWith && e.source === existingIFrame.contentWindow) {\r\n            if (e.data === 'error') {\r\n                this.loggerService.logWarning(configId, 'CheckSession - error from check session messageHandler');\r\n            }\r\n            else if (e.data === 'changed') {\r\n                this.loggerService.logDebug(configId, `CheckSession - ${e} from check session messageHandler`);\r\n                this.checkSessionReceived = true;\r\n                this.eventService.fireEvent(EventTypes.CheckSessionReceived, e.data);\r\n                this.checkSessionChangedInternal$.next(true);\r\n            }\r\n            else {\r\n                this.eventService.fireEvent(EventTypes.CheckSessionReceived, e.data);\r\n                this.loggerService.logDebug(configId, `CheckSession - ${e.data} from check session messageHandler`);\r\n            }\r\n        }\r\n    }\r\n    bindMessageEventToIframe(configId) {\r\n        const iframeMessageEvent = this.messageHandler.bind(this, configId);\r\n        window.addEventListener('message', iframeMessageEvent, false);\r\n    }\r\n    getOrCreateIframe(configId) {\r\n        const existingIframe = this.getExistingIframe();\r\n        if (!existingIframe) {\r\n            const frame = this.iFrameService.addIFrameToWindowBody(IFRAME_FOR_CHECK_SESSION_IDENTIFIER, configId);\r\n            this.bindMessageEventToIframe(configId);\r\n            return frame;\r\n        }\r\n        return existingIframe;\r\n    }\r\n}\r\nCheckSessionService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CheckSessionService, deps: [{ token: StoragePersistenceService }, { token: LoggerService }, { token: IFrameService }, { token: PublicEventsService }, { token: ConfigurationProvider }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCheckSessionService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CheckSessionService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CheckSessionService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: LoggerService }, { type: IFrameService }, { type: PublicEventsService }, { type: ConfigurationProvider }, { type: i0.NgZone }]; } });\n\nclass CurrentUrlService {\r\n    constructor(doc) {\r\n        this.doc = doc;\r\n    }\r\n    getStateParamFromCurrentUrl() {\r\n        const currentUrl = this.getCurrentUrl();\r\n        const parsedUrl = new URL(currentUrl);\r\n        const urlParams = new URLSearchParams(parsedUrl.search);\r\n        const stateFromUrl = urlParams.get('state');\r\n        return stateFromUrl;\r\n    }\r\n    currentUrlHasStateParam() {\r\n        return !!this.getStateParamFromCurrentUrl();\r\n    }\r\n    getCurrentUrl() {\r\n        return this.doc.defaultView.location.toString();\r\n    }\r\n}\r\nCurrentUrlService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CurrentUrlService, deps: [{ token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCurrentUrlService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CurrentUrlService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CurrentUrlService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }]; } });\n\nconst IFRAME_FOR_SILENT_RENEW_IDENTIFIER = 'myiFrameForSilentRenew';\r\nclass SilentRenewService {\r\n    constructor(configurationProvider, iFrameService, flowsService, resetAuthDataService, flowsDataService, authStateService, loggerService, flowHelper, implicitFlowCallbackService, intervalService) {\r\n        this.configurationProvider = configurationProvider;\r\n        this.iFrameService = iFrameService;\r\n        this.flowsService = flowsService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.authStateService = authStateService;\r\n        this.loggerService = loggerService;\r\n        this.flowHelper = flowHelper;\r\n        this.implicitFlowCallbackService = implicitFlowCallbackService;\r\n        this.intervalService = intervalService;\r\n        this.refreshSessionWithIFrameCompletedInternal$ = new Subject();\r\n    }\r\n    get refreshSessionWithIFrameCompleted$() {\r\n        return this.refreshSessionWithIFrameCompletedInternal$.asObservable();\r\n    }\r\n    getOrCreateIframe(configId) {\r\n        const existingIframe = this.getExistingIframe();\r\n        if (!existingIframe) {\r\n            return this.iFrameService.addIFrameToWindowBody(IFRAME_FOR_SILENT_RENEW_IDENTIFIER, configId);\r\n        }\r\n        return existingIframe;\r\n    }\r\n    isSilentRenewConfigured(configId) {\r\n        const { useRefreshToken, silentRenew } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        return !useRefreshToken && silentRenew;\r\n    }\r\n    codeFlowCallbackSilentRenewIframe(urlParts, configId) {\r\n        const params = new HttpParams({\r\n            fromString: urlParts[1],\r\n        });\r\n        const error = params.get('error');\r\n        if (error) {\r\n            this.authStateService.updateAndPublishAuthState({\r\n                isAuthenticated: false,\r\n                validationResult: ValidationResult.LoginRequired,\r\n                isRenewProcess: true,\r\n            });\r\n            this.resetAuthDataService.resetAuthorizationData(configId);\r\n            this.flowsDataService.setNonce('', configId);\r\n            this.intervalService.stopPeriodicTokenCheck();\r\n            return throwError(error);\r\n        }\r\n        const code = params.get('code');\r\n        const state = params.get('state');\r\n        const sessionState = params.get('session_state');\r\n        const callbackContext = {\r\n            code,\r\n            refreshToken: null,\r\n            state,\r\n            sessionState,\r\n            authResult: null,\r\n            isRenewProcess: true,\r\n            jwtKeys: null,\r\n            validationResult: null,\r\n            existingIdToken: null,\r\n        };\r\n        return this.flowsService.processSilentRenewCodeFlowCallback(callbackContext, configId).pipe(catchError((errorFromFlow) => {\r\n            this.intervalService.stopPeriodicTokenCheck();\r\n            this.resetAuthDataService.resetAuthorizationData(configId);\r\n            return throwError(errorFromFlow);\r\n        }));\r\n    }\r\n    silentRenewEventHandler(e, configId) {\r\n        this.loggerService.logDebug(configId, 'silentRenewEventHandler');\r\n        if (!e.detail) {\r\n            return;\r\n        }\r\n        let callback$ = of(null);\r\n        const isCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(configId);\r\n        if (isCodeFlow) {\r\n            const urlParts = e.detail.toString().split('?');\r\n            callback$ = this.codeFlowCallbackSilentRenewIframe(urlParts, configId);\r\n        }\r\n        else {\r\n            callback$ = this.implicitFlowCallbackService.authenticatedImplicitFlowCallback(configId, e.detail);\r\n        }\r\n        callback$.subscribe((callbackContext) => {\r\n            this.refreshSessionWithIFrameCompletedInternal$.next(callbackContext);\r\n            this.flowsDataService.resetSilentRenewRunning(configId);\r\n        }, (err) => {\r\n            this.loggerService.logError(configId, 'Error: ' + err);\r\n            this.refreshSessionWithIFrameCompletedInternal$.next(null);\r\n            this.flowsDataService.resetSilentRenewRunning(configId);\r\n        });\r\n    }\r\n    getExistingIframe() {\r\n        return this.iFrameService.getExistingIFrame(IFRAME_FOR_SILENT_RENEW_IDENTIFIER);\r\n    }\r\n}\r\nSilentRenewService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: SilentRenewService, deps: [{ token: ConfigurationProvider }, { token: IFrameService }, { token: FlowsService }, { token: ResetAuthDataService }, { token: FlowsDataService }, { token: AuthStateService }, { token: LoggerService }, { token: FlowHelper }, { token: ImplicitFlowCallbackService }, { token: IntervalService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nSilentRenewService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: SilentRenewService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: SilentRenewService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: ConfigurationProvider }, { type: IFrameService }, { type: FlowsService }, { type: ResetAuthDataService }, { type: FlowsDataService }, { type: AuthStateService }, { type: LoggerService }, { type: FlowHelper }, { type: ImplicitFlowCallbackService }, { type: IntervalService }]; } });\n\nclass CodeFlowCallbackService {\r\n    constructor(flowsService, flowsDataService, intervalService, configurationProvider, router) {\r\n        this.flowsService = flowsService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.intervalService = intervalService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.router = router;\r\n    }\r\n    authenticatedCallbackWithCode(urlToCheck, configId) {\r\n        const isRenewProcess = this.flowsDataService.isSilentRenewRunning(configId);\r\n        const { triggerAuthorizationResultEvent, postLoginRoute, unauthorizedRoute } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        return this.flowsService.processCodeFlowCallback(urlToCheck, configId).pipe(tap((callbackContext) => {\r\n            if (!triggerAuthorizationResultEvent && !callbackContext.isRenewProcess) {\r\n                this.router.navigateByUrl(postLoginRoute);\r\n            }\r\n        }), catchError((error) => {\r\n            this.flowsDataService.resetSilentRenewRunning(configId);\r\n            this.intervalService.stopPeriodicTokenCheck();\r\n            if (!triggerAuthorizationResultEvent && !isRenewProcess) {\r\n                this.router.navigateByUrl(unauthorizedRoute);\r\n            }\r\n            return throwError(error);\r\n        }));\r\n    }\r\n}\r\nCodeFlowCallbackService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CodeFlowCallbackService, deps: [{ token: FlowsService }, { token: FlowsDataService }, { token: IntervalService }, { token: ConfigurationProvider }, { token: i2.Router }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCodeFlowCallbackService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CodeFlowCallbackService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CodeFlowCallbackService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: FlowsService }, { type: FlowsDataService }, { type: IntervalService }, { type: ConfigurationProvider }, { type: i2.Router }]; } });\n\nclass CallbackService {\r\n    constructor(urlService, flowHelper, implicitFlowCallbackService, codeFlowCallbackService) {\r\n        this.urlService = urlService;\r\n        this.flowHelper = flowHelper;\r\n        this.implicitFlowCallbackService = implicitFlowCallbackService;\r\n        this.codeFlowCallbackService = codeFlowCallbackService;\r\n        this.stsCallbackInternal$ = new Subject();\r\n    }\r\n    get stsCallback$() {\r\n        return this.stsCallbackInternal$.asObservable();\r\n    }\r\n    isCallback(currentUrl) {\r\n        return this.urlService.isCallbackFromSts(currentUrl);\r\n    }\r\n    handleCallbackAndFireEvents(currentCallbackUrl, configId) {\r\n        let callback$;\r\n        if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\r\n            callback$ = this.codeFlowCallbackService.authenticatedCallbackWithCode(currentCallbackUrl, configId);\r\n        }\r\n        else if (this.flowHelper.isCurrentFlowAnyImplicitFlow(configId)) {\r\n            callback$ = this.implicitFlowCallbackService.authenticatedImplicitFlowCallback(configId);\r\n        }\r\n        return callback$.pipe(tap(() => this.stsCallbackInternal$.next()));\r\n    }\r\n}\r\nCallbackService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CallbackService, deps: [{ token: UrlService }, { token: FlowHelper }, { token: ImplicitFlowCallbackService }, { token: CodeFlowCallbackService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCallbackService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CallbackService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CallbackService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: UrlService }, { type: FlowHelper }, { type: ImplicitFlowCallbackService }, { type: CodeFlowCallbackService }]; } });\n\nconst WELL_KNOWN_SUFFIX = `/.well-known/openid-configuration`;\r\nclass AuthWellKnownDataService {\r\n    constructor(http) {\r\n        this.http = http;\r\n    }\r\n    getWellKnownEndPointsFromUrl(authWellknownEndpoint, configId) {\r\n        return this.getWellKnownDocument(authWellknownEndpoint, configId).pipe(map((wellKnownEndpoints) => ({\r\n            issuer: wellKnownEndpoints.issuer,\r\n            jwksUri: wellKnownEndpoints.jwks_uri,\r\n            authorizationEndpoint: wellKnownEndpoints.authorization_endpoint,\r\n            tokenEndpoint: wellKnownEndpoints.token_endpoint,\r\n            userInfoEndpoint: wellKnownEndpoints.userinfo_endpoint,\r\n            endSessionEndpoint: wellKnownEndpoints.end_session_endpoint,\r\n            checkSessionIframe: wellKnownEndpoints.check_session_iframe,\r\n            revocationEndpoint: wellKnownEndpoints.revocation_endpoint,\r\n            introspectionEndpoint: wellKnownEndpoints.introspection_endpoint,\r\n            parEndpoint: wellKnownEndpoints.pushed_authorization_request_endpoint,\r\n        })));\r\n    }\r\n    getWellKnownDocument(wellKnownEndpoint, configId) {\r\n        let url = wellKnownEndpoint;\r\n        if (!wellKnownEndpoint.includes(WELL_KNOWN_SUFFIX)) {\r\n            url = `${wellKnownEndpoint}${WELL_KNOWN_SUFFIX}`;\r\n        }\r\n        return this.http.get(url, configId).pipe(retry(2));\r\n    }\r\n}\r\nAuthWellKnownDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthWellKnownDataService, deps: [{ token: DataService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAuthWellKnownDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthWellKnownDataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthWellKnownDataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: DataService }]; } });\n\nclass AuthWellKnownService {\r\n    constructor(publicEventsService, dataService, storagePersistenceService) {\r\n        this.publicEventsService = publicEventsService;\r\n        this.dataService = dataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n    }\r\n    getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId) {\r\n        const alreadySavedWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        if (!!alreadySavedWellKnownEndpoints) {\r\n            return of(alreadySavedWellKnownEndpoints);\r\n        }\r\n        return this.getWellKnownEndPointsFromUrl(authWellknownEndpointUrl, configId).pipe(tap((mappedWellKnownEndpoints) => this.storeWellKnownEndpoints(configId, mappedWellKnownEndpoints)), catchError((error) => {\r\n            this.publicEventsService.fireEvent(EventTypes.ConfigLoadingFailed, null);\r\n            return throwError(error);\r\n        }));\r\n    }\r\n    storeWellKnownEndpoints(configId, mappedWellKnownEndpoints) {\r\n        this.storagePersistenceService.write('authWellKnownEndPoints', mappedWellKnownEndpoints, configId);\r\n    }\r\n    getWellKnownEndPointsFromUrl(authWellknownEndpointUrl, configId) {\r\n        return this.dataService.getWellKnownEndPointsFromUrl(authWellknownEndpointUrl, configId);\r\n    }\r\n}\r\nAuthWellKnownService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthWellKnownService, deps: [{ token: PublicEventsService }, { token: AuthWellKnownDataService }, { token: StoragePersistenceService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAuthWellKnownService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthWellKnownService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthWellKnownService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: PublicEventsService }, { type: AuthWellKnownDataService }, { type: StoragePersistenceService }]; } });\n\nclass RefreshSessionIframeService {\r\n    constructor(doc, loggerService, urlService, silentRenewService, rendererFactory) {\r\n        this.doc = doc;\r\n        this.loggerService = loggerService;\r\n        this.urlService = urlService;\r\n        this.silentRenewService = silentRenewService;\r\n        this.renderer = rendererFactory.createRenderer(null, null);\r\n    }\r\n    refreshSessionWithIframe(configId, customParams) {\r\n        this.loggerService.logDebug(configId, 'BEGIN refresh session Authorize Iframe renew');\r\n        const url = this.urlService.getRefreshSessionSilentRenewUrl(configId, customParams);\r\n        return this.sendAuthorizeRequestUsingSilentRenew(url, configId);\r\n    }\r\n    sendAuthorizeRequestUsingSilentRenew(url, configId) {\r\n        const sessionIframe = this.silentRenewService.getOrCreateIframe(configId);\r\n        this.initSilentRenewRequest(configId);\r\n        this.loggerService.logDebug(configId, 'sendAuthorizeRequestUsingSilentRenew for URL:' + url);\r\n        return new Observable((observer) => {\r\n            const onLoadHandler = () => {\r\n                sessionIframe.removeEventListener('load', onLoadHandler);\r\n                this.loggerService.logDebug(configId, 'removed event listener from IFrame');\r\n                observer.next(true);\r\n                observer.complete();\r\n            };\r\n            sessionIframe.addEventListener('load', onLoadHandler);\r\n            sessionIframe.contentWindow.location.replace(url);\r\n        });\r\n    }\r\n    initSilentRenewRequest(configId) {\r\n        const instanceId = Math.random();\r\n        const initDestroyHandler = this.renderer.listen('window', 'oidc-silent-renew-init', (e) => {\r\n            if (e.detail !== instanceId) {\r\n                initDestroyHandler();\r\n                renewDestroyHandler();\r\n            }\r\n        });\r\n        const renewDestroyHandler = this.renderer.listen('window', 'oidc-silent-renew-message', (e) => this.silentRenewService.silentRenewEventHandler(e, configId));\r\n        this.doc.defaultView.dispatchEvent(new CustomEvent('oidc-silent-renew-init', {\r\n            detail: instanceId,\r\n        }));\r\n    }\r\n}\r\nRefreshSessionIframeService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshSessionIframeService, deps: [{ token: DOCUMENT }, { token: LoggerService }, { token: UrlService }, { token: SilentRenewService }, { token: i0.RendererFactory2 }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRefreshSessionIframeService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshSessionIframeService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshSessionIframeService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }, { type: LoggerService }, { type: UrlService }, { type: SilentRenewService }, { type: i0.RendererFactory2 }]; } });\n\nclass RefreshSessionRefreshTokenService {\r\n    constructor(loggerService, resetAuthDataService, flowsService, intervalService) {\r\n        this.loggerService = loggerService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.flowsService = flowsService;\r\n        this.intervalService = intervalService;\r\n    }\r\n    refreshSessionWithRefreshTokens(configId, customParamsRefresh) {\r\n        this.loggerService.logDebug(configId, 'BEGIN refresh session Authorize');\r\n        return this.flowsService.processRefreshToken(configId, customParamsRefresh).pipe(catchError((error) => {\r\n            this.intervalService.stopPeriodicTokenCheck();\r\n            this.resetAuthDataService.resetAuthorizationData(configId);\r\n            return throwError(error);\r\n        }));\r\n    }\r\n}\r\nRefreshSessionRefreshTokenService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshSessionRefreshTokenService, deps: [{ token: LoggerService }, { token: ResetAuthDataService }, { token: FlowsService }, { token: IntervalService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRefreshSessionRefreshTokenService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshSessionRefreshTokenService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshSessionRefreshTokenService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: ResetAuthDataService }, { type: FlowsService }, { type: IntervalService }]; } });\n\nconst MAX_RETRY_ATTEMPTS = 3;\r\nclass RefreshSessionService {\r\n    constructor(flowHelper, configurationProvider, flowsDataService, loggerService, silentRenewService, authStateService, authWellKnownService, refreshSessionIframeService, storagePersistenceService, refreshSessionRefreshTokenService, userService) {\r\n        this.flowHelper = flowHelper;\r\n        this.configurationProvider = configurationProvider;\r\n        this.flowsDataService = flowsDataService;\r\n        this.loggerService = loggerService;\r\n        this.silentRenewService = silentRenewService;\r\n        this.authStateService = authStateService;\r\n        this.authWellKnownService = authWellKnownService;\r\n        this.refreshSessionIframeService = refreshSessionIframeService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.refreshSessionRefreshTokenService = refreshSessionRefreshTokenService;\r\n        this.userService = userService;\r\n    }\r\n    userForceRefreshSession(configId, extraCustomParams) {\r\n        this.persistCustomParams(extraCustomParams, configId);\r\n        return this.forceRefreshSession(configId, extraCustomParams);\r\n    }\r\n    forceRefreshSession(configId, extraCustomParams) {\r\n        const { customParamsRefreshTokenRequest } = this.configurationProvider.getOpenIDConfiguration();\r\n        const mergedParams = Object.assign(Object.assign({}, customParamsRefreshTokenRequest), extraCustomParams);\r\n        if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(configId)) {\r\n            return this.startRefreshSession(configId, mergedParams).pipe(map(() => {\r\n                const isAuthenticated = this.authStateService.areAuthStorageTokensValid(configId);\r\n                if (isAuthenticated) {\r\n                    return {\r\n                        idToken: this.authStateService.getIdToken(configId),\r\n                        accessToken: this.authStateService.getAccessToken(configId),\r\n                        userData: this.userService.getUserDataFromStore(configId),\r\n                        isAuthenticated,\r\n                        configId,\r\n                    };\r\n                }\r\n                return null;\r\n            }));\r\n        }\r\n        const { silentRenewTimeoutInSeconds } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        const timeOutTime = silentRenewTimeoutInSeconds * 1000;\r\n        return forkJoin([\r\n            this.startRefreshSession(configId, extraCustomParams),\r\n            this.silentRenewService.refreshSessionWithIFrameCompleted$.pipe(take(1)),\r\n        ]).pipe(timeout(timeOutTime), retryWhen(this.timeoutRetryStrategy.bind(this)), map(([_, callbackContext]) => {\r\n            var _a, _b;\r\n            const isAuthenticated = this.authStateService.areAuthStorageTokensValid(configId);\r\n            if (isAuthenticated) {\r\n                return {\r\n                    idToken: (_a = callbackContext === null || callbackContext === void 0 ? void 0 : callbackContext.authResult) === null || _a === void 0 ? void 0 : _a.id_token,\r\n                    accessToken: (_b = callbackContext === null || callbackContext === void 0 ? void 0 : callbackContext.authResult) === null || _b === void 0 ? void 0 : _b.access_token,\r\n                    userData: this.userService.getUserDataFromStore(configId),\r\n                    isAuthenticated,\r\n                    configId,\r\n                };\r\n            }\r\n            return null;\r\n        }));\r\n    }\r\n    persistCustomParams(extraCustomParams, configId) {\r\n        const { useRefreshToken } = this.configurationProvider.getOpenIDConfiguration();\r\n        if (extraCustomParams) {\r\n            if (useRefreshToken) {\r\n                this.storagePersistenceService.write('storageCustomParamsRefresh', extraCustomParams, configId);\r\n            }\r\n            else {\r\n                this.storagePersistenceService.write('storageCustomParamsAuthRequest', extraCustomParams, configId);\r\n            }\r\n        }\r\n    }\r\n    startRefreshSession(configId, extraCustomParams) {\r\n        const isSilentRenewRunning = this.flowsDataService.isSilentRenewRunning(configId);\r\n        this.loggerService.logDebug(configId, `Checking: silentRenewRunning: ${isSilentRenewRunning}`);\r\n        const shouldBeExecuted = !isSilentRenewRunning;\r\n        if (!shouldBeExecuted) {\r\n            return of(null);\r\n        }\r\n        const { authWellknownEndpointUrl } = this.configurationProvider.getOpenIDConfiguration(configId) || {};\r\n        if (!authWellknownEndpointUrl) {\r\n            this.loggerService.logError(configId, 'no authWellKnownEndpoint given!');\r\n            return of(null);\r\n        }\r\n        return this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).pipe(switchMap(() => {\r\n            this.flowsDataService.setSilentRenewRunning(configId);\r\n            if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(configId)) {\r\n                // Refresh Session using Refresh tokens\r\n                return this.refreshSessionRefreshTokenService.refreshSessionWithRefreshTokens(configId, extraCustomParams);\r\n            }\r\n            return this.refreshSessionIframeService.refreshSessionWithIframe(configId, extraCustomParams);\r\n        }));\r\n    }\r\n    timeoutRetryStrategy(errorAttempts, configId) {\r\n        return errorAttempts.pipe(mergeMap((error, index) => {\r\n            const scalingDuration = 1000;\r\n            const currentAttempt = index + 1;\r\n            if (!(error instanceof TimeoutError) || currentAttempt > MAX_RETRY_ATTEMPTS) {\r\n                return throwError(error);\r\n            }\r\n            this.loggerService.logDebug(configId, `forceRefreshSession timeout. Attempt #${currentAttempt}`);\r\n            this.flowsDataService.resetSilentRenewRunning(configId);\r\n            return timer(currentAttempt * scalingDuration);\r\n        }));\r\n    }\r\n}\r\nRefreshSessionService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshSessionService, deps: [{ token: FlowHelper }, { token: ConfigurationProvider }, { token: FlowsDataService }, { token: LoggerService }, { token: SilentRenewService }, { token: AuthStateService }, { token: AuthWellKnownService }, { token: RefreshSessionIframeService }, { token: StoragePersistenceService }, { token: RefreshSessionRefreshTokenService }, { token: UserService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRefreshSessionService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshSessionService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshSessionService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: FlowHelper }, { type: ConfigurationProvider }, { type: FlowsDataService }, { type: LoggerService }, { type: SilentRenewService }, { type: AuthStateService }, { type: AuthWellKnownService }, { type: RefreshSessionIframeService }, { type: StoragePersistenceService }, { type: RefreshSessionRefreshTokenService }, { type: UserService }]; } });\n\nclass PeriodicallyTokenCheckService {\r\n    constructor(resetAuthDataService, flowHelper, configurationProvider, flowsDataService, loggerService, userService, authStateService, refreshSessionIframeService, refreshSessionRefreshTokenService, intervalService, storagePersistenceService, publicEventsService) {\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.flowHelper = flowHelper;\r\n        this.configurationProvider = configurationProvider;\r\n        this.flowsDataService = flowsDataService;\r\n        this.loggerService = loggerService;\r\n        this.userService = userService;\r\n        this.authStateService = authStateService;\r\n        this.refreshSessionIframeService = refreshSessionIframeService;\r\n        this.refreshSessionRefreshTokenService = refreshSessionRefreshTokenService;\r\n        this.intervalService = intervalService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.publicEventsService = publicEventsService;\r\n    }\r\n    startTokenValidationPeriodically() {\r\n        const configsWithSilentRenewEnabled = this.getConfigsWithSilentRenewEnabled();\r\n        if (configsWithSilentRenewEnabled.length <= 0) {\r\n            return;\r\n        }\r\n        const refreshTimeInSeconds = this.getSmallestRefreshTimeFromConfigs(configsWithSilentRenewEnabled);\r\n        if (!!this.intervalService.runTokenValidationRunning) {\r\n            return;\r\n        }\r\n        // START PERIODICALLY CHECK ONCE AND CHECK EACH CONFIG WHICH HAS IT ENABLED\r\n        const periodicallyCheck$ = this.intervalService.startPeriodicTokenCheck(refreshTimeInSeconds).pipe(switchMap(() => {\r\n            const objectWithConfigIdsAndRefreshEvent = {};\r\n            configsWithSilentRenewEnabled.forEach(({ configId }) => {\r\n                objectWithConfigIdsAndRefreshEvent[configId] = this.getRefreshEvent(configId);\r\n            });\r\n            return forkJoin(objectWithConfigIdsAndRefreshEvent);\r\n        }));\r\n        this.intervalService.runTokenValidationRunning = periodicallyCheck$.subscribe((objectWithConfigIds) => {\r\n            for (const [key, _] of Object.entries(objectWithConfigIds)) {\r\n                this.loggerService.logDebug(key, 'silent renew, periodic check finished!');\r\n                if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(key)) {\r\n                    this.flowsDataService.resetSilentRenewRunning(key);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    getRefreshEvent(configId) {\r\n        const shouldStartRefreshEvent = this.shouldStartPeriodicallyCheckForConfig(configId);\r\n        if (!shouldStartRefreshEvent) {\r\n            return of(null);\r\n        }\r\n        const refreshEvent$ = this.createRefreshEventForConfig(configId);\r\n        this.publicEventsService.fireEvent(EventTypes.SilentRenewStarted);\r\n        const refreshEventWithErrorHandler$ = refreshEvent$.pipe(catchError((error) => {\r\n            this.loggerService.logError(configId, 'silent renew failed!', error);\r\n            this.flowsDataService.resetSilentRenewRunning(configId);\r\n            return throwError(error);\r\n        }));\r\n        return refreshEventWithErrorHandler$;\r\n    }\r\n    getSmallestRefreshTimeFromConfigs(configsWithSilentRenewEnabled) {\r\n        const result = configsWithSilentRenewEnabled.reduce((prev, curr) => prev.tokenRefreshInSeconds < curr.tokenRefreshInSeconds ? prev : curr);\r\n        return result.tokenRefreshInSeconds;\r\n    }\r\n    getConfigsWithSilentRenewEnabled() {\r\n        return this.configurationProvider.getAllConfigurations().filter((x) => x.silentRenew);\r\n    }\r\n    createRefreshEventForConfig(configId) {\r\n        this.loggerService.logDebug(configId, 'starting silent renew...');\r\n        const config = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!(config === null || config === void 0 ? void 0 : config.silentRenew)) {\r\n            this.resetAuthDataService.resetAuthorizationData(configId);\r\n            return of(null);\r\n        }\r\n        this.flowsDataService.setSilentRenewRunning(configId);\r\n        if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(configId)) {\r\n            // Retrieve Dynamically Set Custom Params for refresh body\r\n            const customParamsRefresh = this.storagePersistenceService.read('storageCustomParamsRefresh', configId) || {};\r\n            const { customParamsRefreshTokenRequest } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n            const mergedParams = Object.assign(Object.assign({}, customParamsRefreshTokenRequest), customParamsRefresh);\r\n            // Refresh Session using Refresh tokens\r\n            return this.refreshSessionRefreshTokenService.refreshSessionWithRefreshTokens(configId, mergedParams);\r\n        }\r\n        // Retrieve Dynamically Set Custom Params\r\n        const customParams = this.storagePersistenceService.read('storageCustomParamsAuthRequest', configId);\r\n        return this.refreshSessionIframeService.refreshSessionWithIframe(configId, customParams);\r\n    }\r\n    shouldStartPeriodicallyCheckForConfig(configId) {\r\n        const idToken = this.authStateService.getIdToken(configId);\r\n        const isSilentRenewRunning = this.flowsDataService.isSilentRenewRunning(configId);\r\n        const userDataFromStore = this.userService.getUserDataFromStore(configId);\r\n        this.loggerService.logDebug(configId, `Checking: silentRenewRunning: ${isSilentRenewRunning} - has idToken: ${!!idToken} - has userData: ${!!userDataFromStore}`);\r\n        const shouldBeExecuted = !!userDataFromStore && !isSilentRenewRunning && !!idToken;\r\n        if (!shouldBeExecuted) {\r\n            return false;\r\n        }\r\n        const idTokenStillValid = this.authStateService.hasIdTokenExpiredAndRenewCheckIsEnabled(configId);\r\n        const accessTokenHasExpired = this.authStateService.hasAccessTokenExpiredIfExpiryExists(configId);\r\n        if (!idTokenStillValid && !accessTokenHasExpired) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\nPeriodicallyTokenCheckService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PeriodicallyTokenCheckService, deps: [{ token: ResetAuthDataService }, { token: FlowHelper }, { token: ConfigurationProvider }, { token: FlowsDataService }, { token: LoggerService }, { token: UserService }, { token: AuthStateService }, { token: RefreshSessionIframeService }, { token: RefreshSessionRefreshTokenService }, { token: IntervalService }, { token: StoragePersistenceService }, { token: PublicEventsService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nPeriodicallyTokenCheckService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PeriodicallyTokenCheckService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PeriodicallyTokenCheckService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: ResetAuthDataService }, { type: FlowHelper }, { type: ConfigurationProvider }, { type: FlowsDataService }, { type: LoggerService }, { type: UserService }, { type: AuthStateService }, { type: RefreshSessionIframeService }, { type: RefreshSessionRefreshTokenService }, { type: IntervalService }, { type: StoragePersistenceService }, { type: PublicEventsService }]; } });\n\nclass PopUpService {\r\n    constructor() {\r\n        this.STORAGE_IDENTIFIER = 'popupauth';\r\n        this.resultInternal$ = new Subject();\r\n    }\r\n    get result$() {\r\n        return this.resultInternal$.asObservable();\r\n    }\r\n    isCurrentlyInPopup() {\r\n        if (this.canAccessSessionStorage()) {\r\n            const popup = sessionStorage.getItem(this.STORAGE_IDENTIFIER);\r\n            return !!window.opener && window.opener !== window && !!popup;\r\n        }\r\n        return false;\r\n    }\r\n    openPopUp(url, popupOptions) {\r\n        const optionsToPass = this.getOptions(popupOptions);\r\n        this.popUp = window.open(url, '_blank', optionsToPass);\r\n        this.popUp.sessionStorage.setItem(this.STORAGE_IDENTIFIER, 'true');\r\n        const listener = (event) => {\r\n            if (!(event === null || event === void 0 ? void 0 : event.data) || typeof event.data !== 'string') {\r\n                return;\r\n            }\r\n            this.resultInternal$.next({ userClosed: false, receivedUrl: event.data });\r\n            this.cleanUp(listener);\r\n        };\r\n        window.addEventListener('message', listener, false);\r\n        this.handle = window.setInterval(() => {\r\n            if (this.popUp.closed) {\r\n                this.resultInternal$.next({ userClosed: true });\r\n                this.cleanUp(listener);\r\n            }\r\n        }, 200);\r\n    }\r\n    sendMessageToMainWindow(url) {\r\n        if (window.opener) {\r\n            this.sendMessage(url, window.location.href);\r\n        }\r\n    }\r\n    cleanUp(listener) {\r\n        var _a;\r\n        window.removeEventListener('message', listener, false);\r\n        window.clearInterval(this.handle);\r\n        if (this.popUp) {\r\n            (_a = this.popUp.sessionStorage) === null || _a === void 0 ? void 0 : _a.removeItem(this.STORAGE_IDENTIFIER);\r\n            this.popUp.close();\r\n            this.popUp = null;\r\n        }\r\n    }\r\n    sendMessage(url, href) {\r\n        window.opener.postMessage(url, href);\r\n    }\r\n    getOptions(popupOptions) {\r\n        const popupDefaultOptions = { width: 500, height: 500, left: 50, top: 50 };\r\n        const options = Object.assign(Object.assign({}, popupDefaultOptions), (popupOptions || {}));\r\n        const left = window.screenLeft + (window.outerWidth - options.width) / 2;\r\n        const top = window.screenTop + (window.outerHeight - options.height) / 2;\r\n        options.left = left;\r\n        options.top = top;\r\n        return Object.entries(options)\r\n            .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`)\r\n            .join(',');\r\n    }\r\n    canAccessSessionStorage() {\r\n        return typeof navigator !== 'undefined' && navigator.cookieEnabled && typeof Storage !== 'undefined';\r\n    }\r\n}\r\nPopUpService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PopUpService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nPopUpService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PopUpService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PopUpService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }] });\n\nclass CheckAuthService {\r\n    constructor(checkSessionService, currentUrlService, silentRenewService, userService, loggerService, configurationProvider, authStateService, callbackService, refreshSessionService, periodicallyTokenCheckService, popupService, autoLoginService, storagePersistenceService) {\r\n        this.checkSessionService = checkSessionService;\r\n        this.currentUrlService = currentUrlService;\r\n        this.silentRenewService = silentRenewService;\r\n        this.userService = userService;\r\n        this.loggerService = loggerService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.authStateService = authStateService;\r\n        this.callbackService = callbackService;\r\n        this.refreshSessionService = refreshSessionService;\r\n        this.periodicallyTokenCheckService = periodicallyTokenCheckService;\r\n        this.popupService = popupService;\r\n        this.autoLoginService = autoLoginService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n    }\r\n    checkAuth(passedConfigId, url) {\r\n        if (this.currentUrlService.currentUrlHasStateParam()) {\r\n            const stateParamFromUrl = this.currentUrlService.getStateParamFromCurrentUrl();\r\n            const config = this.getConfigurationWithUrlState(stateParamFromUrl);\r\n            if (!config) {\r\n                return throwError(`could not find matching config for state ${stateParamFromUrl}`);\r\n            }\r\n            return this.checkAuthWithConfig(config, url);\r\n        }\r\n        if (!!passedConfigId) {\r\n            const config = this.configurationProvider.getOpenIDConfiguration(passedConfigId);\r\n            return this.checkAuthWithConfig(config, url);\r\n        }\r\n        const onlyExistingConfig = this.configurationProvider.getOpenIDConfiguration();\r\n        return this.checkAuthWithConfig(onlyExistingConfig, url);\r\n    }\r\n    checkAuthMultiple(passedConfigId, url) {\r\n        if (this.currentUrlService.currentUrlHasStateParam()) {\r\n            const stateParamFromUrl = this.currentUrlService.getStateParamFromCurrentUrl();\r\n            const config = this.getConfigurationWithUrlState(stateParamFromUrl);\r\n            if (!config) {\r\n                return throwError(`could not find matching config for state ${stateParamFromUrl}`);\r\n            }\r\n            return this.composeMultipleLoginResults(config, url);\r\n        }\r\n        if (!!passedConfigId) {\r\n            const config = this.configurationProvider.getOpenIDConfiguration(passedConfigId);\r\n            if (!config) {\r\n                return throwError(`could not find matching config for id ${passedConfigId}`);\r\n            }\r\n            return this.composeMultipleLoginResults(config, url);\r\n        }\r\n        const allConfigs = this.configurationProvider.getAllConfigurations();\r\n        const allChecks$ = allConfigs.map((x) => this.checkAuthWithConfig(x, url));\r\n        return forkJoin(allChecks$);\r\n    }\r\n    checkAuthIncludingServer(configId) {\r\n        const config = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        return this.checkAuthWithConfig(config).pipe(switchMap((loginResponse) => {\r\n            const { isAuthenticated } = loginResponse;\r\n            if (isAuthenticated) {\r\n                return of(loginResponse);\r\n            }\r\n            return this.refreshSessionService.forceRefreshSession(configId).pipe(tap((loginResponseAfterRefreshSession) => {\r\n                if (loginResponseAfterRefreshSession === null || loginResponseAfterRefreshSession === void 0 ? void 0 : loginResponseAfterRefreshSession.isAuthenticated) {\r\n                    this.startCheckSessionAndValidation(configId);\r\n                }\r\n            }));\r\n        }));\r\n    }\r\n    checkAuthWithConfig(config, url) {\r\n        const { configId, authority } = config;\r\n        if (!this.configurationProvider.hasAsLeastOneConfig()) {\r\n            const errorMessage = 'Please provide at least one configuration before setting up the module';\r\n            this.loggerService.logError(configId, errorMessage);\r\n            return of({ isAuthenticated: false, errorMessage, userData: null, idToken: null, accessToken: null, configId });\r\n        }\r\n        const currentUrl = url || this.currentUrlService.getCurrentUrl();\r\n        this.loggerService.logDebug(configId, `Working with config '${configId}' using ${authority}`);\r\n        if (this.popupService.isCurrentlyInPopup()) {\r\n            this.popupService.sendMessageToMainWindow(currentUrl);\r\n            return of(null);\r\n        }\r\n        const isCallback = this.callbackService.isCallback(currentUrl);\r\n        this.loggerService.logDebug(configId, 'currentUrl to check auth with: ', currentUrl);\r\n        const callback$ = isCallback ? this.callbackService.handleCallbackAndFireEvents(currentUrl, configId) : of(null);\r\n        return callback$.pipe(map(() => {\r\n            const isAuthenticated = this.authStateService.areAuthStorageTokensValid(configId);\r\n            if (isAuthenticated) {\r\n                this.startCheckSessionAndValidation(configId);\r\n                if (!isCallback) {\r\n                    this.authStateService.setAuthenticatedAndFireEvent();\r\n                    this.userService.publishUserDataIfExists(configId);\r\n                }\r\n            }\r\n            this.loggerService.logDebug(configId, 'checkAuth completed - firing events now. isAuthenticated: ' + isAuthenticated);\r\n            return {\r\n                isAuthenticated,\r\n                userData: this.userService.getUserDataFromStore(configId),\r\n                accessToken: this.authStateService.getAccessToken(configId),\r\n                idToken: this.authStateService.getIdToken(configId),\r\n                configId,\r\n            };\r\n        }), tap(({ isAuthenticated }) => {\r\n            if (isAuthenticated) {\r\n                this.autoLoginService.checkSavedRedirectRouteAndNavigate(configId);\r\n            }\r\n        }), catchError((errorMessage) => {\r\n            this.loggerService.logError(configId, errorMessage);\r\n            return of({ isAuthenticated: false, errorMessage, userData: null, idToken: null, accessToken: null, configId });\r\n        }));\r\n    }\r\n    startCheckSessionAndValidation(configId) {\r\n        if (this.checkSessionService.isCheckSessionConfigured(configId)) {\r\n            this.checkSessionService.start(configId);\r\n        }\r\n        this.periodicallyTokenCheckService.startTokenValidationPeriodically();\r\n        if (this.silentRenewService.isSilentRenewConfigured(configId)) {\r\n            this.silentRenewService.getOrCreateIframe(configId);\r\n        }\r\n    }\r\n    getConfigurationWithUrlState(stateFromUrl) {\r\n        const allConfigs = this.configurationProvider.getAllConfigurations();\r\n        for (const config of allConfigs) {\r\n            const storedState = this.storagePersistenceService.read('authStateControl', config.configId);\r\n            if (storedState === stateFromUrl) {\r\n                return config;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    composeMultipleLoginResults(activeConfig, url) {\r\n        const allOtherConfigs = this.configurationProvider.getAllConfigurations().filter((x) => x.configId !== activeConfig.configId);\r\n        const currentConfigResult = this.checkAuthWithConfig(activeConfig, url);\r\n        const allOtherConfigResults = allOtherConfigs.map((config) => {\r\n            const { redirectUrl } = config;\r\n            return this.checkAuthWithConfig(config, redirectUrl);\r\n        });\r\n        return forkJoin([currentConfigResult, ...allOtherConfigResults]);\r\n    }\r\n}\r\nCheckAuthService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CheckAuthService, deps: [{ token: CheckSessionService }, { token: CurrentUrlService }, { token: SilentRenewService }, { token: UserService }, { token: LoggerService }, { token: ConfigurationProvider }, { token: AuthStateService }, { token: CallbackService }, { token: RefreshSessionService }, { token: PeriodicallyTokenCheckService }, { token: PopUpService }, { token: AutoLoginService }, { token: StoragePersistenceService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCheckAuthService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CheckAuthService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CheckAuthService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: CheckSessionService }, { type: CurrentUrlService }, { type: SilentRenewService }, { type: UserService }, { type: LoggerService }, { type: ConfigurationProvider }, { type: AuthStateService }, { type: CallbackService }, { type: RefreshSessionService }, { type: PeriodicallyTokenCheckService }, { type: PopUpService }, { type: AutoLoginService }, { type: StoragePersistenceService }]; } });\n\nconst DEFAULT_CONFIG = {\r\n    authority: 'https://please_set',\r\n    authWellknownEndpointUrl: '',\r\n    authWellknownEndpoints: null,\r\n    redirectUrl: 'https://please_set',\r\n    clientId: 'please_set',\r\n    responseType: 'code',\r\n    scope: 'openid email profile',\r\n    hdParam: '',\r\n    postLogoutRedirectUri: 'https://please_set',\r\n    startCheckSession: false,\r\n    silentRenew: false,\r\n    silentRenewUrl: 'https://please_set',\r\n    silentRenewTimeoutInSeconds: 20,\r\n    renewTimeBeforeTokenExpiresInSeconds: 0,\r\n    useRefreshToken: false,\r\n    usePushedAuthorisationRequests: false,\r\n    ignoreNonceAfterRefresh: false,\r\n    postLoginRoute: '/',\r\n    forbiddenRoute: '/forbidden',\r\n    unauthorizedRoute: '/unauthorized',\r\n    autoUserInfo: true,\r\n    autoCleanStateAfterAuthentication: true,\r\n    triggerAuthorizationResultEvent: false,\r\n    logLevel: LogLevel.Warn,\r\n    issValidationOff: false,\r\n    historyCleanupOff: false,\r\n    maxIdTokenIatOffsetAllowedInSeconds: 120,\r\n    disableIatOffsetValidation: false,\r\n    storage: null,\r\n    customParamsAuthRequest: {},\r\n    customParamsRefreshTokenRequest: {},\r\n    customParamsEndSessionRequest: {},\r\n    customParamsCodeRequest: {},\r\n    eagerLoadAuthWellKnownEndpoints: true,\r\n    disableRefreshIdTokenAuthTimeValidation: false,\r\n    enableIdTokenExpiredValidationInRenew: true,\r\n    tokenRefreshInSeconds: 4,\r\n    refreshTokenRetryInSeconds: 3,\r\n    ngswBypass: false,\r\n};\n\nconst POSITIVE_VALIDATION_RESULT = {\r\n    result: true,\r\n    messages: [],\r\n    level: null,\r\n};\n\nconst ensureAuthority = (passedConfig) => {\r\n    if (!passedConfig.authority) {\r\n        return {\r\n            result: false,\r\n            messages: ['The authority URL MUST be provided in the configuration! '],\r\n            level: 'error',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst ensureClientId = (passedConfig) => {\r\n    if (!passedConfig.clientId) {\r\n        return {\r\n            result: false,\r\n            messages: ['The clientId is required and missing from your config!'],\r\n            level: 'error',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst createIdentifierToCheck = (passedConfig) => {\r\n    if (!passedConfig) {\r\n        return null;\r\n    }\r\n    const { authority, clientId, scope } = passedConfig;\r\n    return `${authority}${clientId}${scope}`;\r\n};\r\nconst arrayHasDuplicates = (array) => new Set(array).size !== array.length;\r\nconst ensureNoDuplicatedConfigsRule = (passedConfigs) => {\r\n    const allIdentifiers = passedConfigs.map((x) => createIdentifierToCheck(x));\r\n    const someAreNull = allIdentifiers.some((x) => x === null);\r\n    if (someAreNull) {\r\n        return {\r\n            result: false,\r\n            messages: [`Please make sure you add an object with a 'config' property: ....({ config }) instead of ...(config)`],\r\n            level: 'error',\r\n        };\r\n    }\r\n    const hasDuplicates = arrayHasDuplicates(allIdentifiers);\r\n    if (hasDuplicates) {\r\n        return {\r\n            result: false,\r\n            messages: ['You added multiple configs with the same authority, clientId and scope'],\r\n            level: 'warning',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst ensureRedirectRule = (passedConfig) => {\r\n    if (!passedConfig.redirectUrl) {\r\n        return {\r\n            result: false,\r\n            messages: ['The redirectURL is required and missing from your config'],\r\n            level: 'error',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst ensureSilentRenewUrlWhenNoRefreshTokenUsed = (passedConfig) => {\r\n    const usesSilentRenew = passedConfig.silentRenew;\r\n    const usesRefreshToken = passedConfig.useRefreshToken;\r\n    const hasSilentRenewUrl = passedConfig.silentRenewUrl;\r\n    if (usesSilentRenew && !usesRefreshToken && !hasSilentRenewUrl) {\r\n        return {\r\n            result: false,\r\n            messages: ['Please provide a silent renew URL if using renew and not refresh tokens'],\r\n            level: 'error',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst useOfflineScopeWithSilentRenew = (passedConfig) => {\r\n    const hasRefreshToken = passedConfig.useRefreshToken;\r\n    const hasSilentRenew = passedConfig.silentRenew;\r\n    const scope = passedConfig.scope || '';\r\n    const hasOfflineScope = scope.split(' ').includes('offline_access');\r\n    if (hasRefreshToken && hasSilentRenew && !hasOfflineScope) {\r\n        return {\r\n            result: false,\r\n            messages: ['When using silent renew and refresh tokens please set the `offline_access` scope'],\r\n            level: 'warning',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst allRules = [\r\n    ensureAuthority,\r\n    useOfflineScopeWithSilentRenew,\r\n    ensureRedirectRule,\r\n    ensureClientId,\r\n    ensureSilentRenewUrlWhenNoRefreshTokenUsed,\r\n];\r\nconst allMultipleConfigRules = [ensureNoDuplicatedConfigsRule];\n\nclass ConfigValidationService {\r\n    constructor(loggerService) {\r\n        this.loggerService = loggerService;\r\n    }\r\n    validateConfigs(passedConfigs) {\r\n        return this.validateConfigsInternal(passedConfigs, allMultipleConfigRules);\r\n    }\r\n    validateConfig(passedConfig) {\r\n        return this.validateConfigInternal(passedConfig, allRules);\r\n    }\r\n    validateConfigsInternal(passedConfigs, allRulesToUse) {\r\n        const allValidationResults = allRulesToUse.map((rule) => rule(passedConfigs));\r\n        let overallErrorCount = 0;\r\n        passedConfigs.forEach((passedConfig) => {\r\n            const errorCount = this.processValidationResultsAndGetErrorCount(allValidationResults, passedConfig === null || passedConfig === void 0 ? void 0 : passedConfig.configId);\r\n            overallErrorCount += errorCount;\r\n        });\r\n        return overallErrorCount === 0;\r\n    }\r\n    validateConfigInternal(passedConfig, allRulesToUse) {\r\n        const allValidationResults = allRulesToUse.map((rule) => rule(passedConfig));\r\n        const errorCount = this.processValidationResultsAndGetErrorCount(allValidationResults, passedConfig.configId);\r\n        return errorCount === 0;\r\n    }\r\n    processValidationResultsAndGetErrorCount(allValidationResults, configId) {\r\n        const allMessages = allValidationResults.filter((x) => x.messages.length > 0);\r\n        const allErrorMessages = this.getAllMessagesOfType('error', allMessages);\r\n        const allWarnings = this.getAllMessagesOfType('warning', allMessages);\r\n        allErrorMessages.forEach((message) => this.loggerService.logError(configId, message));\r\n        allWarnings.forEach((message) => this.loggerService.logWarning(configId, message));\r\n        return allErrorMessages.length;\r\n    }\r\n    getAllMessagesOfType(type, results) {\r\n        const allMessages = results.filter((x) => x.level === type).map((result) => result.messages);\r\n        return allMessages.reduce((acc, val) => acc.concat(val), []);\r\n    }\r\n}\r\nConfigValidationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ConfigValidationService, deps: [{ token: LoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nConfigValidationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ConfigValidationService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ConfigValidationService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }]; } });\n\nclass PlatformProvider {\r\n    constructor(platformId) {\r\n        this.platformId = platformId;\r\n    }\r\n    get isBrowser() {\r\n        return isPlatformBrowser(this.platformId);\r\n    }\r\n}\r\nPlatformProvider.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PlatformProvider, deps: [{ token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });\r\nPlatformProvider.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PlatformProvider });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PlatformProvider, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [PLATFORM_ID]\r\n                }] }]; } });\n\nclass DefaultSessionStorageService {\r\n    read(key) {\r\n        return sessionStorage.getItem(key);\r\n    }\r\n    write(key, value) {\r\n        sessionStorage.setItem(key, value);\r\n    }\r\n    remove(key) {\r\n        sessionStorage.removeItem(key);\r\n    }\r\n    clear() {\r\n        sessionStorage.clear();\r\n    }\r\n}\r\nDefaultSessionStorageService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: DefaultSessionStorageService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nDefaultSessionStorageService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: DefaultSessionStorageService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: DefaultSessionStorageService, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nclass OidcConfigService {\r\n    constructor(loggerService, publicEventsService, configurationProvider, authWellKnownService, storagePersistenceService, configValidationService, platformProvider, defaultSessionStorageService) {\r\n        this.loggerService = loggerService;\r\n        this.publicEventsService = publicEventsService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.authWellKnownService = authWellKnownService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.configValidationService = configValidationService;\r\n        this.platformProvider = platformProvider;\r\n        this.defaultSessionStorageService = defaultSessionStorageService;\r\n    }\r\n    withConfigs(passedConfigs) {\r\n        if (!this.configValidationService.validateConfigs(passedConfigs)) {\r\n            return Promise.resolve(null);\r\n        }\r\n        this.createUniqueIds(passedConfigs);\r\n        const allHandleConfigPromises = passedConfigs.map((x) => this.handleConfig(x));\r\n        return Promise.all(allHandleConfigPromises);\r\n    }\r\n    createUniqueIds(passedConfigs) {\r\n        passedConfigs.forEach((config, index) => {\r\n            if (!config.configId) {\r\n                config.configId = `${index}-${config.clientId}`;\r\n            }\r\n        });\r\n    }\r\n    handleConfig(passedConfig) {\r\n        return new Promise((resolve, reject) => {\r\n            if (!this.configValidationService.validateConfig(passedConfig)) {\r\n                this.loggerService.logError(passedConfig.configId, 'Validation of config rejected with errors. Config is NOT set.');\r\n                resolve(null);\r\n                return;\r\n            }\r\n            if (!passedConfig.authWellknownEndpointUrl) {\r\n                passedConfig.authWellknownEndpointUrl = passedConfig.authority;\r\n            }\r\n            const usedConfig = this.prepareConfig(passedConfig);\r\n            this.configurationProvider.setConfig(usedConfig);\r\n            const alreadyExistingAuthWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', usedConfig.configId);\r\n            if (!!alreadyExistingAuthWellKnownEndpoints) {\r\n                usedConfig.authWellknownEndpoints = alreadyExistingAuthWellKnownEndpoints;\r\n                this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, usedConfig);\r\n                resolve(usedConfig);\r\n                return;\r\n            }\r\n            const passedAuthWellKnownEndpoints = usedConfig.authWellknownEndpoints;\r\n            if (!!passedAuthWellKnownEndpoints) {\r\n                this.authWellKnownService.storeWellKnownEndpoints(usedConfig.configId, passedAuthWellKnownEndpoints);\r\n                usedConfig.authWellknownEndpoints = passedAuthWellKnownEndpoints;\r\n                this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, usedConfig);\r\n                resolve(usedConfig);\r\n                return;\r\n            }\r\n            if (usedConfig.eagerLoadAuthWellKnownEndpoints) {\r\n                this.authWellKnownService\r\n                    .getAuthWellKnownEndPoints(usedConfig.authWellknownEndpointUrl, usedConfig.configId)\r\n                    .pipe(catchError((error) => {\r\n                    this.loggerService.logError(usedConfig.configId, 'Getting auth well known endpoints failed on start', error);\r\n                    return throwError(error);\r\n                }), tap((wellknownEndPoints) => {\r\n                    usedConfig.authWellknownEndpoints = wellknownEndPoints;\r\n                    this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, usedConfig);\r\n                }))\r\n                    .subscribe(() => resolve(usedConfig), () => reject());\r\n            }\r\n            else {\r\n                this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, usedConfig);\r\n                resolve(usedConfig);\r\n            }\r\n        });\r\n    }\r\n    prepareConfig(configuration) {\r\n        const openIdConfigurationInternal = Object.assign(Object.assign({}, DEFAULT_CONFIG), configuration);\r\n        this.setSpecialCases(openIdConfigurationInternal);\r\n        this.setStorage(openIdConfigurationInternal);\r\n        return openIdConfigurationInternal;\r\n    }\r\n    setSpecialCases(currentConfig) {\r\n        if (!this.platformProvider.isBrowser) {\r\n            currentConfig.startCheckSession = false;\r\n            currentConfig.silentRenew = false;\r\n            currentConfig.useRefreshToken = false;\r\n            currentConfig.usePushedAuthorisationRequests = false;\r\n        }\r\n    }\r\n    setStorage(currentConfig) {\r\n        if (currentConfig.storage) {\r\n            return;\r\n        }\r\n        if (this.hasBrowserStorage()) {\r\n            currentConfig.storage = this.defaultSessionStorageService;\r\n        }\r\n        else {\r\n            currentConfig.storage = null;\r\n        }\r\n    }\r\n    hasBrowserStorage() {\r\n        return typeof navigator !== 'undefined' && navigator.cookieEnabled && typeof Storage !== 'undefined';\r\n    }\r\n}\r\nOidcConfigService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: OidcConfigService, deps: [{ token: LoggerService }, { token: PublicEventsService }, { token: ConfigurationProvider }, { token: AuthWellKnownService }, { token: StoragePersistenceService }, { token: ConfigValidationService }, { token: PlatformProvider }, { token: DefaultSessionStorageService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nOidcConfigService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: OidcConfigService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: OidcConfigService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: PublicEventsService }, { type: ConfigurationProvider }, { type: AuthWellKnownService }, { type: StoragePersistenceService }, { type: ConfigValidationService }, { type: PlatformProvider }, { type: DefaultSessionStorageService }]; } });\n\nclass OpenIdConfigLoader {\r\n}\r\nclass StsConfigLoader {\r\n}\r\nclass StsConfigStaticLoader {\r\n    constructor(passedConfigs) {\r\n        this.passedConfigs = passedConfigs;\r\n    }\r\n    loadConfigs() {\r\n        if (Array.isArray(this.passedConfigs)) {\r\n            const allInstantStaticPromises = this.passedConfigs.map((x) => new Promise((resolve, _) => resolve(x)));\r\n            return allInstantStaticPromises;\r\n        }\r\n        const singleStaticPromise = new Promise((resolve, _) => resolve(this.passedConfigs));\r\n        return [singleStaticPromise];\r\n    }\r\n}\r\nclass StsConfigHttpLoader {\r\n    constructor(configs$) {\r\n        this.configs$ = configs$;\r\n    }\r\n    loadConfigs() {\r\n        return Array.isArray(this.configs$) ? this.configs$ : [this.configs$];\r\n    }\r\n}\n\nclass ClosestMatchingRouteService {\r\n    constructor(configProvider) {\r\n        this.configProvider = configProvider;\r\n    }\r\n    getConfigIdForClosestMatchingRoute(route) {\r\n        const allConfiguredRoutes = this.getAllConfiguredRoutes();\r\n        for (const routesWithConfig of allConfiguredRoutes) {\r\n            const allRoutesForConfig = routesWithConfig.routes;\r\n            for (const configuredRoute of allRoutesForConfig) {\r\n                if (route.startsWith(configuredRoute)) {\r\n                    return {\r\n                        matchingRoute: configuredRoute,\r\n                        matchingConfigId: routesWithConfig.configId,\r\n                    };\r\n                }\r\n            }\r\n        }\r\n        return {\r\n            matchingRoute: null,\r\n            matchingConfigId: null,\r\n        };\r\n    }\r\n    getAllConfiguredRoutes() {\r\n        const allConfigurations = this.configProvider.getAllConfigurations();\r\n        return allConfigurations.map((x) => ({ routes: x.secureRoutes, configId: x.configId }));\r\n    }\r\n}\r\nClosestMatchingRouteService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ClosestMatchingRouteService, deps: [{ token: ConfigurationProvider }], target: i0.ɵɵFactoryTarget.Injectable });\r\nClosestMatchingRouteService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ClosestMatchingRouteService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ClosestMatchingRouteService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: ConfigurationProvider }]; } });\n\nclass ResponseTypeValidationService {\r\n    constructor(loggerService, flowHelper) {\r\n        this.loggerService = loggerService;\r\n        this.flowHelper = flowHelper;\r\n    }\r\n    hasConfigValidResponseType(configId) {\r\n        if (this.flowHelper.isCurrentFlowAnyImplicitFlow(configId)) {\r\n            return true;\r\n        }\r\n        if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\r\n            return true;\r\n        }\r\n        this.loggerService.logWarning(configId, 'module configured incorrectly, invalid response_type. Check the responseType in the config');\r\n        return false;\r\n    }\r\n}\r\nResponseTypeValidationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ResponseTypeValidationService, deps: [{ token: LoggerService }, { token: FlowHelper }], target: i0.ɵɵFactoryTarget.Injectable });\r\nResponseTypeValidationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ResponseTypeValidationService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ResponseTypeValidationService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: FlowHelper }]; } });\n\nclass RedirectService {\r\n    constructor(doc) {\r\n        this.doc = doc;\r\n    }\r\n    redirectTo(url) {\r\n        this.doc.location.href = url;\r\n    }\r\n}\r\nRedirectService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RedirectService, deps: [{ token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRedirectService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RedirectService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RedirectService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }]; } });\n\nclass ParService {\r\n    constructor(loggerService, urlService, dataService, storagePersistenceService) {\r\n        this.loggerService = loggerService;\r\n        this.urlService = urlService;\r\n        this.dataService = dataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n    }\r\n    postParRequest(configId, customParams) {\r\n        let headers = new HttpHeaders();\r\n        headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\r\n        const authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        if (!authWellknownEndpoints) {\r\n            return throwError('Could not read PAR endpoint because authWellKnownEndPoints are not given');\r\n        }\r\n        const parEndpoint = authWellknownEndpoints.parEndpoint;\r\n        if (!parEndpoint) {\r\n            return throwError('Could not read PAR endpoint from authWellKnownEndpoints');\r\n        }\r\n        const data = this.urlService.createBodyForParCodeFlowRequest(configId, customParams);\r\n        return this.dataService.post(parEndpoint, data, configId, headers).pipe(retry(2), map((response) => {\r\n            this.loggerService.logDebug(configId, 'par response: ', response);\r\n            return {\r\n                expiresIn: response.expires_in,\r\n                requestUri: response.request_uri,\r\n            };\r\n        }), catchError((error) => {\r\n            const errorMessage = `There was an error on ParService postParRequest`;\r\n            this.loggerService.logError(configId, errorMessage, error);\r\n            return throwError(errorMessage);\r\n        }));\r\n    }\r\n}\r\nParService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ParService, deps: [{ token: LoggerService }, { token: UrlService }, { token: DataService }, { token: StoragePersistenceService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nParService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ParService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ParService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: UrlService }, { type: DataService }, { type: StoragePersistenceService }]; } });\n\nclass ParLoginService {\r\n    constructor(loggerService, responseTypeValidationService, urlService, redirectService, configurationProvider, authWellKnownService, popupService, checkAuthService, parService) {\r\n        this.loggerService = loggerService;\r\n        this.responseTypeValidationService = responseTypeValidationService;\r\n        this.urlService = urlService;\r\n        this.redirectService = redirectService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.authWellKnownService = authWellKnownService;\r\n        this.popupService = popupService;\r\n        this.checkAuthService = checkAuthService;\r\n        this.parService = parService;\r\n    }\r\n    loginPar(configId, authOptions) {\r\n        if (!this.responseTypeValidationService.hasConfigValidResponseType(configId)) {\r\n            this.loggerService.logError(configId, 'Invalid response type!');\r\n            return;\r\n        }\r\n        const { authWellknownEndpointUrl } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!authWellknownEndpointUrl) {\r\n            this.loggerService.logError(configId, 'no authWellknownEndpoint given!');\r\n            return;\r\n        }\r\n        this.loggerService.logDebug(configId, 'BEGIN Authorize OIDC Flow, no auth data');\r\n        const { urlHandler, customParams } = authOptions || {};\r\n        this.authWellKnownService\r\n            .getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId)\r\n            .pipe(switchMap(() => this.parService.postParRequest(configId, customParams)))\r\n            .subscribe((response) => {\r\n            this.loggerService.logDebug(configId, 'par response: ', response);\r\n            const url = this.urlService.getAuthorizeParUrl(response.requestUri, configId);\r\n            this.loggerService.logDebug(configId, 'par request url: ', url);\r\n            if (!url) {\r\n                this.loggerService.logError(configId, `Could not create URL with param ${response.requestUri}: '${url}'`);\r\n                return;\r\n            }\r\n            if (urlHandler) {\r\n                urlHandler(url);\r\n            }\r\n            else {\r\n                this.redirectService.redirectTo(url);\r\n            }\r\n        });\r\n    }\r\n    loginWithPopUpPar(configId, authOptions, popupOptions) {\r\n        if (!this.responseTypeValidationService.hasConfigValidResponseType(configId)) {\r\n            const errorMessage = 'Invalid response type!';\r\n            this.loggerService.logError(configId, errorMessage);\r\n            return throwError(errorMessage);\r\n        }\r\n        const { authWellknownEndpointUrl } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!authWellknownEndpointUrl) {\r\n            const errorMessage = 'no authWellknownEndpoint given!';\r\n            this.loggerService.logError(configId, errorMessage);\r\n            return throwError(errorMessage);\r\n        }\r\n        this.loggerService.logDebug(configId, 'BEGIN Authorize OIDC Flow with popup, no auth data');\r\n        const { customParams } = authOptions || {};\r\n        return this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).pipe(switchMap(() => this.parService.postParRequest(configId, customParams)), switchMap((response) => {\r\n            this.loggerService.logDebug(configId, 'par response: ', response);\r\n            const url = this.urlService.getAuthorizeParUrl(response.requestUri, configId);\r\n            this.loggerService.logDebug(configId, 'par request url: ', url);\r\n            if (!url) {\r\n                const errorMessage = `Could not create URL with param ${response.requestUri}: 'url'`;\r\n                this.loggerService.logError(configId, errorMessage);\r\n                return throwError(errorMessage);\r\n            }\r\n            this.popupService.openPopUp(url, popupOptions);\r\n            return this.popupService.result$.pipe(take(1), switchMap((result) => {\r\n                const { userClosed, receivedUrl } = result;\r\n                if (userClosed) {\r\n                    return of({\r\n                        isAuthenticated: false,\r\n                        errorMessage: 'User closed popup',\r\n                        userData: null,\r\n                        idToken: null,\r\n                        accessToken: null,\r\n                        configId,\r\n                    });\r\n                }\r\n                return this.checkAuthService.checkAuth(configId, receivedUrl);\r\n            }));\r\n        }));\r\n    }\r\n}\r\nParLoginService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ParLoginService, deps: [{ token: LoggerService }, { token: ResponseTypeValidationService }, { token: UrlService }, { token: RedirectService }, { token: ConfigurationProvider }, { token: AuthWellKnownService }, { token: PopUpService }, { token: CheckAuthService }, { token: ParService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nParLoginService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ParLoginService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ParLoginService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: ResponseTypeValidationService }, { type: UrlService }, { type: RedirectService }, { type: ConfigurationProvider }, { type: AuthWellKnownService }, { type: PopUpService }, { type: CheckAuthService }, { type: ParService }]; } });\n\nclass PopUpLoginService {\r\n    constructor(loggerService, responseTypeValidationService, urlService, configurationProvider, authWellKnownService, popupService, checkAuthService) {\r\n        this.loggerService = loggerService;\r\n        this.responseTypeValidationService = responseTypeValidationService;\r\n        this.urlService = urlService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.authWellKnownService = authWellKnownService;\r\n        this.popupService = popupService;\r\n        this.checkAuthService = checkAuthService;\r\n    }\r\n    loginWithPopUpStandard(configId, authOptions, popupOptions) {\r\n        if (!this.responseTypeValidationService.hasConfigValidResponseType(configId)) {\r\n            const errorMessage = 'Invalid response type!';\r\n            this.loggerService.logError(configId, errorMessage);\r\n            return throwError(errorMessage);\r\n        }\r\n        const { authWellknownEndpointUrl } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!authWellknownEndpointUrl) {\r\n            const errorMessage = 'no authWellknownEndpoint given!';\r\n            this.loggerService.logError(configId, errorMessage);\r\n            return throwError(errorMessage);\r\n        }\r\n        this.loggerService.logDebug(configId, 'BEGIN Authorize OIDC Flow with popup, no auth data');\r\n        return this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).pipe(switchMap(() => {\r\n            const { customParams } = authOptions || {};\r\n            const authUrl = this.urlService.getAuthorizeUrl(configId, customParams);\r\n            this.popupService.openPopUp(authUrl, popupOptions);\r\n            return this.popupService.result$.pipe(take(1), switchMap((result) => {\r\n                const { userClosed, receivedUrl } = result;\r\n                if (userClosed) {\r\n                    return of({\r\n                        isAuthenticated: false,\r\n                        errorMessage: 'User closed popup',\r\n                        userData: null,\r\n                        idToken: null,\r\n                        accessToken: null,\r\n                        configId,\r\n                    });\r\n                }\r\n                return this.checkAuthService.checkAuth(configId, receivedUrl);\r\n            }));\r\n        }));\r\n    }\r\n}\r\nPopUpLoginService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PopUpLoginService, deps: [{ token: LoggerService }, { token: ResponseTypeValidationService }, { token: UrlService }, { token: ConfigurationProvider }, { token: AuthWellKnownService }, { token: PopUpService }, { token: CheckAuthService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nPopUpLoginService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PopUpLoginService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PopUpLoginService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: ResponseTypeValidationService }, { type: UrlService }, { type: ConfigurationProvider }, { type: AuthWellKnownService }, { type: PopUpService }, { type: CheckAuthService }]; } });\n\nclass StandardLoginService {\r\n    constructor(loggerService, responseTypeValidationService, urlService, redirectService, configurationProvider, authWellKnownService) {\r\n        this.loggerService = loggerService;\r\n        this.responseTypeValidationService = responseTypeValidationService;\r\n        this.urlService = urlService;\r\n        this.redirectService = redirectService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.authWellKnownService = authWellKnownService;\r\n    }\r\n    loginStandard(configId, authOptions) {\r\n        if (!this.responseTypeValidationService.hasConfigValidResponseType(configId)) {\r\n            this.loggerService.logError(configId, 'Invalid response type!');\r\n            return;\r\n        }\r\n        const { authWellknownEndpointUrl } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!authWellknownEndpointUrl) {\r\n            this.loggerService.logError(configId, 'no authWellknownEndpoint given!');\r\n            return;\r\n        }\r\n        this.loggerService.logDebug(configId, 'BEGIN Authorize OIDC Flow, no auth data');\r\n        this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).subscribe(() => {\r\n            const { urlHandler, customParams } = authOptions || {};\r\n            const url = this.urlService.getAuthorizeUrl(configId, customParams);\r\n            if (!url) {\r\n                this.loggerService.logError(configId, 'Could not create URL', url);\r\n                return;\r\n            }\r\n            if (urlHandler) {\r\n                urlHandler(url);\r\n            }\r\n            else {\r\n                this.redirectService.redirectTo(url);\r\n            }\r\n        });\r\n    }\r\n}\r\nStandardLoginService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: StandardLoginService, deps: [{ token: LoggerService }, { token: ResponseTypeValidationService }, { token: UrlService }, { token: RedirectService }, { token: ConfigurationProvider }, { token: AuthWellKnownService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nStandardLoginService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: StandardLoginService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: StandardLoginService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: ResponseTypeValidationService }, { type: UrlService }, { type: RedirectService }, { type: ConfigurationProvider }, { type: AuthWellKnownService }]; } });\n\nclass LoginService {\r\n    constructor(configurationProvider, parLoginService, popUpLoginService, standardLoginService, storagePersistenceService) {\r\n        this.configurationProvider = configurationProvider;\r\n        this.parLoginService = parLoginService;\r\n        this.popUpLoginService = popUpLoginService;\r\n        this.standardLoginService = standardLoginService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n    }\r\n    login(configId, authOptions) {\r\n        if (authOptions === null || authOptions === void 0 ? void 0 : authOptions.customParams) {\r\n            this.storagePersistenceService.write('storageCustomParamsAuthRequest', authOptions.customParams, configId);\r\n        }\r\n        const { usePushedAuthorisationRequests } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (usePushedAuthorisationRequests) {\r\n            return this.parLoginService.loginPar(configId, authOptions);\r\n        }\r\n        else {\r\n            return this.standardLoginService.loginStandard(configId, authOptions);\r\n        }\r\n    }\r\n    loginWithPopUp(configId, authOptions, popupOptions) {\r\n        if (authOptions === null || authOptions === void 0 ? void 0 : authOptions.customParams) {\r\n            this.storagePersistenceService.write('storageCustomParamsAuthRequest', authOptions.customParams, configId);\r\n        }\r\n        const { usePushedAuthorisationRequests } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (usePushedAuthorisationRequests) {\r\n            return this.parLoginService.loginWithPopUpPar(configId, authOptions, popupOptions);\r\n        }\r\n        else {\r\n            return this.popUpLoginService.loginWithPopUpStandard(configId, authOptions, popupOptions);\r\n        }\r\n    }\r\n}\r\nLoginService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: LoginService, deps: [{ token: ConfigurationProvider }, { token: ParLoginService }, { token: PopUpLoginService }, { token: StandardLoginService }, { token: StoragePersistenceService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nLoginService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: LoginService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: LoginService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: ConfigurationProvider }, { type: ParLoginService }, { type: PopUpLoginService }, { type: StandardLoginService }, { type: StoragePersistenceService }]; } });\n\nclass LogoffRevocationService {\r\n    constructor(dataService, storagePersistenceService, loggerService, urlService, checkSessionService, resetAuthDataService, redirectService, configurationProvider) {\r\n        this.dataService = dataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.loggerService = loggerService;\r\n        this.urlService = urlService;\r\n        this.checkSessionService = checkSessionService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.redirectService = redirectService;\r\n        this.configurationProvider = configurationProvider;\r\n    }\r\n    // Logs out on the server and the local client.\r\n    // If the server state has changed, check session, then only a local logout.\r\n    logoff(configId, authOptions) {\r\n        const { urlHandler, customParams } = authOptions || {};\r\n        this.loggerService.logDebug(configId, 'logoff, remove auth ');\r\n        const endSessionUrl = this.getEndSessionUrl(configId, customParams);\r\n        this.resetAuthDataService.resetAuthorizationData(configId);\r\n        if (!endSessionUrl) {\r\n            this.loggerService.logDebug(configId, 'only local login cleaned up, no end_session_endpoint');\r\n            return;\r\n        }\r\n        if (this.checkSessionService.serverStateChanged(configId)) {\r\n            this.loggerService.logDebug(configId, 'only local login cleaned up, server session has changed');\r\n        }\r\n        else if (urlHandler) {\r\n            urlHandler(endSessionUrl);\r\n        }\r\n        else {\r\n            this.redirectService.redirectTo(endSessionUrl);\r\n        }\r\n    }\r\n    logoffLocal(configId) {\r\n        this.resetAuthDataService.resetAuthorizationData(configId);\r\n        this.checkSessionService.stop();\r\n    }\r\n    logoffLocalMultiple() {\r\n        const allConfigs = this.configurationProvider.getAllConfigurations();\r\n        allConfigs.forEach(({ configId }) => this.logoffLocal(configId));\r\n    }\r\n    // The refresh token and and the access token are revoked on the server. If the refresh token does not exist\r\n    // only the access token is revoked. Then the logout run.\r\n    logoffAndRevokeTokens(configId, authOptions) {\r\n        const { revocationEndpoint } = this.storagePersistenceService.read('authWellKnownEndPoints', configId) || {};\r\n        if (!revocationEndpoint) {\r\n            this.loggerService.logDebug(configId, 'revocation endpoint not supported');\r\n            this.logoff(configId, authOptions);\r\n        }\r\n        if (this.storagePersistenceService.getRefreshToken(configId)) {\r\n            return this.revokeRefreshToken(configId).pipe(switchMap((result) => this.revokeAccessToken(configId, result)), catchError((error) => {\r\n                const errorMessage = `revoke token failed`;\r\n                this.loggerService.logError(configId, errorMessage, error);\r\n                return throwError(errorMessage);\r\n            }), tap(() => this.logoff(configId, authOptions)));\r\n        }\r\n        else {\r\n            return this.revokeAccessToken(configId).pipe(catchError((error) => {\r\n                const errorMessage = `revoke accessToken failed`;\r\n                this.loggerService.logError(configId, errorMessage, error);\r\n                return throwError(errorMessage);\r\n            }), tap(() => this.logoff(configId, authOptions)));\r\n        }\r\n    }\r\n    // https://tools.ietf.org/html/rfc7009\r\n    // revokes an access token on the STS. If no token is provided, then the token from\r\n    // the storage is revoked. You can pass any token to revoke. This makes it possible to\r\n    // manage your own tokens. The is a public API.\r\n    revokeAccessToken(configId, accessToken) {\r\n        const accessTok = accessToken || this.storagePersistenceService.getAccessToken(configId);\r\n        const body = this.urlService.createRevocationEndpointBodyAccessToken(accessTok, configId);\r\n        return this.sendRevokeRequest(configId, body);\r\n    }\r\n    // https://tools.ietf.org/html/rfc7009\r\n    // revokes an refresh token on the STS. This is only required in the code flow with refresh tokens.\r\n    // If no token is provided, then the token from the storage is revoked. You can pass any token to revoke.\r\n    // This makes it possible to manage your own tokens.\r\n    revokeRefreshToken(configId, refreshToken) {\r\n        const refreshTok = refreshToken || this.storagePersistenceService.getRefreshToken(configId);\r\n        const body = this.urlService.createRevocationEndpointBodyRefreshToken(refreshTok, configId);\r\n        return this.sendRevokeRequest(configId, body);\r\n    }\r\n    getEndSessionUrl(configId, customParams) {\r\n        const idToken = this.storagePersistenceService.getIdToken(configId);\r\n        const { customParamsEndSessionRequest } = this.configurationProvider.getOpenIDConfiguration();\r\n        const mergedParams = Object.assign(Object.assign({}, customParamsEndSessionRequest), customParams);\r\n        return this.urlService.createEndSessionUrl(idToken, configId, mergedParams);\r\n    }\r\n    sendRevokeRequest(configId, body) {\r\n        const url = this.urlService.getRevocationEndpointUrl(configId);\r\n        let headers = new HttpHeaders();\r\n        headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\r\n        return this.dataService.post(url, body, configId, headers).pipe(retry(2), switchMap((response) => {\r\n            this.loggerService.logDebug(configId, 'revocation endpoint post response: ', response);\r\n            return of(response);\r\n        }), catchError((error) => {\r\n            const errorMessage = `Revocation request failed`;\r\n            this.loggerService.logError(configId, errorMessage, error);\r\n            return throwError(errorMessage);\r\n        }));\r\n    }\r\n}\r\nLogoffRevocationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: LogoffRevocationService, deps: [{ token: DataService }, { token: StoragePersistenceService }, { token: LoggerService }, { token: UrlService }, { token: CheckSessionService }, { token: ResetAuthDataService }, { token: RedirectService }, { token: ConfigurationProvider }], target: i0.ɵɵFactoryTarget.Injectable });\r\nLogoffRevocationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: LogoffRevocationService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: LogoffRevocationService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: DataService }, { type: StoragePersistenceService }, { type: LoggerService }, { type: UrlService }, { type: CheckSessionService }, { type: ResetAuthDataService }, { type: RedirectService }, { type: ConfigurationProvider }]; } });\n\nclass OidcSecurityService {\r\n    constructor(checkSessionService, checkAuthService, userService, tokenHelperService, configurationProvider, authStateService, flowsDataService, callbackService, logoffRevocationService, loginService, refreshSessionService, urlService) {\r\n        this.checkSessionService = checkSessionService;\r\n        this.checkAuthService = checkAuthService;\r\n        this.userService = userService;\r\n        this.tokenHelperService = tokenHelperService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.authStateService = authStateService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.callbackService = callbackService;\r\n        this.logoffRevocationService = logoffRevocationService;\r\n        this.loginService = loginService;\r\n        this.refreshSessionService = refreshSessionService;\r\n        this.urlService = urlService;\r\n    }\r\n    /**\r\n     * Provides information about the user after they have logged in.\r\n     *\r\n     * @returns Returns an object containing either the user data directly (single config) or\r\n     * the user data per config in case you are running with multiple configs\r\n     */\r\n    get userData$() {\r\n        return this.userService.userData$;\r\n    }\r\n    /**\r\n     * Emits each time an authorization event occurs.\r\n     *\r\n     * @returns Returns an object containing if you are authenticated or not.\r\n     * Single Config: true if config is authenticated, false if not.\r\n     * Multiple Configs: true is all configs are authenticated, false if only one of them is not\r\n     *\r\n     * The `allConfigsAuthenticated` property contains the auth information _per config_.\r\n     */\r\n    get isAuthenticated$() {\r\n        return this.authStateService.authenticated$;\r\n    }\r\n    /**\r\n     * Emits each time the server sends a CheckSession event and the value changed. This property will always return\r\n     * true.\r\n     */\r\n    get checkSessionChanged$() {\r\n        return this.checkSessionService.checkSessionChanged$;\r\n    }\r\n    /**\r\n     * Emits on a Security Token Service callback. The observable will never contain a value.\r\n     */\r\n    get stsCallback$() {\r\n        return this.callbackService.stsCallback$;\r\n    }\r\n    /**\r\n     * Returns the currently active OpenID configurations.\r\n     *\r\n     * @returns an array of OpenIdConfigurations.\r\n     */\r\n    getConfigurations() {\r\n        return this.configurationProvider.getAllConfigurations();\r\n    }\r\n    /**\r\n     * Returns a single active OpenIdConfiguration.\r\n     *\r\n     * @param configId The configId to identify the config. If not passed, the first one is being returned\r\n     */\r\n    getConfiguration(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration().configId;\r\n        return this.configurationProvider.getOpenIDConfiguration(configId);\r\n    }\r\n    /**\r\n     * Returns the userData for a configuration\r\n     *\r\n     * @param configId The configId to identify the config. If not passed, the first one is being used\r\n     */\r\n    getUserData(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration().configId;\r\n        return this.userService.getUserDataFromStore(configId);\r\n    }\r\n    /**\r\n     * Starts the complete setup flow for one configuration. Calling will start the entire authentication flow, and the returned observable\r\n     * will denote whether the user was successfully authenticated including the user data, the access token, the configId and\r\n     * an error message in case an error happened\r\n     *\r\n     * @param url The URL to perform the authorization on the behalf of.\r\n     * @param configId The configId to perform the authorization on the behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An object `LoginResponse` containing all information about the login\r\n     */\r\n    checkAuth(url, configId) {\r\n        return this.checkAuthService.checkAuth(configId, url);\r\n    }\r\n    /**\r\n     * Starts the complete setup flow for multiple configurations.\r\n     * Calling will start the entire authentication flow, and the returned observable\r\n     * will denote whether the user was successfully authenticated including the user data, the access token, the configId and\r\n     * an error message in case an error happened in an array for each config which was provided\r\n     *\r\n     * @param url The URL to perform the authorization on the behalf of.\r\n     * @param configId The configId to perform the authorization on the behalf of. If not passed, all of the current\r\n     * configured ones will be used to check.\r\n     *\r\n     * @returns An array of `LoginResponse` objects containing all information about the logins\r\n     */\r\n    checkAuthMultiple(url, configId) {\r\n        return this.checkAuthService.checkAuthMultiple(configId, url);\r\n    }\r\n    /**\r\n     * Provides information about the current authenticated state\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A boolean whether the config is authenticated or not.\r\n     */\r\n    isAuthenticated(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.authStateService.isAuthenticated(configId);\r\n    }\r\n    /**\r\n     * Checks the server for an authenticated session using the iframe silent renew if not locally authenticated.\r\n     */\r\n    checkAuthIncludingServer(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.checkAuthService.checkAuthIncludingServer(configId);\r\n    }\r\n    /**\r\n     * Returns the access token for the login scenario.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A string with the access token.\r\n     */\r\n    getAccessToken(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.authStateService.getAccessToken(configId);\r\n    }\r\n    /**\r\n     * Returns the ID token for the sign-in.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A string with the id token.\r\n     */\r\n    getIdToken(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.authStateService.getIdToken(configId);\r\n    }\r\n    /**\r\n     * Returns the refresh token, if present, for the sign-in.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A string with the refresh token.\r\n     */\r\n    getRefreshToken(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.authStateService.getRefreshToken(configId);\r\n    }\r\n    /**\r\n     * Returns the authentication result, if present, for the sign-in.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A object with the authentication result\r\n     */\r\n    getAuthenticationResult(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.authStateService.getAuthenticationResult(configId);\r\n    }\r\n    /**\r\n     * Returns the payload from the ID token.\r\n     *\r\n     * @param encode Set to true if the payload is base64 encoded\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns The payload from the id token.\r\n     */\r\n    getPayloadFromIdToken(encode = false, configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        const token = this.authStateService.getIdToken(configId);\r\n        return this.tokenHelperService.getPayloadFromToken(token, encode, configId);\r\n    }\r\n    /**\r\n     * Sets a custom state for the authorize request.\r\n     *\r\n     * @param state The state to set.\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     */\r\n    setState(state, configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        this.flowsDataService.setAuthStateControl(state, configId);\r\n    }\r\n    /**\r\n     * Gets the state value used for the authorize request.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns The state value used for the authorize request.\r\n     */\r\n    getState(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.flowsDataService.getAuthStateControl(configId);\r\n    }\r\n    /**\r\n     * Redirects the user to the Security Token Service to begin the authentication process.\r\n     *\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     * @param authOptions The custom options for the the authentication request.\r\n     */\r\n    authorize(configId, authOptions) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        this.loginService.login(configId, authOptions);\r\n    }\r\n    /**\r\n     * Opens the Security Token Service in a new window to begin the authentication process.\r\n     *\r\n     * @param authOptions The custom options for the authentication request.\r\n     * @param popupOptions The configuration for the popup window.\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An `Observable<LoginResponse>` containing all information about the login\r\n     */\r\n    authorizeWithPopUp(authOptions, popupOptions, configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.loginService.loginWithPopUp(configId, authOptions, popupOptions);\r\n    }\r\n    /**\r\n     * Manually refreshes the session.\r\n     *\r\n     * @param customParams Custom parameters to pass to the refresh request.\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An `Observable<LoginResponse>` containing all information about the login\r\n     */\r\n    forceRefreshSession(customParams, configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.refreshSessionService.userForceRefreshSession(configId, customParams);\r\n    }\r\n    /**\r\n     * Revokes the refresh token (if present) and the access token on the server and then performs the logoff operation.\r\n     * The refresh token and and the access token are revoked on the server. If the refresh token does not exist\r\n     * only the access token is revoked. Then the logout run.\r\n     *\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     * @param authOptions The custom options for the request.\r\n     *\r\n     * @returns An observable when the action is finished\r\n     */\r\n    logoffAndRevokeTokens(configId, authOptions) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.logoffRevocationService.logoffAndRevokeTokens(configId, authOptions);\r\n    }\r\n    /**\r\n     * Logs out on the server and the local client. If the server state has changed, confirmed via check session,\r\n     * then only a local logout is performed.\r\n     *\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     * @param authOptions with custom parameters and/or an custom url handler\r\n     */\r\n    logoff(configId, authOptions) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.logoffRevocationService.logoff(configId, authOptions);\r\n    }\r\n    /**\r\n     * Logs the user out of the application without logging them out of the server.\r\n     * Use this method if you have _one_ config enabled.\r\n     *\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     */\r\n    logoffLocal(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.logoffRevocationService.logoffLocal(configId);\r\n    }\r\n    /**\r\n     * Logs the user out of the application for all configs without logging them out of the server.\r\n     * Use this method if you have _multiple_ configs enabled.\r\n     */\r\n    logoffLocalMultiple() {\r\n        return this.logoffRevocationService.logoffLocalMultiple();\r\n    }\r\n    /**\r\n     * Revokes an access token on the Security Token Service. This is only required in the code flow with refresh tokens. If no token is\r\n     * provided, then the token from the storage is revoked. You can pass any token to revoke.\r\n     * https://tools.ietf.org/html/rfc7009\r\n     *\r\n     * @param accessToken The access token to revoke.\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An observable when the action is finished\r\n     */\r\n    revokeAccessToken(accessToken, configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.logoffRevocationService.revokeAccessToken(configId, accessToken);\r\n    }\r\n    /**\r\n     * Revokes a refresh token on the Security Token Service. This is only required in the code flow with refresh tokens. If no token is\r\n     * provided, then the token from the storage is revoked. You can pass any token to revoke.\r\n     * https://tools.ietf.org/html/rfc7009\r\n     *\r\n     * @param refreshToken The access token to revoke.\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An observable when the action is finished\r\n     */\r\n    revokeRefreshToken(refreshToken, configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.logoffRevocationService.revokeRefreshToken(configId, refreshToken);\r\n    }\r\n    /**\r\n     * Creates the end session URL which can be used to implement an alternate server logout.\r\n     *\r\n     * @param customParams\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A string with the end session url or null\r\n     */\r\n    getEndSessionUrl(customParams, configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.logoffRevocationService.getEndSessionUrl(configId, customParams);\r\n    }\r\n    /**\r\n     * Creates the authorize URL based on your flow\r\n     *\r\n     * @param customParams\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A string with the authorize URL or null\r\n     */\r\n    getAuthorizeUrl(customParams, configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.urlService.getAuthorizeUrl(configId, customParams);\r\n    }\r\n}\r\nOidcSecurityService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: OidcSecurityService, deps: [{ token: CheckSessionService }, { token: CheckAuthService }, { token: UserService }, { token: TokenHelperService }, { token: ConfigurationProvider }, { token: AuthStateService }, { token: FlowsDataService }, { token: CallbackService }, { token: LogoffRevocationService }, { token: LoginService }, { token: RefreshSessionService }, { token: UrlService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nOidcSecurityService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: OidcSecurityService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: OidcSecurityService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: CheckSessionService }, { type: CheckAuthService }, { type: UserService }, { type: TokenHelperService }, { type: ConfigurationProvider }, { type: AuthStateService }, { type: FlowsDataService }, { type: CallbackService }, { type: LogoffRevocationService }, { type: LoginService }, { type: RefreshSessionService }, { type: UrlService }]; } });\n\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\r\nfunction createStaticLoader(passedConfig) {\r\n    return new StsConfigStaticLoader(passedConfig.config);\r\n}\r\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\r\nfunction configurationProviderFactory(oidcConfigService, loader) {\r\n    const allLoadPromises = Promise.all(loader.loadConfigs());\r\n    const fn = () => allLoadPromises.then((configs) => oidcConfigService.withConfigs(configs));\r\n    return fn;\r\n}\r\nconst PASSED_CONFIG = new InjectionToken('PASSED_CONFIG');\r\nclass AuthModule {\r\n    static forRoot(passedConfig) {\r\n        return {\r\n            ngModule: AuthModule,\r\n            providers: [\r\n                // Make the PASSED_CONFIG available through injection\r\n                { provide: PASSED_CONFIG, useValue: passedConfig },\r\n                // Create the loader: Either the one getting passed or a static one\r\n                (passedConfig === null || passedConfig === void 0 ? void 0 : passedConfig.loader) || { provide: StsConfigLoader, useFactory: createStaticLoader, deps: [PASSED_CONFIG] },\r\n                // Load the config when the app starts\r\n                {\r\n                    provide: APP_INITIALIZER,\r\n                    multi: true,\r\n                    deps: [OidcConfigService, StsConfigLoader, PASSED_CONFIG],\r\n                    useFactory: configurationProviderFactory,\r\n                },\r\n                OidcConfigService,\r\n                PublicEventsService,\r\n                FlowHelper,\r\n                ConfigurationProvider,\r\n                OidcSecurityService,\r\n                TokenValidationService,\r\n                PlatformProvider,\r\n                CheckSessionService,\r\n                FlowsDataService,\r\n                FlowsService,\r\n                SilentRenewService,\r\n                LogoffRevocationService,\r\n                UserService,\r\n                RandomService,\r\n                HttpBaseService,\r\n                UrlService,\r\n                AuthStateService,\r\n                SigninKeyDataService,\r\n                StoragePersistenceService,\r\n                TokenHelperService,\r\n                LoggerService,\r\n                IFrameService,\r\n                EqualityService,\r\n                LoginService,\r\n                ParService,\r\n                AuthWellKnownDataService,\r\n                AuthWellKnownService,\r\n                DataService,\r\n                StateValidationService,\r\n                ConfigValidationService,\r\n                CheckAuthService,\r\n                ResetAuthDataService,\r\n                ImplicitFlowCallbackService,\r\n                HistoryJwtKeysCallbackHandlerService,\r\n                ResponseTypeValidationService,\r\n                UserCallbackHandlerService,\r\n                StateValidationCallbackHandlerService,\r\n                RefreshSessionCallbackHandlerService,\r\n                RefreshTokenCallbackHandlerService,\r\n                CodeFlowCallbackHandlerService,\r\n                ImplicitFlowCallbackHandlerService,\r\n                ParLoginService,\r\n                PopUpLoginService,\r\n                StandardLoginService,\r\n                AutoLoginService,\r\n                JsrsAsignReducedService,\r\n                CurrentUrlService,\r\n                ClosestMatchingRouteService,\r\n                DefaultSessionStorageService,\r\n                BrowserStorageService,\r\n            ],\r\n        };\r\n    }\r\n}\r\nAuthModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\r\nAuthModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthModule, imports: [CommonModule, HttpClientModule] });\r\nAuthModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthModule, imports: [[CommonModule, HttpClientModule]] });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthModule, decorators: [{\r\n            type: NgModule,\r\n            args: [{\r\n                    imports: [CommonModule, HttpClientModule],\r\n                    declarations: [],\r\n                    exports: [],\r\n                }]\r\n        }] });\n\nclass AutoLoginAllRoutesGuard {\r\n    constructor(autoLoginService, checkAuthService, loginService, configurationProvider) {\r\n        this.autoLoginService = autoLoginService;\r\n        this.checkAuthService = checkAuthService;\r\n        this.loginService = loginService;\r\n        this.configurationProvider = configurationProvider;\r\n    }\r\n    canLoad(route, segments) {\r\n        const routeToRedirect = segments.join('/');\r\n        return this.checkAuth(routeToRedirect);\r\n    }\r\n    canActivate(route, state) {\r\n        return this.checkAuth(state.url);\r\n    }\r\n    canActivateChild(route, state) {\r\n        return this.checkAuth(state.url);\r\n    }\r\n    checkAuth(url) {\r\n        const configId = this.getId();\r\n        return this.checkAuthService.checkAuth().pipe(take(1), map(({ isAuthenticated }) => {\r\n            if (isAuthenticated) {\r\n                this.autoLoginService.checkSavedRedirectRouteAndNavigate(configId);\r\n            }\r\n            if (!isAuthenticated) {\r\n                this.autoLoginService.saveRedirectRoute(configId, url);\r\n                this.loginService.login(configId);\r\n            }\r\n            return isAuthenticated;\r\n        }));\r\n    }\r\n    getId() {\r\n        return this.configurationProvider.getOpenIDConfiguration().configId;\r\n    }\r\n}\r\nAutoLoginAllRoutesGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AutoLoginAllRoutesGuard, deps: [{ token: AutoLoginService }, { token: CheckAuthService }, { token: LoginService }, { token: ConfigurationProvider }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAutoLoginAllRoutesGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AutoLoginAllRoutesGuard, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AutoLoginAllRoutesGuard, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: AutoLoginService }, { type: CheckAuthService }, { type: LoginService }, { type: ConfigurationProvider }]; } });\n\nclass AutoLoginPartialRoutesGuard {\r\n    constructor(autoLoginService, authStateService, loginService, configurationProvider) {\r\n        this.autoLoginService = autoLoginService;\r\n        this.authStateService = authStateService;\r\n        this.loginService = loginService;\r\n        this.configurationProvider = configurationProvider;\r\n    }\r\n    canLoad(route, segments) {\r\n        const routeToRedirect = segments.join('/');\r\n        return this.checkAuth(routeToRedirect);\r\n    }\r\n    canActivate(route, state) {\r\n        return this.checkAuth(state.url);\r\n    }\r\n    canActivateChild(route, state) {\r\n        return this.checkAuth(state.url);\r\n    }\r\n    checkAuth(url) {\r\n        const configId = this.getId();\r\n        const isAuthenticated = this.authStateService.areAuthStorageTokensValid(configId);\r\n        if (isAuthenticated) {\r\n            this.autoLoginService.checkSavedRedirectRouteAndNavigate(configId);\r\n        }\r\n        if (!isAuthenticated) {\r\n            this.autoLoginService.saveRedirectRoute(configId, url);\r\n            this.loginService.login(configId);\r\n        }\r\n        return isAuthenticated;\r\n    }\r\n    getId() {\r\n        return this.configurationProvider.getOpenIDConfiguration().configId;\r\n    }\r\n}\r\nAutoLoginPartialRoutesGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AutoLoginPartialRoutesGuard, deps: [{ token: AutoLoginService }, { token: AuthStateService }, { token: LoginService }, { token: ConfigurationProvider }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAutoLoginPartialRoutesGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AutoLoginPartialRoutesGuard, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AutoLoginPartialRoutesGuard, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: AutoLoginService }, { type: AuthStateService }, { type: LoginService }, { type: ConfigurationProvider }]; } });\n\nclass AuthInterceptor {\r\n    constructor(authStateService, configurationProvider, loggerService, closestMatchingRouteService) {\r\n        this.authStateService = authStateService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.loggerService = loggerService;\r\n        this.closestMatchingRouteService = closestMatchingRouteService;\r\n    }\r\n    intercept(req, next) {\r\n        if (!this.configurationProvider.hasAsLeastOneConfig()) {\r\n            return next.handle(req);\r\n        }\r\n        const allConfigurations = this.configurationProvider.getAllConfigurations();\r\n        const allRoutesConfigured = allConfigurations.map((x) => x.secureRoutes || []);\r\n        const allRoutesConfiguredFlat = [].concat.apply([], allRoutesConfigured);\r\n        if (allRoutesConfiguredFlat.length === 0) {\r\n            const { configId } = allConfigurations[0];\r\n            this.loggerService.logDebug(configId, `No routes to check configured`);\r\n            return next.handle(req);\r\n        }\r\n        const { matchingConfigId, matchingRoute } = this.closestMatchingRouteService.getConfigIdForClosestMatchingRoute(req.url);\r\n        if (!matchingConfigId) {\r\n            const { configId } = allConfigurations[0];\r\n            this.loggerService.logDebug(configId, `Did not find any configured route for route ${req.url}`);\r\n            return next.handle(req);\r\n        }\r\n        this.loggerService.logDebug(matchingConfigId, `'${req.url}' matches configured route '${matchingRoute}'`);\r\n        const token = this.authStateService.getAccessToken(matchingConfigId);\r\n        if (!token) {\r\n            this.loggerService.logDebug(matchingConfigId, `Wanted to add token to ${req.url} but found no token: '${token}'`);\r\n            return next.handle(req);\r\n        }\r\n        this.loggerService.logDebug(matchingConfigId, `'${req.url}' matches configured route '${matchingRoute}', adding token`);\r\n        req = req.clone({\r\n            headers: req.headers.set('Authorization', 'Bearer ' + token),\r\n        });\r\n        return next.handle(req);\r\n    }\r\n}\r\nAuthInterceptor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthInterceptor, deps: [{ token: AuthStateService }, { token: ConfigurationProvider }, { token: LoggerService }, { token: ClosestMatchingRouteService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAuthInterceptor.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthInterceptor });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthInterceptor, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: AuthStateService }, { type: ConfigurationProvider }, { type: LoggerService }, { type: ClosestMatchingRouteService }]; } });\n\n/**\r\n * Implement this class-interface to create a custom storage.\r\n */\r\nclass AbstractSecurityStorage {\r\n}\r\nAbstractSecurityStorage.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AbstractSecurityStorage, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nAbstractSecurityStorage.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AbstractSecurityStorage });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AbstractSecurityStorage, decorators: [{\r\n            type: Injectable\r\n        }] });\n\n// Public classes.\n\n/*\r\n * Public API Surface of angular-auth-oidc-client\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { AbstractSecurityStorage, AuthInterceptor, AuthModule, AutoLoginAllRoutesGuard, AutoLoginPartialRoutesGuard, EventTypes, LogLevel, LoggerService, OidcConfigService, OidcSecurityService, OpenIdConfigLoader, PASSED_CONFIG, PopUpService, PublicEventsService, StateValidationResult, StsConfigHttpLoader, StsConfigLoader, StsConfigStaticLoader, TokenHelperService, TokenValidationService, ValidationResult, configurationProviderFactory, createStaticLoader };\n"]},"metadata":{},"sourceType":"module"}